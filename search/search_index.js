var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"About This Site","text":"<p>This is the content site for Johns Hopkins University Whiting School of Engineering's 605.686 Mobile Development for the Android Platform.</p> <p>All code and content is open source and free for use. Please see the <code>LICENSE-code.md</code> and <code>LICENSE-content.md</code> files for license details.</p>"},{"location":"index.html#using-this-site","title":"Using this site","text":"<p>I recommend viewing this site on a desktop or laptop, full screen.</p> <p>Navigation links will be visible on the left if there is enough screen space. Otherwise, a \"hamburger menu\" navigation button will appear in the upper left corner of the site; click on it and you can navigate. </p> <p>If the search box isn't focused, you can hit <code>P</code> or <code>,</code> to go to the previous page and <code>N</code> or <code>.</code> to go to the next page.</p>"},{"location":"modules/android-studio/index.html","title":"Video","text":"<p>Watch the following video overview of setting up Android Studio, creating and running a project, and a walkthrough of some Android Studio features.</p> <p>Note</p> <p>After setting up, take a look at Configure hardware acceleration for the Android Emulator to ensure your emulator is set up for acceleration.</p> <p>If you experience mouse stuttering when running an Android Virtual Device (AVD), try deleting the AVD and creating a new one. When creating, check the Hardware GLES 2.0 graphics option (you can change it to Software GLES 2.0 if things get wonky).</p> <p>Note</p> <p>I recommend you watch the video at its recorded resolution (FHD - 1920x1080) if possible.</p> <p>You can change the quality and playback speed by clicking the  icon when the video is playing. </p> <p>If you would like to search the captions for this video, click Watch on YouTube, press \"...\" and choose Show Transcript.</p>"},{"location":"modules/architecture/index.html","title":"Overview","text":"<p>Before we start writing code, let's talk about how we should organize our application.</p> <p>Over the years there have been many best practices for organizing code. These practices evolve as technologies change and we learn from maintaining previous approaches.</p> <p>When we look at the application as a whole and consider all of its high-level parts, we're talking about the architecture of the application. The architecture describes the general division of responsibilities in your application, and which parts communicate with which other parts. </p> <p>Breaking your application into chunks allows for</p> <ul> <li>Easier discussion of how the application works</li> <li>Easier developer tasking (especially in larger applications)</li> <li>Reuse of chunks across different types of applications (reusing the data layer, for example, across mobile apps, web services, and command-line applications)</li> <li>Easier independent testing of separate parts of your application</li> </ul> <p>The architecture we use in this class is based on Modern Android Development, also known as \"MAD\". See https://developer.android.com/modern-android-development, which includes architecture, tools and libraries that Google recommends for Android development.</p>"},{"location":"modules/architecture/index.html#architecture-overview","title":"Architecture Overview","text":"<p>Applications are structured as Layers and Modules.</p> <p>A \"module\" is a separately-compilable group of code and resources that can be consumed by other modules in your system. They're useful for isolating functionality, internal implementation details can be hidden while exposing a subset of function, its public API (Application Programming Interface). Separating code into modules also helps large applications isolate changes that many developers are making at the same time.</p> <p>A \"layer\" is a grouping of one or more modules with certain responsibilities. Layers allow you to explicitly define communication between modules and further improve ease of maintenance.</p> <p>Application Layers</p> <pre><code>graph TD\n    UI[User-Interface Layer] --&gt;|depends on| Domain\n    Domain[Domain Layer] --&gt;|depends on| Data[Data Layer]</code></pre> <p>At a high level, we talk about application layers, separating data from its manipulation and presentation.</p> <p>Each layer isolates a responsibility in the application. At its simplest, each layer could be exactly one module. (While layers could be just conceptual grouping of code/resources that are all in a single module, using at least one module per layer gives us the ability to restrict what's exposed between layers.)</p> <p>Layers could contain multiple modules, which I recommend as the application grows in size.</p> <p>The Data Layer manages data acquisition and update. You can use it to persist data locally in a database, file or in memory. Or maybe your application connects to a server for its data; you can use the Data Layer to connect to a server to grab data and push changes. </p> <p>By keeping your data access code inside the Data Layer, you can abstract and hide the how data is accessed from the rest of the application. If your data management code changes over time, the rest of the application may require fewer changes to adapt. </p> <p>Operations in the Data Layer are sometimes called Primitive Operations, as they're the core, often simplest, operations you define on your data. Many primitive operations are simply property changes to objects and CRUD operations (Create/Read/Update/Delete) against your data store. You may also define more complex operations that are always needed for any user of the data. </p> <p>The Data Layer doesn't depend upon other architectural layers, but may depend upon other modules/libraries such as database storage or network communication.</p> <p>The Domain Layer is an optional layer that increases in value as the size of your application grows. Often you'll find that several parts of your application need to perform the same sequences of primitive operations. For example, a game might have several places that put an item in the player's inventory. It would be a great idea to create a function to contain the repeated code, but where do we put that function?</p> <p>In a smaller application, you could add a function in the User-Interface Layer, and you've successfully factored out that common functionality.</p> <p>As the application grows, the user interface might be broken down into multiple modules. Which UI module should host that functionality?</p> <p>Or if you want to use the same \"put item in inventory\" for an Android application, desktop application, and web application, you no longer have a common user interface to host it.</p> <p>A Domain Layer hosts this type of common functionality and gives you access from any user interface components, within the same application or across multiple applications.</p> <p>These types of operations are generally called \"macro operations\". They build upon primitive operations by combining primitives to create more complex processing of the data.</p> <p>In recent architectures, these types of operations are called Use Cases or Interactors.</p> <p>The Domain Layer only depends upon the architectural Data Layer for access to its data. It can also depend upon other modules/libraries that provide frameworks, algorithms or support functions to work with the data.</p> <p>Finally, we use our User-Interface Layer to present data to the user and interpret their actions. This layer can present the data using many different approaches: graphically, textually, as a service, or using assistive technologies for example.</p> <p>Note</p> <p>I've called out \"as a service\" as a type of User-Interface implementation. Think about what it means to be a \"user\". The \"outsider\" that's interacting with your application is its user. That could be a person, or it could be other applications. When we think of a service (such as a web service) as a \"user interface\", we're talking about a layer that prepares data for presentation (creating a JSON output, for example) and interprets user interaction (receives the service call, figures out what it means, and calls the appropriate functionality in the Domain (if present) or Data layers.)</p> <p>The User-Interface Layer only depends on the Domain Layer (if present) or the Data Layer. This is somewhat controversial; some want to allow the User-Interface Layer to use the Domain Layer for complex operations, and skip past it directly access the Data Layer for simpler operations. The problem here is that it's possible to miss added value in the Domain Layer with this approach.</p> <p>Suppose you have a Domain Layer that exposes macro operations to the User-Interface Layer, and also passes-through primitive operations from the Data Layer. If we allow the User-Interface Layer a choice of which layer it wants to work with, it may miss changes that the Domain Layer makes. For example, later on, as part of the simpler pass-throughs, if the Domain Layer adds some logging and verification (that the Data Layer doesn't have), it will be missed if the User-Interface Layer skipped around the Domain Layer to directly communicate with the Data Layer. </p> <p>When using a Domain Layer, all User-Interface Layer modules must only depend on modules in the Domain Layer.</p>"},{"location":"modules/architecture/STEP_020_FULL.html","title":"Data Layer","text":"<p>Let's dive a little deeper into the Data Layer.</p> <p>The most basic part of the Data Layer is a Data Source. This is where you access your data. It could be a local or remote database, a web service, a file or another place to store your data. The data in this layer is usually persisted so it can be accessed across runs of the application.</p> <p>Sometimes your application may use more than one data source. For example, if your application managed contacts, they might be stored in a server for access across devices. To reduce the user's network use, you may also have a local database that stores any contacts that have been previously accessed. </p> <p>So how do you decide which data source to use? </p> <p>Add a repository module. A repository can act as a switch between data sources. If the repository is asked for a contact, it checks to see if it's in the local-database data source. If so, it just returns it; no network communication needed! If not, it grabs the contact from the network, stores it in the local database, then returns it. (We're ignoring data that's been changed on the server in this example, but there are other technologies that make that easy to manage.)</p> <pre><code>flowchart LR\n    other[User Interface/Domain Layer] --&gt; repo\n    ds1 --&gt; db[(Database)]\n    ds2 --&gt; file(((File)))\n    ds3 --&gt; ws(((Web Service)))\n    subgraph Data Layer\n    direction LR\n    repo[Repository] --&gt; ds1[Data Source 1]\n    repo[Repository] --&gt; ds2[Data Source 2]\n    repo[Repository] --&gt; ds3[Data Source 3]\n    end</code></pre> <p>(Arrows represent dependencies)</p> <p>The repository can also perform another useful function - convert data that's used directly by a data source to data that can be returned to other layers. This conversion can</p> <ul> <li>limit which data is available to other layers (hiding data that you don't want to expose)</li> <li>add new data that's derived from a data source or pulled in from other sources</li> <li>change the accessibility of data, commonly making it immutable</li> <li>return objects that implement interfaces required by other layers</li> </ul> <p>One of the most important things we'll learn about our User-Interface Layer is that immutable data makes everything more reliable and can help frameworks like Jetpack Compose optimize what needs to be refreshed. Immutable data stops its users for directly modifying it; they must use other functions to make changes, functions that will then know that changes are being made. This allows for easy enforcement of Unidirectional Data Flow, which we'll talk about later.</p> <p>The repository copies the data from the actual data objects (often known as \"entities\") and creates Data Transfer Objects (DTOs) to carry that data. DTOs are often immutable, and can also restrict which data is visible or enhance the data with derived properties. DTOs may be a simple wrapper (an \"Adapter\" in design-pattern parlance), or an entirely-separate object that holds a copy of the data.</p> <p>Using a repository helps abstract the way the data is accessed outside the Data Layer. Depending on your level of abstraction, this may result in better isolation between the layers. Changes to how you store data become less likely to force changes outside the Data Layer.</p> <p>Note</p> <p>\"Less likely\" depends on the amount of abstraction used when exposing data from the data layer, and this is a tradeoff. Higher abstraction requires more types (interfaces and/or classes) to be defined and maintained and reduces required external changes. Lower abstraction (such as directly passing data that's managed by your database) is less to develop and maintain, but requires more to change outside the layer when data-later internals change.</p> <p>Think about how likely change is in your application. Is it likely you'll switch data sources? Is it likely the app will only be an Android application, or might you want to use parts of it in a desktop or web application? (Eventually, I think that Kotlin Multiplatform [KMP] will also allow easy reuse of much of your code on iOS as well.)</p>"},{"location":"modules/architecture/STEP_030_FULL.html","title":"Domain Layer","text":"<p>The Domain Layer is optional, and we won't be using it in this class. It's overkill for small applications. As your applications grow, it becomes a much more useful.</p> <pre><code>flowchart LR\n    ui[User Interface Layer]\n    ui --&gt; uc1\n    ui --&gt; uc2\n    ui --&gt; uc3\n    ui --&gt; data\n    data --&gt; repo\n    uc1 --&gt; repo\n    uc2 --&gt; repo\n    uc3 --&gt; repo\n    ds1 --&gt; db[(Database)]\n    ds2 --&gt; file(((File)))\n    ds3 --&gt; ws(((Web Service)))\n    subgraph Domain Layer\n    direction LR\n    data[Data]\n    uc1[Use Case 1]\n    uc2[Use Case 2]\n    uc3[Use Case 3]\n    end\n    subgraph Data Layer\n    direction LR\n    repo[Repository] --&gt; ds1[Data Source 1]\n    repo[Repository] --&gt; ds2[Data Source 2]\n    repo[Repository] --&gt; ds3[Data Source 3]\n    end</code></pre> <p>(Arrows represent dependencies)</p> <p>The gist of this layer is that is exposes data from the Data Layer along with Use Cases for common data modifications.</p> <p>For more detail on the Domain Layer, please see https://developer.android.com/topic/architecture/domain-layer.</p> <p>You may also be interested in learning about \"Clean Architecture\", which explains the use of a Domain Layer. Be careful though - adding a Domain Layer can increase the complexity of a smaller app and make its maintenance burdensome - you'll have to find that line, and much of depends on how many developers will be working on the same application. If only a few, it's best to keep it simple. If many developers on a larger application, the extra separation and explicit use cases can be a great help.</p>"},{"location":"modules/architecture/STEP_040_FULL.html","title":"User-Interface Layer","text":"<p>The User Interface Layer is likely where most of your changes will happen, and will usually involve much more detailed code.</p> <p>There are two major concepts in this layer:</p> <ul> <li>State - the data used to present the user interface</li> <li>User Interface - the means of allowing the user to consume and interact with the data</li> </ul>"},{"location":"modules/architecture/STEP_040_FULL.html#state","title":"State","text":"<p>State includes data from other layers as well as data that's only used for controlling the user interface. If you have an application that's displaying contact information, the contact data comes from the other layers and is the \"what\" that you want to display. But you'll also need other information such as </p> <ul> <li>What screen is user seeing?</li> <li>Which position in a list is at the top?</li> <li>What field currently has focus?</li> </ul> <p>Some data only makes sense for a specific user interface. It's easiest to determine which data this is if you ask yourself \"would I need this data for a graphical user interface, a command-line interface, and a web service?\" If so, the data likely belongs in the Data Layer. Otherwise, the data only exists in the User-Interface Layer.</p> <p>Our goals in the User-Interface Layer are to</p> <ul> <li>Observe state changes</li> <li>Prepare our state for presentation to the user</li> <li>Interpret user interaction</li> <li>Update the state as needed (which will trigger our observers)</li> </ul> <p>We'll be using Jetpack Compose as our user interface in this class.Compose has great state-management support, often making the state observation invisible, but sometimes it can be tricky to set up. We'll work through several types of state use in this class, but be aware that best practices for state are still being developed and may change from what I present. Keep an eye on https://developer.android.com/ site and the https://android-developers.googleblog.com/ blog for emerging details.</p> <p>As part of the User-Interface Layer responsibilities, we need to prepare and update state. This function is usually managed by a View Model.</p>"},{"location":"modules/architecture/STEP_040_FULL.html#view-models","title":"View Models","text":"<p>The concept of a View Model is simple - it's a place to manage state preparation and updates. </p> Without Domain LayerWith Domain Layer <pre><code>flowchart LR\n    subgraph User Interface Layer\n    ui[User Interface] --&gt; vm[View Model]\n    end\n    vm --&gt; repo\n    ds1 --&gt; db[(Database)]\n    ds2 --&gt; file(((File)))\n    ds3 --&gt; ws(((Web Service)))\n    subgraph Data Layer\n    direction LR\n    repo[Repository] --&gt; ds1[Data Source 1]\n    repo[Repository] --&gt; ds2[Data Source 2]\n    repo[Repository] --&gt; ds3[Data Source 3]\n    end</code></pre> <pre><code>flowchart LR\n    subgraph User Interface Layer\n    ui[User Interface] --&gt; vm[View Model]\n    end\n    vm --&gt; uc1\n    vm --&gt; uc2\n    vm --&gt; uc3\n    vm --&gt; data\n    uc1 --&gt; repo\n    uc2 --&gt; repo\n    uc3 --&gt; repo\n    data --&gt; repo\n    ds1 --&gt; db[(Database)]\n    ds2 --&gt; file(((File)))\n    ds3 --&gt; ws(((Web Service)))\n    subgraph Domain Layer\n    direction LR\n    data[Data]\n    uc1[Use Case 1]\n    uc2[Use Case 2]\n    uc3[Use Case 3]\n    end\n    subgraph Data Layer\n    direction LR\n    repo[Repository] --&gt; ds1[Data Source 1]\n    repo[Repository] --&gt; ds2[Data Source 2]\n    repo[Repository] --&gt; ds3[Data Source 3]\n    end</code></pre> <p>(Arrows represent dependencies)</p> <p>Note</p> <p>You may have multiple view models. Some developers prefer one view model per screen, others prefer by types of data, and others prefer a single view model. The decision often depends on the size of the application as well.</p> <p>A view model creates state to be used by the user interface. In some cases, it may just pass the state along. In other cases, it may modify or combine state from underlying layers.</p> <p>View model functions allow the user interface to tell it what the user wants to do, such as adding/deleting a contact or switching to a different screen. These functions will interact with the Domain Layer (if present) or Data Layer to update the data.</p> <p>The view model needs to expose the state in a way that the user interface can observe it. Depending on the UI framework being used, the state might be exposed using the Observer pattern, using Android <code>LiveData</code>, Jetpack Compose <code>State</code> objects, Kotlin <code>Flow</code>s or other approaches. </p> <p>For our work, we'll be using Kotlin <code>Flow</code>s and Compose <code>State</code>s. We'll talk about what those are in later modules.</p>"},{"location":"modules/architecture/STEP_040_FULL.html#composable-functions","title":"Composable Functions","text":"<p>For our user interfaces, we'll use Jetpack Compose to declare our user interface.</p> <p>In a nutshell, you'll create Composable functions in Kotlin. These functions will emit descriptions of parts of the user interface to a tree. The Compose UI framework will look at this tree and create a user interface.</p> <p>The cool thing is that Compose can watch the parameters passed to a Composable function. If the values change from one call to the next, it will recompose, emitting a replacement for the part of the tree that it previously emitted. The Compose UI will then detect changes and refresh only the parts of the UI that need to be refreshed.</p>"},{"location":"modules/architecture/STEP_050_FULL.html","title":"Data Objects","text":"<p>Different types of data flow between different parts of the application. Your application may use</p> <ul> <li>Raw data - data obtained in its raw form from a database, file, service, etcetera. The data source formats it into an object to be passed back to the repository</li> <li>Entities - data obtained from data sources</li> <li>Data Transfer Objects (DTOs) - data abstracted/restricted before being passed out of the Data Layer</li> <li>State - data prepared for use in the user interface</li> </ul> <p>A typical flow of data might look like</p> Without Domain LayerWith Domain Layer <pre><code>flowchart RL\n    subgraph User Interface Layer\n    vm[View Model] --&gt;|State| ui[User Interface]\n    end\n    repo --&gt;|DTO| vm\n    db[(Database)] --&gt;|raw| ds\n    subgraph Data Layer\n    ds[Data Source] --&gt;|Entity| repo[Repository]\n    end</code></pre> <pre><code>flowchart RL\n    subgraph User Interface Layer\n    vm[View Model] --&gt;|State| ui[User Interface]\n    end\n    Data\n    data --&gt;|DTO| vm\n    repo --&gt;|DTO| data\n    db[(Database)] --&gt;|raw| ds\n    subgraph Domain Layer\n    direction TB\n    data[Data]\n    uc[Use Case]\n    end\n    subgraph Data Layer\n    ds[Data Source] --&gt;|Entity| repo[Repository]\n    end</code></pre>"},{"location":"modules/architecture/STEP_060_FULL.html","title":"Events","text":"<p>So how do we make changes? That's where events come in.</p> <p>The user interface receives user interactions, such as key and button presses, and interprets their meaning. It then calls Event functions to trigger state changes.</p> <p>When using Jetpack Compose, these event functions are typically Kotlin lambdas passed into the functions we use to create the user interface. Most of these lambdas will call functions in the view model; others may update some local state in the user interface itself.</p> Without Domain LayerWith Domain Layer <pre><code>flowchart LR\n    subgraph User Interface Layer\n    ui[User Interface] --&gt;|\"event()\"| vm[View Model]\n    end\n    vm --&gt;|\"update()\"| repo\n    ds --&gt;|query| db[(Database)]\n    subgraph Data Layer\n    repo[Repository] --&gt;|\"update()\"| ds[Data Source]\n    end</code></pre> <pre><code>flowchart LR\n    subgraph User Interface Layer\n    ui[User Interface] --&gt;|\"event()\"| vm[View Model]\n    end\n    vm --&gt;|\"update()\"| uc\n    uc --&gt;|\"update()\"| repo\n    ds --&gt;|query| db[(Database)]\n    subgraph Domain Layer\n    direction TB\n    data[Data]\n    uc[Use Case]\n    end\n    subgraph Data Layer\n    repo[Repository] --&gt;|\"update()\"| ds[Data Source]\n    end</code></pre> <p>We'll see how this works when we start coding our user interface.</p>"},{"location":"modules/architecture/STEP_070_FULL.html","title":"Concurrency","text":"<p>User interfaces are typically updated via a single thread. That thread is responsible for drawing any needed changes and responding to user interactions. The UI should respond immediately to interactions such as pressing a button, scrolling the screen, or drawing pictures with their finger. </p> <p>Many user actions result in performing data updates, which can be expensive. If we perform these actions on the same thread that detected the user interaction, all screen updates are blocked until that update has completed. At best, this can result in \"jank\", an interface that doesn't immediately respond and jumps between drawn frames. At worst, an update might take long enough that the user interface freezes.</p> <p>The easiest fix for this is to run data updates on a different thread so the user interface can keep responding immediately. We'll do this using Kotlin Coroutines, but it could also be done using threads and executors.</p> <p>While the UI is now responsive, we can run into data synchronization, race and deadlock issues. Fortunately there are several patterns we can follow to more reliably work with concurrent processing.</p> <p>One of the most effective ways to help is to use a Unidirectional Data Flow, or UDF.</p>"},{"location":"modules/architecture/STEP_080_FULL.html","title":"Unidirectional Data Flow","text":"<p>By passing data into functions, and receiving event calls out, we remove the possibility of data changing while it's being read.</p> <p>Jetpack Compose's <code>Composable</code> functions take parameters for data and events. For example, we might define a \"submit button\" function:</p> <pre><code>@Composable\nfun Submit(\n    buttonText: String,\n    onButtonPress: () -&gt; Unit,\n) {\n    ...\n}\n</code></pre> <p>Note</p> <p>The convention for Composable functions that emit ui nodes to the tree is that they are named using <code>UpperCamelCase()</code>. This feels a bit weird, but the idea is that we're treating these functions as declarations of what the ui looks like, not imperative code to build a UI. Declarations feel more like class or interface definitions, hence the case.</p> <p>The <code>buttonText</code> is data coming in; the <code>Submit()</code> function will emit a button to the tree that displays that text. <code>Submit()</code> will also attach a \"click listener\" to the button. When the button is pressed, it will call <code>onButtonPress()</code> to tell the caller of <code>Submit()</code> that the button was pressed.</p> <p>Data comes in; events go out. That's Unidirectional Data Flow.</p> <p>Somewhere up at the top of the call chain, a lambda is passed in to be used as that <code>onButtonPress</code> parameter, and it contains the code to perform the update.</p> <p>That lambda should immediately switch to a different thread to perform its work. We'll do this by launching a coroutine to perform the work. At the end of the coroutine, new data will be set for the state and passed in.</p> <p>For this example, if the new state contains the <code>buttonText</code> that's passed into <code>SubmitButton()</code>, the UI will be updated.</p> <p>We'll dig into this when we start talking about Jetpack Compose. For now, all you need to know is we'll be pushing data and event functions into the Composable functions, and call the event functions to indicate that something has changed. </p>"},{"location":"modules/compose-concepts/index.html","title":"Compose Concepts","text":"<p>Jetpack Compose is the recommended User Interface (UI) framework for use when developing Android applications. It greatly simplifies creation of UIs and management of state used by those UIs. It can be deceptively simple at times, and if you don't understand some of what's going on behind the scenes, it'll seem like magic, and possibly result in some tricky bugs to resolve.</p> <p>In this module, we'll start with the basic concepts, and drill in for some deeper discussion on how Compose uses state to determine when the UI should update.</p> <p>The \"big idea\" of Compose is fairly simple:</p> <ul> <li>Compose is declarative. You declare your user interface in \"composable functions\", rather than create it. Think of it as telling the framework what you want, rather than how to create it.</li> <li>Compose is unidirectional. You pass data in, and get events out. Many user interface frameworks encourage modification of data inside the UI elements you create. This can make it difficult to test data flow and reason about how the application behaves. In Compose, you:<ul> <li>Pass data to composable functions that declare the UI.</li> <li>Pass callback \"event\" functions to those composable functions.</li> <li>The composable function calls the event functions to tell the caller \"something happened\".</li> </ul> </li> </ul>"},{"location":"modules/compose-concepts/STEP_020_FULL.html","title":"Composable Functions","text":"<p>How does Compose create your user interface?</p> <ol> <li>Composition - composable functions run to declare the user interface in a tree of nodes. (Behind the scenes it uses a Gap buffer, but conceptually it's a tree.)</li> <li>Layout - compose examines the tree and determines the size of each element and where to place it on the screen.</li> <li>Drawing - compose renders the elements on the screen for the user to interact with.</li> </ol> <p>Things get interesting when the data passed to a composable function changes. This triggers \"recomposition\". Compose determines which parts of the UI tree are affected by the changed data, and re-runs the composable functions that created those parts. This updates or replaces parts of the tree. The layout and drawing phases follow, updating the changed parts of the UI.</p> <p>To make this work efficiently and correctly, you need to follow a few rules:</p> <ul> <li>Composable functions must be idempotent. This means that they must always produce the same output when run with the same parameter values. If this isn't the case, Compose would need to refresh the entire UI every time, as it couldn't tell which parts might change.</li> <li>Composable functions should only base their UI declaration on parameters and composition locals (more on that later). They shouldn't reach out to other external objects for data.</li> <li>Composable functions must be free of uncontrolled side effects (we'll talk about controlled side-effects later). They should not directly modify external data or call external functions. Their only communication with the outside world must be through event functions that are passed in.</li> </ul> <p>Composable functions are annotated with <code>@Composable</code>. For example:</p> <pre><code>@Composable\nfun MyList(\n    data: List&lt;String&gt;,\n    onClick: (String) -&gt; Unit,\n) {\n    ...\n}\n</code></pre> <p>This annotation is processed by the Compose Compiler plugin, which runs while the Kotlin compiler is processing your source files.</p> <p>Behind the scenes, this plugin modifies the function, adding some parameters and setting up code to define a scope for all operations inside the function. The generated code works with the runtime to build the UI-declaration tree, keep track of which state has been read, and invoke the function as part of recomposition. If you're interested in more detail, see Under the hood of Jetpack Compose.</p> <p>To determine if a composable function needs to be recomposed, a <code>Snapshot</code> tracks the state used by that function. When the snapshot sees new state that doesn't match the last-rendered state, it triggers recomposition.</p>"},{"location":"modules/compose-concepts/STEP_020_FULL.html#extending-a-composable-function","title":"\"Extending\" a composable function","text":"<p>Many UI toolkits define classes to represent elements in the UI. You can often create subclasses to define new functionality or set common attributes in a single place for consistency in your application.</p> <p>Because Compose uses functions to declare the UI, there's nothing to subclass.</p> <p>To \"extend\" a composable function, you simply write a new function that calls it, passing in common values for parameters or defining a common structure.</p> <p>For example, a common pattern in Compose is defining a button:</p> <pre><code>Button(\n    onClick = {\n        // what to do when the button is pressed\n    },\n    modifier = Modifier.padding(8.dp)\n) {\n    Text(text = text, modifier = Modifier.padding(8.dp))\n}\n</code></pre> <p>This is very flexible (as you can define whatever you would like inside the button, such as a <code>Row</code> containing an <code>Icon</code> and <code>Text</code>), but a but verbose to write every time you want a button.</p> <p>You likely have some common attributes you'd like for a button, such as a padding between the border of the button and its contained text, as well as padding outside of the button between it and other components.</p> <p>We can simplify the above definition with a custom function:</p> <pre><code>@Composable\nfun MyButton(\n    text: String,\n    onClick: () -&gt; Unit,\n) =\nButton(\n    onClick = onClick,\n    modifier = Modifier.padding(8.dp)\n) {\n    Text(text = text, modifier = Modifier.padding(8.dp))\n}\n</code></pre> <p>We've pulled in the common code into our own function to create our button, which we can now call using</p> <pre><code>MyButton(\"Press Me\") {\n    // what to do when the button is pressed\n}\n</code></pre> <p>This locks in the modifier and simplifies the call considerably.</p>"},{"location":"modules/compose-concepts/STEP_030_FULL.html","title":"String literals","text":"<p>This brings up an interesting consideration. In the above example we hardcoded \"Press Me\" as a button label. We're assuming the language and possibly regional dialect used by the user.</p> <p>Fortunately, Android makes it simple to apply internationalization (aka \"I18N\" - the \"18\" is how many letters between the \"I\" and \"N\") to your application.</p> <p>Internationalization is the process of externalizing locale-specific details from your code. At its simplest, you extract string literals into a file, and organize copies of that file with different translations into different resource directories. Each translation is made available based on the language settings of the user.</p> <p>More fine-grained I18N includes extracting details of how currency, numbers and pluralization is represented in your application.</p> <p>We'll use the most-basic I18N support in this class - extracting string literals. To do this, you'll edit (or create) <code>app/src/main/res/values/strings.xml</code> and add any user-facing string literal there. (Do not add things like fixed file names in there, as they could end up with different values based on the device configuration!) For example:</p> <pre><code>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n\n    &lt;string name=\"movies\"&gt;Movies that are rated %1$s&lt;/string&gt;\n    &lt;string name=\"filmography\"&gt;Films that feature %1$s&lt;/string&gt;\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n\n    ...\n&lt;/resources&gt;\n</code></pre> <p>When the Android Gradle Plugin is building your application, it generates numeric ids for each string <code>name</code>. These will look like <code>R.string.app_name</code>, <code>R.string.cast</code>, etc. (The generated <code>R</code> class will be in the package specified by the <code>android.namespace</code> property in your <code>app/build.gradle.kts</code>) Each of these is known as a \"string resource\".</p> <p>Connecting resource values and formats based on the user settings is known as Localization (aka L10N for similar reasons).</p> <p>To use these strings in your Composable functions:</p> <pre><code>@Composable\nfun Display(\n    @StringRes labelId: Int,\n    value: String,\n) {\n    Row {\n        Text(text = stringResource(id = labelId))\n        Text(text = value)\n    }\n}\n\n...\n\nDisplay(\n    labelId = R.string.name,\n    value = name // probably read from a database or typed by a user\n)\n</code></pre> <p>Note</p> <p>The <code>@StringRes</code> is a nice little annotation that the lint tool uses to ensure that the caller is passing a <code>R.string.xyz</code>. It's not required, but I like adding it as it helps me remember the intent of the parameter.</p> <p>If the string resource has a placeholder, such as</p> <pre><code>&lt;string name=\"filmography\"&gt;Films that feature %1$s&lt;/string&gt;\n</code></pre> <p>You can pass the required value as additional parameters:</p> <pre><code>Text(text = stringResource(id = R.string.filmography, actorName))\n</code></pre> <p>The <code>app/src/main/res/values/strings.xml</code> file acts as the default for all strings. To define alternatives, you add a configuation qualifier suffix to the <code>values</code> directory. For example:</p> <pre><code>app/src/main/res/values-en/strings.xml        - English (no region)\napp/src/main/res/values-en-rGB/strings.xml    - English (United Kingdom)\napp/src/main/res/values-es/strings.xml        - Spanish (no region)\napp/src/main/res/values-es-sp/strings.xml     - Spanish (Mexico)\n</code></pre> <p>There are many other configuration qualifiers you can use, indicating device parameters such as screen size, orientation, Android version, UI mode (car, TV, watch, etc) and many others. See (Providing resources)[https://developer.android.com/guide/topics/resources/providing-resources] for more detail.</p> <p>For more details on I18N/L10N, see Localize your app.</p>"},{"location":"modules/compose-concepts/STEP_040_FULL.html","title":"State","text":"<p>State is probably the trickiest thing to understand in Compose, but it doesn't have to be... Once you understand a little of what's going on behind the scenes, you can feel more confident in your UI design using Compose.</p> <p>What is \"state\" in this context? It's the collection of data used by your application for rendering a UI.</p> <p>Compose uses a <code>Snapshot</code> system to track used state and changes to that state. The basic idea:</p> <ul> <li>Any state passed to or read within a composable function is tracked in a <code>Snapshot</code></li> <li>If Compose knows how to observe the read state, it adds an observer to watch for changes.</li> <li>If the state changes, Compose triggers a recomposition.</li> <li>The affected composable functions are called again, passing the new state values.</li> </ul> <p>There are two \"tricky parts\" here\"</p> <ul> <li>What kind of state can Compose observe?</li> <li>What happens if the observed state contains mutable data?</li> </ul>"},{"location":"modules/compose-concepts/STEP_040_FULL.html#literal-data","title":"Literal data","text":"<p>Let's start with a simple example with fixed data:</p> <pre><code>@Composable\nfun Display(\n    text: String,\n) {\n    Text(\n        text = text,\n        // ... other parameters ...\n    )\n}\n\n...\n\nval name = \"Scott\"\n\nDisplay(name)\n</code></pre> <p>The display should never recompose, as the data cannot change.</p>"},{"location":"modules/compose-concepts/STEP_040_FULL.html#basic-var-properties","title":"Basic var properties","text":"<p>Suppose instead we have</p> <pre><code>var name = \"Scott\"\n\n@Composable\nfun TheCaller() {\n    ClickAndChange(name) { name = \"Mike\" }\n}\n\n@Composable\nfun ClickAndChange(\n    text: String,\n    onClick: () -&gt; Unit,\n) {\n    Text(\n        text = text,\n        modifier = Modifier.clickable { onClick() }\n    )\n}\n</code></pre> <p>This example wants to change the displayed name when it's clicked. But it doesn't work. Why?</p> <p>Compose needs to be able to observe state in order to know when to recompose. The <code>var</code> that we've defined doesn't have any sort of observable quality, so Compose has no idea that it has changed.</p>"},{"location":"modules/compose-concepts/STEP_040_FULL.html#mutablestate-a-compose-observable-bucket","title":"MutableState - a Compose-observable \"bucket\"","text":"<p>Let's tweak the above example:</p> <pre><code>var name = mutableStateOf(\"Scott\") // CHANGED!\n\n@Composable\nfun TheCaller() {\n    ClickAndChange(name.value) { name.value = \"Mike\" }\n}\n\n@Composable\nfun ClickAndChange(\n    text: String,\n    onClick: () -&gt; Unit,\n) {\n    Text(\n        text = text,\n        modifier = Modifier.clickable { onClick() }\n    )\n}\n</code></pre> <p>This works! <code>mutableStateOf</code> creates a <code>MutableState</code> object that can hold our name, and be observed by Compose. I like to call this an \"observable bucket\" - you can place things in the bucket and when the value is different, observers can be notified. Compose uses <code>State</code> objects like this to hold onto and observe data.</p> <p>To understand why this works, we need to dig a bit into the way this is implemented. The following is a simplified implementation of <code>MutableState</code>:</p> <pre><code>class MutableState&lt;T&gt;(\n    initialValue: T\n) {\n    var value: T = initialValue\n        get() {\n            // track this mutable state as being read\n            //   from the current Composable context\n            return field\n        }\n        set(value) {\n            field = value\n            // trigger recomposition on all Composable\n            //   contexts that have read this mutable state \n        }\n}\n</code></pre> <p>You can override the default <code>get</code>/<code>set</code> behavior of Kotlin properties, and here the Compose team uses it to create the \"magic\" of recomposition triggering.</p> <p>The <code>get()</code> is called whenever the <code>value</code> is read. In our example, this happens to get the parameter value: </p> <pre><code>@Composable\nfun TheCaller() {\n    ClickAndChange(name.value) { name.value = \"Mike\" }\n}\n</code></pre> <p>The read is actually done in the context of <code>TheCaller</code> - it's easiest to see this if we separate the <code>name.value</code> call:</p> <pre><code>@Composable\nfun TheCaller() {\n    val nameToPass = name.value\n    ClickAndChange(nameToPass) { name.value = \"Mike\" }\n}\n</code></pre> <p>The Compose compiler plugin passes a <code>Composer</code> as an extra parameter to the function, and sets up the Compose context. The resulting code looks a little like:</p> <pre><code>@Composable\nfun TheCaller(composer: Composer) {\n    composer.start(123) // a unique \"group number\" for the context\n    val nameToPass = name.value\n    ClickAndChange(nameToPass) { name.value = \"Mike\" }\n    composer.end()\n}\n</code></pre> <p>That <code>start(123)</code> call sets up the context for use inside the UI tree and <code>Snapshot</code> - when the <code>get()</code> is called, the context is known so we can record which state is read in which context.</p> <p>When the <code>set()</code> is called (in this case, the <code>name.value = \"Mike\"</code> in <code>ClickAndChange(name.value) { name.value = \"Mike\" }</code>), the <code>set()</code> informs the snapshot manager that the <code>MutableState</code> has changed, which can then trigger recomposition for all contexts that had previously read the <code>MutableState</code>.</p> <p>Kinda like magic, but even cooler when you see what's going on behind the scenes...</p> <p>Let's make it even magic-er...</p>"},{"location":"modules/compose-concepts/STEP_040_FULL.html#simplifying-access-with-kotlin-property-delegates","title":"Simplifying access with Kotlin property delegates","text":"<p>One of my favorite Kotlin features is Delegated Properties.</p> <p>Sometimes you find yourself overriding <code>get()</code> and <code>set()</code> the same way, over and over. For example, suppose you wanted to log access and changes to certain properties. You might find yourself writing</p> <pre><code>var name: String = \"\"\n    get() {\n        // log the access\n        return field\n    }\n    set(value) {\n        field = value\n        // log the change\n    }\n</code></pre> <p>in multiple places. It gets worse as the functionality you want inside <code>get()</code> and <code>set()</code> grows.</p> <p>Property delegation means calling the <code>get()</code> and <code>set()</code> functions of an object from your property's <code>get()</code> and <code>set()</code>. We will no longer use a backing field on the property; we'll manage the value (if necessary) inside the delegate object.</p> <p>For example, if we wanted to delegate the above, we might write:</p> <pre><code>class Loggable&lt;T&gt;(initialValue: T) {\n    private var value: T = initialValue\n\n    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): T {\n        // log the access\n        return value\n    }\n    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: T) {\n        this.value = value\n        // log the change\n    }\n}\n</code></pre> <p>An instance of this class manages a value of any type and logs when that value is accessed or changed. We use this via the <code>by</code> keyword in Kotlin:</p> <pre><code>var name by Loggable(\"\")\n</code></pre> <p>Behind this scenes the <code>by</code> does something like:</p> <pre><code>private val nameLogger = Loggable(\"\")\nvar name: String\n    get() = nameLogger.value\n    set(value) {\n        nameLogger.value = value\n    }\n</code></pre> <p>Because neither the <code>get()</code> nor <code>set()</code> for the <code>name</code> property reference <code>field</code>, there is no backing field for <code>name</code>. Instead, we're storing the value inside the <code>Loggable</code> instance.</p> <p>As it turns out, we can use <code>MutableState</code> as a property delegate with <code>by</code>:</p> <pre><code>var name by mutableStateOf(\"Scott\")\n\n@Composable\nfun TheCaller() {\n    ClickAndChange(name) { name = \"Mike\" }\n}\n</code></pre> <p>This simplifies the use of <code>name</code>. We no longer need to use <code>name.value</code>; we can now just use <code>name</code> with the same effect!</p>"},{"location":"modules/compose-concepts/STEP_040_FULL.html#dont-put-mutable-types-in-that-bucket","title":"Don't put mutable types in that bucket!","text":"<p>One of the most common state errors is placing mutable types inside a <code>MutableState</code>. Let's start with a simple <code>Person</code> type:</p> <pre><code>data class Person(\n    val name: String,\n)\n</code></pre> <p>and then use it in a mutable list in our UI:</p> <pre><code>private val _people = mutableListOf(Person(\"Scott\"))\nvar people by mutableStateOf(_people)\n\n@Composable\nfun PeopleListScreen(\n    people: List&lt;Person&gt;,\n    onAddPerson: (Person) -&gt; Unit,\n) {\n    // Display list of people and an \"add\" button\n    // Call onAddPerson(newPerson) when user adds a person\n}\n\n@Composable\nfun TheCaller() {\n    PeopleListScreen(people) { newPerson -&gt;\n        _people.add(newPerson)\n        people = _people\n    }\n}\n</code></pre> <p>(Some readers may realize the problem here, but this is quite common...)</p> <p>What happens here? When <code>people</code> is read, a Compose <code>Snapshot</code> keeps track of that read value. When that same list is written to <code>people</code>, the Snapshot system compares the new and old values and says \"it's the same object; no change\", and doesn't trigger recomposition. </p> <p>If instead we use an immutable list, we're passing a different list instance each time:</p> <pre><code>var people by mutableStateOf(listOf(Person(\"Scott\")))\n\n@Composable\nfun PeopleListScreen(\n    people: List&lt;Person&gt;,\n    onAddPerson: (Person) -&gt; Unit,\n) {\n    // Display list of people and an \"add\" button\n    // Call onAddPerson(newPerson) when user adds a person\n}\n\n@Composable\nfun TheCaller() {\n    PeopleListScreen(people) { newPerson -&gt;\n        people = people + newPerson\n    }\n}\n</code></pre> <p>The <code>listOf()</code> function creates and returns a List, and we set that list as the initial value in the <code>people</code> bucket. When the new person is added, we call <code>people = people + newPerson</code> which gets the existing list from the bucket, creates a new list with the <code>newPerson</code> added at the end, and puts the new list in the bucket.</p> <p>Now Compose will compare two different lists - one with <code>newPerson</code> and one without, and trigger recomposition.</p>"},{"location":"modules/compose-concepts/STEP_050_FULL.html","title":"Compose Optimizations","text":"<p>Compose wants to be as efficient as possible, so during recomposition, it looks at parameter values being passed into nested composable functions and see it can skip the nested part. Take a look at</p> <pre><code>data class Person(\n    val name: String,\n    val age: Int,\n)\n\n@Composable\nfun AgeStuff(age: Int) { ... }\n\n@Composable\nfun PersonStuff(person: Person) {\n    ...\n    AgeStuff(person.age)\n}\n\n...\n\nvar `person` by mutableStateOf(Person(\"Scott\", 22))\nPersonStuff(person)\n</code></pre> <p>This will compose <code>PersonStuff</code> which in turn calls and composes <code>AgeStuff</code>.</p> <p>At some point, suppose that we set <code>person = Person(\"Mike\", 22)</code>. Note that the <code>age</code> hasn't changed.</p> <p>Because <code>person</code> is different, we'll recompose <code>PersonStuff</code>, but when Compose looks at the parameter passed to <code>AgeStuff</code> it realizes the value hasn't changed, and it can skip recomposing it!</p> <p>But how does Compose actually know this is safe to do?</p> <p>Immutable state is state that cannot change. Compose can look at the value of the state and know that if it's looking at the same value, it could not have changed, no matter how deep the data. Basic Kotlin types such as <code>Int</code>, <code>Char</code> and <code>String</code> are immutable, as are containing types that only contain immutable values (and provide no way to mutate them).</p> <p>Stable state may change, but it's controlled in a way that Compose can observe. We've seen <code>MutableState</code>, which interacts with the snapshot system to inform Compose that values have changed.</p> <p>When the Compose compiler plugin analyzes your code, it marks each function that only takes stable or immutable data as \"skippable\". In the previous example, <code>AgeStuff</code> was skippable because it took an immutable value, <code>age: Int</code>, as its only parameter. When running, it knows it can skip recomposition of <code>AgeStuff</code> if the new and old values are the same.</p> <p>You really only have to worry about this when optimizing your composable functions. For more details on optmization, see Stability in Compose and Jetpack Compose Stability Explained. Be careful not to prematurely optimize, but this is good info to help you understand what's happening behind the scenes.</p>"},{"location":"modules/compose-concepts/STEP_060_FULL.html","title":"Where do you store state?","text":"<p>There are a few things you need to consider when deciding where to define your state:</p> <ul> <li>Where does the data come from?</li> <li>Does it need to persist across runs of the application?</li> <li>Does it need to persist if the device configuration changes (such as the user changing its orientation)?</li> <li>Is the data only used inside a composable function (perhaps it's a scrollbar position that's not needed outside)?</li> </ul>"},{"location":"modules/compose-concepts/STEP_060_FULL.html#state-defined-outside-of-composable-functions","title":"State defined outside of composable functions","text":"<p>Let's start by looking at a very simple <code>Activity</code> that displays a person's name. An <code>Activity</code> manages the user interface for your application. Whatever you call in <code>setContent</code> will declare your Compose UI. <code>setContent</code> creates the root Compose context; composable functions can only be called from it or from other composable functions.</p> <pre><code>class MainActivity : ComponentActivity() {\n    var person by mutableStateOf(Person(\"Scott\"))\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Text(person.name)\n        }\n    }\n}\n</code></pre> <p>Here we define <code>person</code> inside the <code>Activity</code> class, but outside of <code>setContent</code>; it's not inside a composable function.</p> <p>This works until the device configuration changes. A \"configuration change\" occurs when, among many other things, the user changes settings (such as language) on the device, folds/unfolds the screen of a foldable device, connects a device to Android Auto, or simply rotates the device from portrait to landscape.</p> <p>The most common configuration change is device rotation (when \"auto rotate\" is set), so we'll use that as an example.</p> <p>When an <code>Activity</code> is created, it uses the device configuration to resolve any resources such as strings and images (and if you're using the old \"views\" based UIs, layouts, menus, themes and so on). To make this easy on the developer, by default, Android will destroy and recreate the <code>Activity</code> instance so the developer doesn't need to worry about potentially stale resources.</p> <p>The problem is, when the <code>Activity</code> is destroyed and recreated, any properties it defines are also destroyed and recreated.</p> <p>This includes <code>person</code> in the above example. If <code>person</code> had been changed, and the user rotates the device, poof! <code>person</code> is reset to <code>Person(\"Scott\")</code>.</p> <p>To deal with this, we could persist the person in a database, but if the data doesn't need to be retained across runs of the application, this is overkill.</p>"},{"location":"modules/compose-concepts/STEP_060_FULL.html#viewmodels","title":"ViewModels","text":"<p>This is where <code>ViewModel</code>s come in. A <code>ViewModel</code>, in Android terms, is a class that prepares/fetches/holds data for an <code>Activity</code> as long as that <code>Activity</code> is being used. This includes across configuration changes, so it's a great place to store state while the application is running.</p> <p>We can create a view model like</p> <pre><code>class MyViewModel: ViewModel() {\n    var person by mutableStateOf(Person(\"Scott\"))\n}\n</code></pre> <p>Note</p> <p>When adding <code>by mutableStateOf(...)</code> to a file for the first time, you'll see some error underlines. If you float over the error, you see a message indicating that <code>MutableState</code> has no method <code>getValue(...)</code> and it can't be used as a property delegate. The basic <code>MutableState</code> type itself isn't directly usable as a property delegate. We can import</p> <pre><code>import androidx.compose.runtime.getValue\nimport androidx.compose.runtime.setValue\n</code></pre> <p>which are extension functions that adapt <code>MutableState</code> for use as a property delegate.</p> <p>You can import these by hitting alt-enter when your cursor is on the red squiggly underline, or clicking the lightbulb to the left of the line.</p> <p>Back in our <code>Activity</code>, we can use the </p> <pre><code>class MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MyViewModel&gt;()\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            PersonScreen(viewModel.person)\n        }\n    }\n}\n</code></pre> <p>The property delegate created by <code>viewModels&lt;MyViewModel&gt;()</code> will create a new instance of <code>MyViewModel</code> when it doesn't yet exist for use with <code>MainActivity</code>, and reuse an existing <code>MyViewModel</code> if it had already been created for <code>MainActivity</code>. Note that if you use <code>viewModels&lt;MyViewModel&gt;</code> in an different <code>Activity</code> class you'll get a different instance. That shouldn't be an issue, as you should usually only be creating a single <code>Activity</code> for your application.</p> <p>Now if we changed <code>person</code> and rotated the screen, the same <code>person</code> value will be available in the new instance of <code>MainActivity</code>.</p> <p>Note</p> <p>While you can create a <code>MutableState</code> in your view model, many don't feel comfortable with bringing a Compose detail into a view model. If you were thinking of sharing your view model across different types of UIs, such as a web UI, command line, or desktop in addition to Compose, you might want to consider using a Kotlin <code>Flow</code> to store the data and collect it inside the UI. We'll use this <code>Flow</code> approach in our examples once we start working with database data. For now, we'll use <code>MutableState</code>.</p> <p>For the record, I'm on the fence here. If you're only using a Compose UI, directly using <code>MutableState</code> inside your view model is simpler all around. You'll likely end up with a mix of <code>Flow</code> and <code>MutableState</code> in your view model, though, as the data frameworks you likely use (like Room) can produce <code>Flow</code>s but not <code>MutableState</code>. The other side of my fence is that desire to keep the view model \"clean\" of UI specifics.</p> <p>However - state is part of Compose runtime, which is separate from Compose UI. Unfortunately at the moment there are some inter-dependencies between the two. I hope that someday the runtime can be used separately from the ui, and then we could use runtime as an independent state manager with cool tree-building support.</p>"},{"location":"modules/compose-concepts/STEP_060_FULL.html#state-inside-composable-functions","title":"State inside composable functions","text":"<p>Sometimes the right place to store data is inside a composable function. For example, you can define state that controls the scroll position of a list of items, and may not need it outside of that composable function. </p> <pre><code>@Composable\nfun LongScreen(...) {\n    Column(\n        modifier = Modifier.verticalScroll(ScrollState(0))\n    ) { ... }\n}\n</code></pre> <p>In this definition, we're defining an instance of <code>ScrollState</code> and passing it into a modifier for <code>Column</code> that controls scrolling.</p> <p>Unfortunately this won't work - every time we recompose <code>LongScreen</code>, we create a new instance of <code>ScrollState</code> at position 0; the page will never appear to scroll.</p> <p>We need to create an instance of the <code>ScrollState</code> and reuse it across recompositions. We do this using <code>remember</code>:</p> <pre><code>@Composable\nfun LongScreen(...) {\n    val scrollState = remember {\n        ScrollState(initial = 0)\n    }\n\n    Column(\n        modifier = Modifier.verticalScroll(scrollState)\n    ) { ... }\n}\n</code></pre> <p><code>remember</code> creates a spot in the subtree being declared by a composable function. Its lambda defines the value to store inside that spot. The lambda is only run on initial composition (but we can specify key data that forces it to reevaluate - more on that later).</p> <p>In this case, we carve out a spot to store a <code>ScrollState</code> inside the tree being declared. The value in that spot will be reused in recomposition, until this subtree no longer exists in the composition. (For example, if you switch to show a different screen in your application).</p> <p>This works great until a configuration change occurs. Because the <code>Activity</code> is destroyed and recreated, so is the UI. The existing tree is disposed and a new tree is created. This is one of the reasons it's so important that composable functions are idempotent - a tree representing the same data can be recreated.</p> <p>If we want the data to survive a configuration change, we can use <code>rememberSaveable</code>:</p> <pre><code>val scrollstate = rememberSaveable(saver = ScrollState.Saver) {\n    ScrollState(initial = 0)\n}\n</code></pre> <p>Note that <code>rememberSaveable</code> requires a <code>saver</code> to be passed in - this describes how the data is saved across configuration changes. In this case, we have</p> <pre><code>val Saver: Saver&lt;ScrollState, *&gt; = Saver(\n    save = { it.value },\n    restore = { ScrollState(it) }\n)\n</code></pre> <p>This <code>saver</code> just returns the value of the <code>ScrollState</code> (its position) to be stored and creates a new <code>ScrollState</code> when being restored.</p> <p>State objects like <code>ScrollState</code> will often provide a shorthand for the <code>remember</code> block. In this case, we can use</p> <pre><code>val scrollState = rememberScrollState()\nColumn(\n    modifier = Modifier.verticalScroll(scrollState)\n) { ... }\n</code></pre> <p>or, if you don't need to look at/modify the scroll state:</p> <pre><code>Column(\n    modifier = Modifier.verticalScroll(rememberScrollState())\n) { ... }\n</code></pre> <p>As a more interesting example, we can look at <code>TextField</code> for letting the user edit a value:</p> <pre><code>@Composable\nfun MyTextField(\n    value: String,                          // AAA\n    onValueChange: (String) -&gt; Unit,        // BBB\n) {\n    var displayedText by remember(value) {  // CCC\n        mutableStateOf(value)               // DDD\n    }\n    TextField(\n        value = displayedText,              // EEE\n        onValueChange = {\n            displayedText = it              // FFF\n            onValueChange(it)               // GGG\n        }\n    )\n}\n</code></pre> <p>The basic operation of <code>MyTextField</code> is to pass in a <code>value</code> (line AAA) to edit and an event function <code>onValueChange</code> (line BBB) that informs the caller when the value has changed. In an ideal world, as the user types to change the field, the new value is sent to the caller who updates the value, triggering recomposition. The user would see the new value.</p> <p>Unfortunately, we have no idea what the caller will be doing with the value and how long it will take to come back. Meanwhile the user keeps typing and more <code>onValueChange</code> calls are made. This can result in race conditions and some \"interesting\" looking text if the user types quickly.</p> <p>To respond as quickly as possible for the user while they're typing, we create an internal bucket to hold the displayed value:</p> <pre><code>var displayedText by remember(value) {  // CCC\n    mutableStateOf(value)               // DDD\n}\n</code></pre> <p>On line CCC, we carve out a spot in the tree being declared by <code>MyTextField</code> to hold our bucket. This spot is initialized via its lambda, creating the bucket on line DDD. The <code>value</code> in <code>remember(value)</code> is a key. Whenever that value changes, the lambda is re-executed, creating a new bucket with the new value from the outside.</p> <p>On line EEE, we pass the value from the bucket to be displayed in the <code>TextField</code>, and whenever the user makes a change, line FFF updates the bucket value, triggering recomposition of the <code>TextField</code>.</p> <p>Line GGG informs the caller of the change. When we implement this later, we'll debounce the update to limit how often we update the caller.</p> <p>In this example we're using <code>remember</code> and not <code>rememberSaveable</code>. The source of truth for the value is coming from the outside, and will be passed in again after a configuration change, and the <code>remember</code> will recreate the bucket based on that data.</p> <p>Note</p> <p><code>remember</code> is a composable function, but it returns a value! Any composable function that returns a value must not call composable functions that emit nodes to the tree! Any composable function that emits nodes to the tree must not return a value. Compose makes these assumptions and can perform some optimizations that won't work properly if you don't adhere to these conventions.</p>"},{"location":"modules/compose-concepts/STEP_070_FULL.html","title":"Density","text":"<p>Android runs on many devices, each of which can have different screen densities. Some might only have a hundred or so pixels per inch, others thousands. We call this \"screen density\", measured in \"dots per inch\", or DPI.</p> <p>If you specify sizes in pixels, the resulting element or drawing will appear different sizes on different screens. The lower the density, the bigger the pixels. Pixel-based elements will appear larger on lower-density screens, and smaller as the density rises.</p> <p>Android abstracts sizing by using \"density independent pixels\"; DIP or DP for short. Each DP appears the same physical size as a real pixel on a 160 DPI screen. (In other words, a DP is 1/160 inch wide/high).</p> <p>If you specify sizes using DP, the system will perform automatic scaling to preserve the same physical size on all devices. This is particularly useful for margin and tap-regios sizes (such as button), ensuring a consistent look and usable tapping on all devices. Other elements in the UI, such as images in a photo app, can use relative sizing, taking advantage of larger screen sizes for better viewing.</p> <p></p> <p>In this image we see four emulators running at different screen densities, lowest density on the left. Note how <code>200dip</code> (or more commonly, <code>200dp</code>) looks the same size on different density screens, whereas <code>200px</code> varies. The second emulator is sized at 160DPI, the size that defines density-independent pixels.</p> <p>We'll typically use sizes such as <code>48dp</code> for buttons, as that's about the size of a typical thumb.</p>"},{"location":"modules/compose-layouts/index.html","title":"Videos","text":""},{"location":"modules/compose-layouts/index.html#introduction","title":"Introduction","text":"<p>Arranging your Composables can be tricky to get right. Jetpack Compose's included layouts give you the basic support you need for most layouts, but you can gain more control and simpler specification with a custom layout. We'll also see how a \"slotted\" layout allows you to define a common overall structure where you can plug in each section of the layout.</p> <p>In this module, we'll explore different ways to create a simple \"Forms\" interface, starting with basic Rows and Columns, trying out ConstraintLayout, then creating our own layout manager that will adapt to show a form differently based on available space.</p>"},{"location":"modules/compose-layouts/index.html#videos","title":"Videos","text":"<p>Total video time for this module: 2:17:34</p>"},{"location":"modules/compose-layouts/index.html#example-basic-and-custom-layouts-fall-2021-11120","title":"Example: Basic and Custom Layouts (Fall 2021) (1:11:20)","text":""},{"location":"modules/compose-layouts/index.html#lecture-slot-apis-fall-2021-1647","title":"Lecture: Slot APIs (Fall 2021) (16:47)","text":""},{"location":"modules/compose-layouts/index.html#example-slot-apis-fall-2021-1027","title":"Example: Slot APIs (Fall 2021) (10:27)","text":""},{"location":"modules/compose-layouts/index.html#bonus-not-required-more-detail-on-template-method-strategy-and-null-object-patterns-fall-2021-3900","title":"(Bonus, Not Required) More detail on Template Method, Strategy and Null Object Patterns (Fall 2021) (39:00)","text":""},{"location":"modules/compose-layouts/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/compose-layouts. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>compose-layouts</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/compose-layouts\n</code></pre>"},{"location":"modules/compose-lists/index.html","title":"Overview","text":"<p>So far, we've displayed lists of data by iterating through all of the data and emitting Text nodes. Seems to work ok, but what happens when that list gets big?</p> <p>When we emit to the composition tree, the Compose UI will render all of the nodes, even if some are offscreen. If there are relatively few offscreen nodes, it's not a big deal, but as the number of nodes increase, the added processing time can contribute to jank in the UI. We need a better approach to manage offscreen parts of our UI.</p> <p>We'll look at this from the point of view of fixed and dynamic UIs.</p> <ul> <li> <p>A fixed UI is one that presents all of its data all the time. Think about a data-entry form. Perhaps you're editing user shipping information. There are typically a fixed number of fields in the UI. Depending on the device configuration (in this case, the screen size and user-selected font scaling), we might not be able to fit all fields on the screen at once. We can make the screen scroll, but all data is always rendered.</p> </li> <li> <p>A dynamic UI is one that only displays part of the available, typically just what will fit on the screen (or a bit more for smooth animation). This is most apparent when presenting data from a database, such as songs in a playlist. The UI will repeat chunks of controls for each item, and can quickly grow past the screen bounds. The dynamic nature of the UI reduces the amount of rendering needed.</p> </li> </ul>"},{"location":"modules/compose-lists/STEP_020_FULL.html","title":"Fixed UIs","text":"<p>First, let's think about a fixed UI. We're asking the user to enter shipping information, which may or may not all fit on the screen. If the device has a large screen or the user is using a \"small\" font setting, we might get all fields on the screen. But as the screen shrinks or the user chooses \"large\" fonts, it's likely that some parts of the UI won't fit.</p> <p>There are a few things you might do about this:</p> <ul> <li> <p>Mark your UI as scrollable. For example, if you use a <code>Column</code> to hold your fields, you can mark the column as scrollable:</p> <pre><code>Column(\n    modifier = Modifier\n        .padding(paddingValues)\n        .verticalScroll(rememberScrollState())\n) { ... }\n</code></pre> <p>This is a good idea whenever using a <code>Column</code> (or other layout) that may need to be scrolled to see all of its content. Keep in mind that devices come in many different form factors, and users will sometimes choose extra-large font sizes to make reading more comfortable.</p> <p>If, on the other hand, you're declaring a UI that has fixed content that always appears on the screen, and scales with the screen size to force it all to fit, you would skip the scroll modifier. (This might apply when writing a full-screen game, for example.)</p> </li> <li> <p>Break the UI into more screens, each with fewer fields. If you have a long, scrollable, UI with many fields, double-check that the fields are all related. If grouping fields makes sense, you might consider creating more than one screen. You could</p> <ul> <li> <p>Create a \"main\" screen for that part of the UI, with buttons or links that open the grouped detail. For example, a shipping screen might have buttons to open an address-editor screen and present shipping rate choices.</p> </li> <li> <p>Create a series of screens with \"next\"/\"previous\" actions to move between them. For example, a \"purchase\" might be presented as a series of screens:</p> <ul> <li>Shopping cart display</li> <li>Shipping address</li> <li>Shipping rate options</li> <li>Credit card entry</li> <li>Confirmation</li> </ul> </li> </ul> </li> </ul> <p>Choosing the right layout can be tricky. If you have some User-Experience (UX) Designers in your company, talk with them about what might make a good user interface. They may help set up an A-B study to test out alternatives with a user (or if you don't have dedicated UX folks, consider such a study yourself, or bounce ideas off other developers to see what might feel the best.)</p> <p>If it feels like the best interface for your application would be a long scrolling list of fields, use a scrollable <code>Column</code> and test its performance. If the list of fields is really long and is causing performance issues, you may want to consider treating the fields as items in a list, and follow the next section.</p>"},{"location":"modules/compose-lists/STEP_030_FULL.html","title":"Dynamic UIs","text":"<p>The amount of available data is often outside of your control. You might have no idea if your application would typically display a handful of items, or a huge number. </p> <p>Ideally, we would only emit the nodes to the composition tree if they are visible. To do this, we need to track which items are visible and as the user scrolls, and properly update them if the data behind them changes.</p> <p>When we emit nodes to the composition tree, Compose typically keeps track of them by position. During recomposition, if the item in a position is stable and equals the previous item in that position, recomposition for that item can be skipped. If items are inserted or deleted, Compose may need to recompose items around it, and may not be able to determine how to apply animations on those inserts and deletes.</p> <p>If instead, you assign keys that uniquely identify items in part of the composition tree, Compose can determine how a newly-emitted chunk of nodes relates to the previously-emitted nodes, and can animate insertions and deletions and possibly moves.</p> <pre><code>LazyColumn(...) {                                       // AAA\n    items(                                              // BBB\n        items = people,\n        key = { it.id },\n    ) { item -&gt;                                         // CCC\n        Card(                                           // DDD\n            elevation = 4.dp,\n            modifier = ...\n        ) {                                             // EEE\n            // content to display the item\n        }\n    }\n}\n</code></pre> Line Description AAA <code>LazyColumn</code> dynamically emits nodes to the composition tree that will be visible (and others if necessary for scrolling and animation). Its content lambda declares which items are in the list, how to uniquely identify them, and what composition should display each item BBB <code>items</code> declares the list of data to display in the <code>LazyColumn</code> and how to get a unique key for each item. The keys allow <code>LazyColumn</code> to determine when items have been inserted, deleted or moved, optimizing recomposition and allowing animation CCC The current item to be displayed is passed to this lambda. The <code>LazyColumn</code> determines which items will be visible (or partially visible) and use the lambda to render them. DDD <code>Card</code> is a composable that displays a raised, rounded-corner rectangle around its contents. You'll often see them used in displayed lists, but they're not required. You can use any other composable inside this lambda torender the content. EEE The content composable lambda that declares the presentation of each item in the <code>Card</code> <p>The above screen might look like</p> <p></p> <p>Note</p> <p>If you want a horizontal display of items, <code>LazyRow</code> works similar. <code>LazyHorizontalGrid</code> and <code>LazyVerticalGrid</code> arrange more than one item horizontally or vertically in rows/columns. We're only working with <code>LazyColumn</code> in this course.</p>"},{"location":"modules/compose-lists/STEP_040_FULL.html","title":"Selection","text":"<p>Sometimes you'd like to allow the user to select one or more items in the list and perform an action against them.</p> <p>This requires:</p> <ul> <li>A collection (typically a <code>Set</code>) to track which items are considered \"selected\" (often just the item id),</li> <li>A declaration of user interaction that is considered \"selecting an item\", which will add the id of that item to the \"selected\" set.</li> <li>A declaration of user interaction that is considered navigating to that item's details (if applicable)</li> <li>Actions (passed to the <code>topBar</code> in the <code>Scaffold</code>) that should be available when <ul> <li>no items are selected</li> <li>one or more items are selected</li> </ul> </li> <li>Colors to use to indicate an item is selected. We'll use the <code>primary</code> color in the theme, but you could choose a different one, such as <code>primaryVariant</code> or <code>secondary</code> colors.</li> </ul> <p>Let's look an an example UI:</p> <p>First, we've added an icon at the start of the cards:</p> <p></p> <p>How does the user interact with the items?</p> <ul> <li>Tapping the icon or long-pressing anywhere in the row toggles the selection</li> <li>Tapping in the row anywhere except the icon:<ul> <li>if any items are selected, toggle this item</li> <li>if no items are selected, trigger navigation</li> </ul> </li> </ul> <p></p> <p>When any items are selected, we change the <code>topBar</code> in the <code>Scaffold</code> to display</p> <ul> <li>a navigation arrow icon. When pressed, all selections are cleared</li> <li>the number of selected items</li> <li>selection actions - \"delete\" in this case (deletes all selected items when tapped)</li> </ul> <p>This alternative bar is called a \"contextual\" bar, as it depends on the items the user has selected. This presentation is a common convention, but you can set up the contextual bar however you see fit.</p> <p>We also highlight the selected items in the list. Note how the foreground and background colors are swapped</p> <p>We'll see the details of how to implement selection as we continue our Movies UI.</p>"},{"location":"modules/compose-text-fields/index.html","title":"Overview","text":"<p>TextFields allow the user to enter text in your application. They follow the same basic pattern we've seen for other composable functions:</p> <ul> <li>Value to display passed in</li> <li>Event function to inform caller that the user wants to change something</li> </ul> <p>For example:</p> <pre><code>@Composable\nfun SomeComposable() {\n   var name by remember { mutableStateOf(\"\") }\n\n   TextField(\n         value = name,\n         onValueChange = { name = it },\n   )\n}\n</code></pre> <p>The TextField has some internal state to manage the cursor location, selections and the edit the user is making, but the value to be displayed is managed outside of it.</p> <p>Note</p> <p>As we'll see later, this separation of internal and external state can cause some nasty data races. Because of this (and some other awkward parts of the current API), Google is working on significant API changes that should come out in 2024.</p> <p>In this module, we'll talk about some ways to mitigate races. You need to be careful how you use this deceptively-simple API...</p> <p>There are three main types of text fields:</p> <ul> <li><code>BasicTextField</code> - the basic operations without decorations like background or outlines. You normally won't use this one unless you're creating a very custom field.</li> <li><code>TextField</code> - a text field with a background</li> <li><code>OutlinedTextField</code> - a textfield with a border around it</li> </ul> <p>The <code>TextField</code> and <code>OutlinedTextField</code> also allow you to specify a <code>placeholder</code> that appears when no text is present, or a <code>label</code>, which acts like a placeholder until text is entered, and then moves/shrinks to remain visible as a label.</p> <p>For example, here are the three types of text fields, with no entry, then after some text has been entered. All three are displaying the same state:</p> <p> </p> <p>Code for the above looks like:</p> <pre><code>var name by remember { mutableStateOf(\"\") }\nColumn {\n   BasicTextField(\n         value = name,\n         onValueChange = { name = it },\n         modifier = Modifier.padding(8.dp).fillMaxWidth(),\n   )\n   TextField(\n         value = name,\n         onValueChange = { name = it },\n         label = { Text(\"First name\")},\n         modifier = Modifier.padding(8.dp).fillMaxWidth(),\n   )\n   OutlinedTextField(\n         value = name,\n         onValueChange = { name = it },\n         label = { Text(\"First name\")},\n         modifier = Modifier.padding(8.dp).fillMaxWidth(),\n   )\n}\n</code></pre> <p>We won't be covering all of the details of the text fields here, but there's quite a bit of customization, including the number of visible lines (as well as allowing/disallowing new lines), styles, but as a quick example, suppose we wanted to allow the user to enter and search for an email address (a bit contrived here, but roll with me)</p> <pre><code>OutlinedTextField(\n      value = name,\n      leadingIcon = {\n         Icon(\n            imageVector = Icons.Default.Email,\n            contentDescription = \"Email\"\n            )\n         },\n      onValueChange = { name = it },\n      label = { Text(\"Email\") },\n      keyboardOptions = KeyboardOptions(\n         imeAction = ImeAction.Search,\n         keyboardType = KeyboardType.Email\n      ),\n      keyboardActions = KeyboardActions(\n         onSearch = { ... },\n      ),\n      modifier = Modifier\n         .padding(8.dp)\n         .fillMaxWidth(),\n)\n</code></pre> <p></p> <p>A few things to note in the above:</p> <ul> <li>Leading icons can help set off individual fields, if they're reasonably obvious.</li> <li> <p>Keyboard types are hints to the keyboard. Not all keyboards support all types.      In this example, we hint to the keyboard that the field is for email. Many keyboards, such as the one displayed in the picture, will change some of the keys to make it easier for the user to enter the field. In this example, we see a convenient \"@\" key. Other keyboard types, such as Uri and Number may display differently.</p> <p> </p> <p>But again - these are just hints and not all keyboards may support all hints.</p> </li> <li> <p>Keyboard imeAction is a hint to the keyboard about treatment of the \"enter\" key. Keyboards typically use imeAction to determine what to display on the enter key. In this example, we asked for \"search\", so a magnifying glass is displayed. Other typical actions may represent sending a message or moving to the next field on the screen.</p> </li> <li> <p>Keyboard actions allow you to specify what to do when the action is pressed.</p> </li> </ul>"},{"location":"modules/compose-text-fields/STEP_020_FULL.html","title":"State Races","text":"<p>As mentioned earlier, text fields have some internal state that needs to be synced to changes coming in from the outside. This internal state includes a copy of the currently-displayed text, the current cursor position, selection range. These are needed to interact with keyboards to perform suggestions, cut/copy/paste, etc.</p> <p>In many cases, I like each change to be reported to the callers so they can immediately update their state. This allows more complex UIs to display updated states outside the text field. For example, if you have a larger screen and are displaying a list of items on the left and the details of a selected item on the right, editing the name of the item would immediately show in the list as you type.</p> <p>This can be extremely error prone. If you pass the item being edited into the \"edit screen\" portion of the UI, and one of its properties into a TextField, you set yourself up for some serious races.</p> <p>The user starts typing in the field. For the change to be displayed, we need to pass updated state into the TextField. But where does that updated state come from?</p> <p>Suppose we have a setup like the following:</p> <pre><code>@Composable\nfun PersonEditScreen(\n    person: Person?,\n    onPersonChange: (Person) -&gt; Unit,\n) {\n    person?.let {\n        Column {\n            OutlinedTextField(\n                value = person.name,\n                onValueChange = {\n                  onPersonChange(person.copy(name = it))\n                }, \n            )\n            OutlinedTextField(\n                value = person.age.toString(),\n                onValueChange = {\n                  onPersonChange(person.copy(age = it.toInt()))\n                    // ignore that this can fail if the text isn't a number...\n                },\n            )\n        }\n    } ?: Text(text  = \"Loading\")\n}\n\n@Composable\nfun Ui(\n    viewModel: MyViewModel,\n) {\n    val person = viewModel.personFlow.collectAsStateWithLifecycle(initialValue = null)\n    PersonEditScreen(\n        person = person,\n        onPersonChange = { editedPerson -&gt;\n            viewModel.updatePerson(editedPerson)\n        } \n    )\n}\n</code></pre> <p>We're using <code>Person.copy(...)</code> (assuming Person is a data class, which generates the <code>copy</code> function) to create a new <code>Person</code> instance with the same data, updating any data passed as parameters. We pass this new <code>Person</code> to the <code>viewModel</code>'s <code>updatePerson</code> function.</p> <p>Many things can happen in that <code>updatePerson</code> function, but let's assume it's expensive, might be running asynchronously, and take a bit to return. Perhaps the person is updated in the database.</p> <p>While that update is happening, the user keeps typing, furiously. An <code>updatePerson</code> call is sent for each added character.</p> <p>The <code>TextField</code> won't show any updates until we pass in a new <code>value</code>. That won't happen until the database update occurs.</p> <p>Best case, we would see a lag between when the user types, and when the new value is displayed.</p> <p>But most often, things can get much, much worse. Depending on how <code>updatePerson</code> is implemented, we might be launching a new coroutine for each call. The end result can be a bad mix of updates and syncs. Here I'm quickly typing \"Scott Stanchfield\" and then holding down backspace.</p> <p></p> <p>Oof! In other cases, the TextField may see that an update hasn't been made within a given amount of time, and it reports the previous value again.</p> <p>So how can we fix this?</p>"},{"location":"modules/compose-text-fields/STEP_030_FULL.html","title":"Fixing State Races","text":"<p>The main solution is to mirror the state that will be displayed in the field, and ensure that updates to the real data happen in the proper order, or all at once on a user action (such as pressing a \"save\" button or navigating back from the edit page)</p> <ul> <li> <p>Mirror state during async processing</p> <ul> <li>Local state updates the text fields</li> <li>As fields change, inform caller to update the external state</li> <li>External state is updated in database</li> <li>Only works if any data translation locally and externally is the same</li> </ul> </li> <li> <p>Mirrored state with final updates made on user action </p> <ul> <li>Local state updates the text field</li> <li>External state is not changed while user types</li> <li>User pressing \"save\" or navigating back triggers<ul> <li>Inform caller of change</li> <li>External data is updated and saved in database</li> </ul> </li> </ul> </li> </ul> <p>Let's look at some examples</p>"},{"location":"modules/compose-text-fields/STEP_030_FULL.html#saving-data-while-the-user-is-typing","title":"Saving data while the user is typing","text":"<p>I like this approach because all data being edited is kept in sync with all parts of the UI that use the data.</p> <p>For example, suppose we have a list/detail setup; a list of items is on the left side of the screen, and the selected item is displayed on the right side of the screen. Some data will be shared - perhaps the name of an item is displayed in the list, but can be edited in the detail. As the user changes the name, it might be nice to change it in the list.</p> <p>Note</p> <p>This approach can have some interesting consequences when the list is sorted by the property being edited - you may need to perform some extra work to ensure the item being edited stays visible in the list.</p> <p>One way to perform this type of processing:</p> <ol> <li>Pass in an id for the item to the edit screen</li> <li>Fetch the actual object in a LaunchedEffect, keyed by the id. It won't be re-fetched unless the id changes. This allows us to get an initial copy of the object that won't change while the user makes changes.</li> <li>Either</li> <li>Use this object and its properties as the text fields' state, or</li> <li>Extract each property into a separate <code>State</code> as the text field state (initialized to the fetched-object properties)</li> <li>As the user types</li> <li>Update the local state, triggering recomposition of the text fields, AND</li> <li>Tell the caller that the value has changed</li> <li>The caller can update the database, and it doesn't trigger recomposition, as its id hasn't changed. I recommend that you debounce this update so if the user types quickly, the database will only update when they pause typing </li> </ol> <p>Code for this might look like</p> <pre><code>class PersonViewModel(\n    private val personRepository: PersonRepository\n): ViewModel() {\n    val personFlow = personRepository.personFlow\n    suspend fun fetchPerson(id: String): Person? =\n        personRepository.getPersonById(id)\n\n    // manual debouncing \n    //   (this implementation assumes all updatePerson calls come from the same thread)\n    //   launch a coroutine and hold a pointer to it\n    //     delay a certain amount of time\n    //     perform the update\n    //     clear the pointer (not really necessary)\n    //   next time we try to run, before launching the coroutine\n    //     if we have a pointer to the last coroutine run, cancel it\n    //        if it's already finished, cancel doesn't do anything\n    //        it it's still running, we abandon the work and start again\n    // This has the effect of only running the work if there's a 500ms gap between calls\n    // This is great for running work on each key press or fast mouse clicks\n    private var updateJob: Job? = null\n    fun updatePerson(person: Person) {\n        updateJob?.cancel()\n        updateJob = viewModelScope.launch(Dispatchers.IO) {\n            delay(500)\n            personRepository.update(person)\n            updateJob = null\n        }\n    }\n}\n\n@Composable\nfun PersonEditScreen(\n    id: String?,\n    onPersonChange: (Person) -&gt; Unit,\n    fetchPerson: suspend (String) -&gt; Person?,\n) {\n    var person by remember { mutableStateOf&lt;Person?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        person = id?.let { fetchPerson(it) }\n    }\n\n    person?.let { fetchedPerson -&gt;\n        ...\n        OutlinedTextField(\n        value = fetchedPerson.name,\n        label = { Text(\"Name\")},\n        onValueChange = {\n            val newPerson = fetchedPerson.copy(name = it)\n            person = newPerson\n            onPersonChange(newPerson)\n        },\n        )\n    }\n}\n</code></pre> <p>This looks like</p> <p></p> <p>In this video, the \"Person name in DB\" field is separate from the person edit UI. It collects a <code>Flow</code> from the database, showing the name of the person we stored.</p> <p>I type my last name fast enough that there is less than 500ms between each keystroke. Once I pause, the database is updated and my last name appears. I then delete several characters, pausing once in a while, until the field is blank. The database only updates during the pauses. I then type \"Hello\", pause, then \" there\", pause. Again, the text only updates in the database when I pause.</p> <p>A safer way to debounce is to use the built-in (experimental) <code>debounce()</code> function in the view model. Here we use a <code>MutableStateFlow</code> as a \"person update queue\", debouncing the flow itself. Note that <code>debounce()</code> creates a new flow chained to the original flow.</p> <p>We collect the flow in a <code>viewModelScope</code>-launched coroutine, which is canceled when the view model is dismissed.</p> <p>The update call just becomes placing the person to update in the queue. The <code>debounce()</code> flow waits a bit before emitting the item, and will skip it if a new item comes in before the timeout.</p> <pre><code>@OptIn(FlowPreview::class)\nclass PersonViewModel(\n): ViewModel() {\n    private val personRepository: PersonRepository = PersonRepository()\n    val personFlow = personRepository.personFlow\n    suspend fun fetchPerson(id: String): Person? =\n        personRepository.getPersonById(id)\n\n    // using a debounced flow as a person-update queue\n    private val personUpdateFlow = MutableStateFlow&lt;Person?&gt;(null)\n    init {\n        viewModelScope.launch(Dispatchers.IO) {\n            personUpdateFlow.debounce(500).collect { person -&gt;\n                person?.let { personRepository.update(it) }\n            }\n        }\n    }\n    fun updatePerson(person: Person) {\n        personUpdateFlow.value = person\n    }\n}\n</code></pre> <p>The behavior is the same as the previous example.</p>"},{"location":"modules/compose-text-fields/STEP_030_FULL.html#updates-made-on-user-save-or-back","title":"Updates made on user \"save\" or \"back\"","text":"<ul> <li>each field has its own state</li> <li>initialize to properties of passed-in object</li> <li>user presses explicit \"save\" button or navigates back<ul> <li>notify caller of all changes and exit</li> </ul> </li> </ul> <pre><code>@Composable\nfun PersonEditScreen(\n    id: String?,\n    onPersonChange: (Person) -&gt; Unit,\n    fetchPerson: suspend (String) -&gt; Person?,\n    onExit: () -&gt; Unit,\n) {\n    var person by remember { mutableStateOf&lt;Person?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        person = id?.let { fetchPerson(it) }\n    }\n\n    person?.let { fetchedPerson -&gt;\n        ...\n        OutlinedTextField(\n            value = fetchedPerson.name,\n            label = { Text(\"Name\")},\n            onValueChange = {\n                person = fetchedPerson.copy(name = it)\n            },\n        )\n        ...\n        Button(\n            onClick = {\n               person?.let { onPersonChange(it) }\n               onExit()\n            }\n        ) { Text(\"Save\") }\n    } ?: Text(text  = \"Loading\")\n}\n</code></pre> <p>Note in this version of the <code>PersonEditScreen</code> we don't call <code>onPersonChange</code> when values of the <code>TextField</code> change; we only update the local <code>Person</code>. When the save button is pressed, we make the call to <code>onPersonChanged</code> and call <code>onExit()</code> to inform the caller we can navigate out.</p> <p>This looks like the following (without the <code>onExit()</code> call so we can see multiple updates). Note that the Database isn't updated unless the save button is pressed. I've disabled debouncing in this example, though you may want to use it as the user could click many times on the button very quickly causing lots of saves (all with the same data).</p> <p></p> <p>We can do similar processing using a <code>BackHandler</code> (to always save when the user navigates back) instead of the save button:</p> <pre><code>@Composable\nfun PersonEditScreen(\n    id: String?,\n    onPersonChange: (Person) -&gt; Unit,\n    fetchPerson: suspend (String) -&gt; Person?,\n    onExit: () -&gt; Unit,\n) {\n    var person by remember { mutableStateOf&lt;Person?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        person = id?.let { fetchPerson(it) }\n    }\n\n    BackHandler {\n        person?.let { onPersonChange(it) }\n        onExit()\n    }\n\n    person?.let { fetchedPerson -&gt;\n        ...\n        OutlinedTextField(\n            value = fetchedPerson.name,\n            label = { Text(\"Name\")},\n            onValueChange = {\n                person = fetchedPerson.copy(name = it)\n            },\n        )\n    } ?: Text(text  = \"Loading\")\n}\n</code></pre>"},{"location":"modules/compose-text-fields/STEP_040_FULL.html","title":"Heads up!","text":"<p>Heads up! Google is currently updating the TextField APIs. It's still early work but may be available in 2024. One of the main goals is to make the state management simpler (which would be incredibly welcome...)</p>"},{"location":"modules/google-maps/index.html","title":"Overview","text":"<p>Some applications become much more useful by displaying a Map. You might be displaying a location or area, or letting the user explore. The map could be central to your application's functionality, or a nice, optional extra. The map may or may not display the user's current location.</p> <p>Note</p> <p>User privacy is a huge concern for your application. PII (Personally Identifiable Information) includes any information that can identify a user, such as name, address, email, phone number (among many others). Photos, contacts and files can also be sources of identifying information. Whenever this type of data is accessed, you must ask the user if it's ok for the application to use it. Providers of such information are usually protected by Android Permissions that are marked as \"dangerous\" to indicate that they have the potential to expose PII or other private information. Device features such as location, phone and biometrics could also be used to expose PII or other personal information.</p> <p>Dangerous permissions must be requested of the user at run time. We'll see this in action when we request the user's current location.</p> <p>Note that when you publish your application to the Google Play Store, you're required to provide a Privacy Policy stating what data you use and how you use it. Regardless of where you publish your application, many states and countries have laws regarding how PII can be used and what types of information must appear in a Privacy Policy. There are many web sites that can assist in generation of a Privacy Policy (I have not researched any in detail and cannot recommend specific generators; I recommend you do some research before choosing one to ensure it generates a propery policy, and/or consult with a lawyer who knows privacy law.)</p> <p>The map itself doesn't use any PII, but using Location Services to gather the user's current location does.</p> <p>Setting up Google Maps requires:</p> <ol> <li>Add Google Maps Dependencies</li> <li>Set up a project in the Google Developer's Console</li> <li>Enable the Maps API in that project (to access map tiles and other mapping information such as POIs and address search)</li> <li>Create an API key to use in your application</li> <li>Add the key to your project </li> </ol> <p>Let's start by creating an empty project.</p>"},{"location":"modules/google-maps/STEP_020_FULL.html","title":"Find Your Fingerprint","text":"<p>Before we can set up the key, we need to get some information from your application.</p> <p>Android applications are digitally signed to uniquely identify their owners, using a self-signed certificate. When you install Android Studio, it creates a debug certificate for you, which you will only use for debugging your application before deployment. Every time we've run an application, it's been signed using the debug key.</p> <p>We want to restrict the API key we're creating to only your application id and signing key combination. For now, we'll use the debug key, but if you plan to sign with a key for releasing the application, you'll need to add the application id and release key combination.</p> <p>We need to pieces of information</p> <ul> <li> <p>application id - this is the unique identifier for your application. (You should typically start    this with a reversed domain-name. For example, I own the \"androidbyexample.com\" domain, so I use   \"com.androidbyexample\" as the prefix of all my application ids for the course samples.)</p> </li> <li> <p>SHA-1 fingerprint of your debug certification</p> </li> </ul> <p>For the application id, take a look at your <code>/app/build.gradle</code> file. You'll find the <code>applicationId</code> inside the <code>defaultConfig</code> block.</p> <pre><code>android {\n    ...\n    defaultConfig {\n        applicationId = \"com.androidbyexample.googlemap\"\n    }\n}\n</code></pre> <p>Copy the application id somewhere. (I usually open a plain text file in Visual Studio Code to as a scratch pad for things like this.)</p> <p>The SHA-1 fingerprint is easy to obtain. Go to the terminal at the bottom of Android Studio and type</p> Windows CMDWindows Poweshell/Linux/Mac <pre><code>gradlew signingReport\n</code></pre> <pre><code>./gradlew signingReport\n</code></pre> <p>Or if you open the Gradle view on the right edge of Android Studio, you can click the little elephant icon and type \"signingReport\" after \"gradle\" and hit enter.</p> <p>The report will show a block like</p> <pre><code>Variant: debug\nConfig: debug\nStore: C:\\Users\\scott\\.android\\debug.keystore\nAlias: AndroidDebugKey\nMD5: xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\nSHA1: xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\nSHA-256: xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx\nValid until: Saturday, May 25, 2052\n----------\n</code></pre> <p>Copy the fingerprint after <code>SHA-1</code> and save with your application id.</p>"},{"location":"modules/google-maps/STEP_030_FULL.html","title":"Google Console Project","text":"<p>Maps need to get their tile data from somewhere - in the cloud. </p> <p>Sign into Google Developer Console. If you don't have a Google account, you'll need to create one.</p> <p>Note</p> <p>Map tiles are only free up to a point (at this point, $200 worth of tiles per month)... It's important that you restrict the key you'll create to your application, or someone else could use it with their application and charge you for the map tiles!!! If you're looking to create and sell a mapping application that will likely have lots of tile loads, see Pricing and set up billing for your project.</p> <p>Once you're into the console, create a new project to host </p> <p></p> <p>And give it a name</p> <p></p> <p>Enable the Maps API in your project (to access map tiles and other mapping information such as POIs and address search)</p> <p></p> <p>Choose \"Maps SDK for Android\" (if you don't see it, search for it)</p> <p></p> <p>And enable it</p> <p></p> <p>Create an API key to use in your application by going to \"Credentials\"</p> <p></p> <p>Press \"Create Credentials\"</p> <p></p> <p>Choose \"API Key\"</p> <p></p> <p>And poof! API key created! (It even says so!)</p> <p>Copy the key and save it somewhere; we'll need it in the Android application later.</p> <p>Click \"Edit API Key\" so we can restrict it to only be used by your application.</p> <p></p> <p>Under Application Restrictions, choose \"Android Apps\". This will show the \"Add an Item\" button. Press it.</p> <p></p> <p>Enter your application ID and SHA-1 fingerprint that we found in the last step, then press \"Done\"</p> <p></p> <p>Don't forget to save everything! Note that it may take a few minutes for the key to be available to your application. This is usually apparent if the map doesn't show on the screen.</p> <p></p>"},{"location":"modules/google-maps/STEP_040_REPO.html","title":"Set up a map","text":"<p>Let's take our new key and add it to the project.</p> <p>First, add the name of the key to a <code>secrets.properties</code> file in the root directory of your project. It should contain the following (replace <code>YOUR_KEY_NAME_GOES_HERE</code> with your API key)</p> <pre><code># DO NOT CHECK THIS FILE IN!\nMAPS_API_KEY=YOUR_KEY_NAME_GOES_HERE\n</code></pre> <p>This file should NEVER be checked into git, as the key name is a secret. (Because this file isn't checked in, and I'm using git to generate the code display on the right, I'll show its contents below). Be sure to add <code>secrets.properties</code> to the top-level <code>.gitignore</code> file:</p> show in full file  .gitignore <pre>// ...\n.cxx\nlocal.properties\nsecrets.properties</pre> <p>To access the key, we'll use the \"secrets\" plugin, which reads <code>secrets.properties</code> and makes the properties available in other files.</p> <p>To add the secrets plugin to your build, declare the version of the secrets plugin and the plugin artifact in your version catalog</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nsecrets = \"2.0.1\"\n\nmaps-compose = \"6.2.1\"\n// ...\n[libraries]\n// ...\n[plugins]\n// ...\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n//\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }</pre> <p>Declare that you want to use the plugin in your root build.gradle.kts. We use <code>apply false</code> so it doesn't do anything other than set up the plugin on the classpath for all modules that will use it.</p> show in full file  build.gradle.kts <pre>// ...\nplugins {\n    // ...\n    alias(libs.plugins.kotlin.android) apply false\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.secrets) apply false\n}</pre> <p>Apply the plugin in your <code>app/build.gradle.kts</code> and configure it to use our <code>secrets.properties</code> file</p> show in full file  app/build.gradle.kts <pre>plugins {\n    // ...\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n}\n\n// ...\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}</pre> <p>Then we can drop the key in the Manifest for Google Maps to find at runtime.</p> show in full file  app/src/main/AndroidManifest.xml <pre>// ...\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n    // ...\n    &lt;application\n        // ...\n        tools:targetApi=\"31\"&gt;\n\n        &lt;meta-data\n            android:name=\"com.google.android.geo.API_KEY\"\n            android:value=\"${MAPS_API_KEY}\" /&gt;\n\n        &lt;activity\n            // ...\n    &lt;/application&gt;\n// ...\n&lt;/manifest&gt;</pre> <p>So far we don't have access to the Google Maps @Composable function, so we add versions and libraries to the version catalog:</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nsecrets = \"2.0.1\"\n\nmaps-compose = \"6.2.1\"\n\n[libraries]\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\n\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\n// ...\n[plugins]\n// ...</pre> <p>Then add the dependencies to the <code>app</code>'s build script. </p> show in full file  app/build.gradle.kts <pre>// ...\ndependencies {\n//\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    // ...\n}\n// ...</pre> <p>Finally, add a Map to the UI</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  Greeting(\n//                      name = \"Android\",\n//                      modifier = Modifier.padding(innerPadding)\n//                  )\n                    GoogleMap(\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    ) {\n                        // no content yet\n                    }\n                }\n            }\n        }\n    }\n}\n// ...</pre> <p>When we run the app, we'll see</p> <p></p> All code changes CHANGED: .gitignore <pre>*.iml\n.gradle\n/local.properties\n/.idea/caches\n/.idea/libraries\n/.idea/modules.xml\n/.idea/workspace.xml\n/.idea/navEditor.xml\n/.idea/assetWizardSettings.xml\n.DS_Store\n/build\n/captures\n.externalNativeBuild\n.cxx\nlocal.properties\nsecrets.properties\n</pre> CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.google.google.maps\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.google.google.maps\"\n        minSdk = 24\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n//\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}\n</pre> CHANGED: app/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n\n    &lt;application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.GoogleMaps\"\n        tools:targetApi=\"31\"&gt;\n\n        &lt;meta-data\n            android:name=\"com.google.android.geo.API_KEY\"\n            android:value=\"${MAPS_API_KEY}\" /&gt;\n\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/Theme.GoogleMaps\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.maps.android.compose.GoogleMap\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  Greeting(\n//                      name = \"Android\",\n//                      modifier = Modifier.padding(innerPadding)\n//                  )\n                    GoogleMap(\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    ) {\n                        // no content yet\n                    }\n                }\n            }\n        }\n    }\n}\n//\n//@Composable\n//fun Greeting(name: String, modifier: Modifier = Modifier) {\n//  Text(\n//      text = \"Hello $name!\",\n//      modifier = modifier\n//  )\n//}\n//\n//@Preview(showBackground = true)\n//@Composable\n//fun GreetingPreview() {\n//  GoogleMapsTheme {\n//      Greeting(\"Android\")\n//  }\n//}\n</pre> CHANGED: build.gradle.kts <pre>// Top-level build file where you can add configuration options common to all sub-projects/modules.\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.android) apply false\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.secrets) apply false\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nsecrets = \"2.0.1\"\n\nmaps-compose = \"6.2.1\"\n\n[libraries]\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\n\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n//\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }\n</pre>"},{"location":"modules/google-maps/STEP_050_REPO.html","title":"Add a Marker","text":"<p>A map by itself is useful for exploring, but what if you want to tell the user where something is?</p> <p>That's where markers come in, and where the <code>GoogleMap</code> content parameter becomes useful.</p> <p>Our <code>GoogleMap</code> call is going to get more complex over the next several steps. By  Creating a new @Composable to hold the map, we can set up parameters</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\nimport com.google.maps.android.compose.rememberMarkerState\n\n@Composable\nfun GoogleMapDisplay(\n    place: LatLng,\n    placeDescription: String,\n    modifier: Modifier,\n) {\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    GoogleMap(\n        modifier = modifier,\n    ) {\n        MarkerInfoWindowContent(\n            state = placeState,\n            title = placeDescription,\n            onClick = {\n                placeState.showInfoWindow()\n                true\n            }\n        )\n    }\n}</pre> <p>and Simplify the Caller (passing in a place)</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  GoogleMap(\n                    val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                    GoogleMapDisplay(\n                        place = googleHQ,\n                        placeDescription = \"Google HQ\",\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n//                  ) {\n//                      // no content yet\n//                  }\n                    )\n                }\n            }\n        }\n    }\n}</pre> <p>Our new @Composable takes a <code>LatLng</code> for the place to display the marker, a <code>String</code> description of the marker, and a <code>Modifier</code>. It's a great habit to pass <code>Modifiers</code> into your Composable functions; this allows the caller more control over how the called Composable is placed. You'll want to Pass the Modifier}} to the top-level Composable that your function calls, or use it as a base modifier (rather than passing <code>Modifier.xxx()</code>, you'll pass <code>modifier.xxx()</code> to start with the passed-in <code>Modifier</code>).</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n\n    GoogleMap(\n        modifier = modifier,\n    ) {\n        MarkerInfoWindowContent(\n            // ...\n    }\n}</pre> <p>Now for the marker. We need to set up the data for the Marker - we use rememberMarkerState to create and <code>remember</code> a <code>MarkerState</code> instance. This instance will be re-created whenever the <code>key</code> passed to it is changed. In this example, we want to change the position whenever the <code>LatLng</code> changes. <code>rememberMarkerState</code> takes a <code>String</code> as a key, so we just convert the <code>LatLng</code> to a <code>String</code>.</p> <p>Once we have data, we can Create the Marker in the <code>GoogleMap</code> content.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n    modifier: Modifier,\n) {\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    GoogleMap(\n        modifier = modifier,\n    ) {\n        MarkerInfoWindowContent(\n            state = placeState,\n            title = placeDescription,\n            onClick = {\n                placeState.showInfoWindow()\n                true\n            }\n        )\n    }\n}</pre> <p>Running the application is a bit disappointing; we're still centered at 0.0, 0.0. If we pan over we'll see the marker:</p> <p></p> <p>You can zoom by double-tapping, pinching, or tapping the \"+\" button to see</p> <p></p> <p>If you tap on the marker, its description is displayed and the map centers on the marker:</p> <p></p> All code changes ADDED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.rememberMarkerState\n\n@Composable\nfun GoogleMapDisplay(\n    place: LatLng,\n    placeDescription: String,\n    modifier: Modifier,\n) {\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    GoogleMap(\n        modifier = modifier,\n    ) {\n        MarkerInfoWindowContent(\n            state = placeState,\n            title = placeDescription,\n            onClick = {\n                placeState.showInfoWindow()\n                true\n            }\n        )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  GoogleMap(\n                    val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                    GoogleMapDisplay(\n                        place = googleHQ,\n                        placeDescription = \"Google HQ\",\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n//                  ) {\n//                      // no content yet\n//                  }\n                    )\n                }\n            }\n        }\n    }\n}\n</pre>"},{"location":"modules/google-maps/STEP_060_REPO.html","title":"Initial Position","text":"<p>Let's make the app more friendly by automatically moving to that marker position.</p> <p>First, we define a <code>CameraPosition</code> to indicate where we want to jump to on the map. Think of this as a literal camera, pointing to a LatLng from a specific bearing and tilt, zoomed in/out to a certain factor.</p> <p>We define a <code>CameraPositionState</code> similar to our <code>MarkerState</code> to hold the data for the map camera. It's position is initialized to our <code>defaultCameraPosition</code>, but as the user interacts with the map (panning, zooming, rotating, etc) this state will be updated.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                    val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                    val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                    val cameraPositionState = rememberCameraPositionState {\n                        position = defaultCameraPosition\n                    }\n                    GoogleMapDisplay(\n                        place = googleHQ,\n                        placeDescription = \"Google HQ\",\n                        cameraPositionState = cameraPositionState,\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    )\n                }\n            }\n        }\n    }\n}</pre> <p>Where should we define these state? Only as high in the call hierarchy as needed. Pretend that we have a <code>ViewModel</code> that needs to know when the camera moves; defining the <code>cameraPositionState</code> in <code>onCreate</code> as we're doing here gives us access to that state. If instead we defined it inside <code>GoogleMapView</code>, we would only have access to that state inside <code>GoogleMapView</code> (unless we passed an <code>onCameraChange</code> function that could be used to send out changed camera values). </p> <p>Pulling state up out of functions like this is called \"State Hoisting\".</p> <p>We use that state inside the <code>GoogleMap</code> call</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    place: LatLng,\n    placeDescription: String,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    GoogleMap(\n        cameraPositionState = cameraPositionState,\n        modifier = modifier,\n    ) {\n        // ...\n    }\n}</pre> <p>Now when we run the application, we see the map centered on Google HQ.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.rememberMarkerState\n\n@Composable\nfun GoogleMapDisplay(\n    place: LatLng,\n    placeDescription: String,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    GoogleMap(\n        cameraPositionState = cameraPositionState,\n        modifier = modifier,\n    ) {\n        MarkerInfoWindowContent(\n            state = placeState,\n            title = placeDescription,\n            onClick = {\n                placeState.showInfoWindow()\n                true\n            }\n        )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.rememberCameraPositionState\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                    val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                    val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                    val cameraPositionState = rememberCameraPositionState {\n                        position = defaultCameraPosition\n                    }\n                    GoogleMapDisplay(\n                        place = googleHQ,\n                        placeDescription = \"Google HQ\",\n                        cameraPositionState = cameraPositionState,\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    )\n                }\n            }\n        }\n    }\n}\n</pre>"},{"location":"modules/google-maps/STEP_070_REPO.html","title":"Loading Spinner","text":"<p>Google map takes a little while to initialize. While it's loading, the user sees a blank screen, which may make them think the application isn't working.</p> <p>Adding an animated progress indicator lets the user know the application isn't just hanging. We'll add an \"indeterminate\" (no obvious beginning/end/length) spinning indicator on top of the map for this.</p> <p>First, let's wrap the <code>GoogleMap</code> so we can contain it and the progress spinner that we'll create. We do this using a <code>Box</code>.</p> <p>We need state to keep track of whether the map has finished loading. A simple remembered <code>MutableState</code> will do the trick.</p> <p>This drives the display of the <code>CircularProgressIndicator</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    Box(\n        modifier = modifier,\n    ) {\n        GoogleMap(\n            cameraPositionState = cameraPositionState,\n            onMapLoaded = {\n                mapLoaded = true\n            },\n//      modifier = modifier,\n            modifier = Modifier.fillMaxSize(),\n        ) {\n            MarkerInfoWindowContent(\n                // ...\n        }\n\n        if (!mapLoaded) {\n            AnimatedVisibility(\n                visible = true,\n                modifier = Modifier.fillMaxSize(),\n                enter = EnterTransition.None,\n                exit = fadeOut()\n            ) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .background(MaterialTheme.colorScheme.background)\n                        .wrapContentSize()\n                )\n            }\n        }\n    }\n}</pre> <p>Note</p> <p>Displaying or not displaying the progress indicator just takes an <code>if</code> expression. Note that we could have passed <code>!mapLoaded</code> for the <code>visible</code> parameter to <code>AnimatedVisibility</code>, but that means we'd still be looking at that Composable on every recomposition. Instead I chose to add the <code>if</code> expression around it. </p> <p>This likely doesn't make a big difference here, but I wanted to demonstrate how normal Kotlin logic can be used to conditionally display overlays like this. Some overlays that you use (like a dialog) won't have a parameter like <code>visible</code>.</p> <p><code>AnimatedVisibility</code> is used here to fade-out the progress spinner when it's time to leave the composition. Because it's after the <code>GoogleMap</code> in the <code>Box</code>, it appears on top of it. The solid background prevents any part of the map from being visible before it's completely loaded.</p> <p>When the map tells us it's loaded, we set <code>mapLoaded</code>. When its value changes, recomposition is triggered and changes whether or not we include the progress indicator in the composition tree.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    Box(\n        // ...\n    ) {\n        GoogleMap(\n            cameraPositionState = cameraPositionState,\n            onMapLoaded = {\n                mapLoaded = true\n            },\n//      modifier = modifier,\n            modifier = Modifier.fillMaxSize(),\n        ) {\n            // ...\n        }\n        // ...\n    }\n}</pre> <p>Did you notice how we changed where the passed-in <code>Modifier</code> is used? We moved it from the <code>GoogleMap</code> to the to the <code>Box</code>. This function declares the parent of the <code>GoogleMap</code> (the <code>Box</code>), so we have full control over its <code>Modifiers</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n\n    Box(\n        modifier = modifier,\n    ) {\n        GoogleMap(\n            // ...\n                mapLoaded = true\n            },\n//      modifier = modifier,\n            modifier = Modifier.fillMaxSize(),\n        ) {\n            MarkerInfoWindowContent(\n                // ...\n        }\n        // ...\n    }\n}</pre> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.rememberMarkerState\n\n@Composable\nfun GoogleMapDisplay(\n    place: LatLng,\n    placeDescription: String,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    Box(\n        modifier = modifier,\n    ) {\n        GoogleMap(\n            cameraPositionState = cameraPositionState,\n            onMapLoaded = {\n                mapLoaded = true\n            },\n//      modifier = modifier,\n            modifier = Modifier.fillMaxSize(),\n        ) {\n            MarkerInfoWindowContent(\n                state = placeState,\n                title = placeDescription,\n                onClick = {\n                    placeState.showInfoWindow()\n                    true\n                }\n            )\n        }\n\n        if (!mapLoaded) {\n            AnimatedVisibility(\n                visible = true,\n                modifier = Modifier.fillMaxSize(),\n                enter = EnterTransition.None,\n                exit = fadeOut()\n            ) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .background(MaterialTheme.colorScheme.background)\n                        .wrapContentSize()\n                )\n            }\n        }\n    }\n}\n</pre>"},{"location":"modules/google-maps/STEP_080_REPO.html","title":"Map Types","text":"<p>Google Map provides several types of tiles:</p> <ul> <li>Normal (Streets)</li> <li>Satellite Images</li> <li>Hybrid of Streets/Satellite</li> <li>Terrain</li> <li>No visible map</li> </ul> <p>By adding a dropdown list at the top of the screen, the user can select from these types.</p> <p>We create a new file to host the map-type selector. Not that because we're using the experimental <code>ExposedDropdownMenuBox</code>, so we need to declare we're ok with using experimental API.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MapTypeSelector.kt <pre>// ...\nimport com.google.maps.android.compose.MapType\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MapTypeSelector(\n    currentValue: MapType,\n    modifier: Modifier,\n    onMapTypeClick: (MapType) -&gt; Unit,\n) {\n    var expanded by remember {\n        mutableStateOf(false)\n    }\n    ExposedDropdownMenuBox(\n        expanded = expanded,\n        onExpandedChange = { expanded = !expanded },\n        modifier = modifier,\n    ) {\n        TextField(\n            value = currentValue.name,\n            label = {\n                Text(text = stringResource(id = R.string.map_type))\n            },\n            readOnly = true,    // don't allow user to type\n            onValueChange = {}, // unused\n            trailingIcon = {\n                ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)\n            },\n            colors = ExposedDropdownMenuDefaults.textFieldColors(),\n            modifier = Modifier.menuAnchor().fillMaxWidth()\n        )\n        ExposedDropdownMenu(\n            expanded = expanded,\n            onDismissRequest = { expanded = false },\n            modifier = Modifier.fillMaxWidth(),\n        ) {\n            MapType.entries.forEach {\n                DropdownMenuItem(\n                    text = { Text(text = it.name) },\n                    onClick = {\n                        onMapTypeClick(it)\n                        expanded = false\n                    },\n                    contentPadding = ExposedDropdownMenuDefaults.ItemContentPadding\n                )\n            }\n        }\n    }\n}</pre> <p>Caution</p> <p>Using experimental APIs can get you access to cool new features, but that API is not yet stable. If you use these in your application, there's a chance the API will change and you'll have to rewrite parts of your application. Use with care (if at all)!</p> <p>The standard unidirectional data flow and externalized state patterns of Composable functions is again visible, as we need to declare expansion state and manage it in the call to <code>ExposedDropdownMenuBox</code>. The expansion state is not needed outside of <code>MapTypeSelector</code> so we keep it defined locally.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MapTypeSelector.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MapTypeSelector(\n    // ...\n    onMapTypeClick: (MapType) -&gt; Unit,\n) {\n    var expanded by remember {\n        mutableStateOf(false)\n    }\n    ExposedDropdownMenuBox(\n        expanded = expanded,\n        onExpandedChange = { expanded = !expanded },\n        modifier = modifier,\n    ) {\n        // ...\n    }\n}</pre> <p>We're using a read-only <code>TextField</code> to display the current map type. This gives us the nice little label at the top while showing the current value in a larger font. Note the use of the <code>trailingIcon</code> parameter to add the expansion indicator for the drop-down list.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MapTypeSelector.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MapTypeSelector(\n    // ...\n) {\n    // ...\n    ExposedDropdownMenuBox(\n        // ...\n        modifier = modifier,\n    ) {\n        TextField(\n            value = currentValue.name,\n            label = {\n                Text(text = stringResource(id = R.string.map_type))\n            },\n            readOnly = true,    // don't allow user to type\n            onValueChange = {}, // unused\n            trailingIcon = {\n                ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)\n            },\n            colors = ExposedDropdownMenuDefaults.textFieldColors(),\n            modifier = Modifier.menuAnchor().fillMaxWidth()\n        )\n        ExposedDropdownMenu(\n            expanded = expanded,\n            // ...\n    }\n}</pre> <p>Setting the up the expansion menu should start to look similar to other controls. We tell it if it's <code>expanded</code> or not, and it tells us if the user wanted to change the expansion state. Inside, we loop through the possible values of <code>MapType</code> (it's an enumeration), creating each drop-down item.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MapTypeSelector.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MapTypeSelector(\n    // ...\n) {\n    // ...\n    ExposedDropdownMenuBox(\n        // ...\n    ) {\n        // ...\n            modifier = Modifier.menuAnchor().fillMaxWidth()\n        )\n        ExposedDropdownMenu(\n            expanded = expanded,\n            onDismissRequest = { expanded = false },\n            modifier = Modifier.fillMaxWidth(),\n        ) {\n            MapType.entries.forEach {\n                DropdownMenuItem(\n                    text = { Text(text = it.name) },\n                    onClick = {\n                        onMapTypeClick(it)\n                        expanded = false\n                    },\n                    contentPadding = ExposedDropdownMenuDefaults.ItemContentPadding\n                )\n            }\n        }\n    }\n}</pre> <p>When the user clicks an item, we tell the caller which <code>MapType</code> was clicked and close the drop-down menu.</p> <p>Back in our <code>GoogleMapDisplay</code>, we keep track of the <code>MapType</code>. We need to share that <code>MapType</code> between the <code>GoogleMap</code> and the <code>MapTypeSelector</code>; defining it here makes it available to both.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val placeState =\n        // ...\n}</pre> <p>For our layout, we'll wrap the <code>GoogleMap</code> and <code>MapTypeSelector</code> in a <code>Column</code>. The <code>MapTypeSelector</code> stays a fixed size,</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    Box(\n        modifier = modifier,\n    ) {\n        Column(\n            modifier = Modifier.fillMaxSize()\n        ) {\n            MapTypeSelector(\n                currentValue = currentMapType,\n                modifier = Modifier.fillMaxWidth(),\n            ) {\n                mapProperties = mapProperties.copy(mapType = it)\n                currentMapType = it\n            }\n            GoogleMap(\n                cameraPositionState = cameraPositionState,\n                onMapLoaded = {\n                    mapLoaded = true\n                },\n                properties = mapProperties,\n//          modifier = Modifier.fillMaxSize(),\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n            ) {\n                MarkerInfoWindowContent(\n                    state = placeState,\n                    title = placeDescription,\n                    onClick = {\n                        placeState.showInfoWindow()\n                        true\n                    }\n                )\n            }\n        }\n\n        if (!mapLoaded) {\n            AnimatedVisibility(\n                visible = true,\n                modifier = Modifier.fillMaxSize(),\n                enter = EnterTransition.None,\n                exit = fadeOut()\n            ) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .background(MaterialTheme.colorScheme.background)\n                        .wrapContentSize()\n                )\n            }\n        }\n    }\n}</pre> <p>while we set the <code>GoogleMap</code> weight to fill the remaining height (and tell it to fill the available width).</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    Box(\n        // ...\n    ) {\n        Column(\n            // ...\n        ) {\n            // ...\n            GoogleMap(\n                // ...\n                },\n                properties = mapProperties,\n//          modifier = Modifier.fillMaxSize(),\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n            ) {\n                MarkerInfoWindowContent(\n                    // ...\n            }\n        }\n        // ...\n    }\n}</pre> <p>The <code>GoogleMap</code> uses a <code>MapProperties</code> state holder to track the map type (among other options). We'll initialize it with the \"normal\" (streets-only) map type, and pass it to the <code>GoogleMap</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    Box(\n        // ...\n    ) {\n        Column(\n            // ...\n        ) {\n            // ...\n            GoogleMap(\n                cameraPositionState = cameraPositionState,\n                onMapLoaded = {\n                    mapLoaded = true\n                },\n                properties = mapProperties,\n//          modifier = Modifier.fillMaxSize(),\n                modifier = Modifier\n                    // ...\n            ) {\n                // ...\n            }\n        }\n        // ...\n    }\n}</pre> <p>The resulting application now looks like this (when \"Normal\" map type is selected)</p> <p></p> <p>and this (when \"Satellite\" map type is selected)</p> <p></p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.rememberMarkerState\n\n@Composable\nfun GoogleMapDisplay(\n    place: LatLng,\n    placeDescription: String,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val placeState =\n        rememberMarkerState(key = place.toString(), position = place)\n\n    Box(\n        modifier = modifier,\n    ) {\n        Column(\n            modifier = Modifier.fillMaxSize()\n        ) {\n            MapTypeSelector(\n                currentValue = currentMapType,\n                modifier = Modifier.fillMaxWidth(),\n            ) {\n                mapProperties = mapProperties.copy(mapType = it)\n                currentMapType = it\n            }\n            GoogleMap(\n                cameraPositionState = cameraPositionState,\n                onMapLoaded = {\n                    mapLoaded = true\n                },\n                properties = mapProperties,\n//          modifier = Modifier.fillMaxSize(),\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n            ) {\n                MarkerInfoWindowContent(\n                    state = placeState,\n                    title = placeDescription,\n                    onClick = {\n                        placeState.showInfoWindow()\n                        true\n                    }\n                )\n            }\n        }\n\n        if (!mapLoaded) {\n            AnimatedVisibility(\n                visible = true,\n                modifier = Modifier.fillMaxSize(),\n                enter = EnterTransition.None,\n                exit = fadeOut()\n            ) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .background(MaterialTheme.colorScheme.background)\n                        .wrapContentSize()\n                )\n            }\n        }\n    }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MapTypeSelector.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.material3.DropdownMenuItem\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.ExposedDropdownMenuBox\nimport androidx.compose.material3.ExposedDropdownMenuDefaults\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextField\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.google.maps.android.compose.MapType\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MapTypeSelector(\n    currentValue: MapType,\n    modifier: Modifier,\n    onMapTypeClick: (MapType) -&gt; Unit,\n) {\n    var expanded by remember {\n        mutableStateOf(false)\n    }\n    ExposedDropdownMenuBox(\n        expanded = expanded,\n        onExpandedChange = { expanded = !expanded },\n        modifier = modifier,\n    ) {\n        TextField(\n            value = currentValue.name,\n            label = {\n                Text(text = stringResource(id = R.string.map_type))\n            },\n            readOnly = true,    // don't allow user to type\n            onValueChange = {}, // unused\n            trailingIcon = {\n                ExposedDropdownMenuDefaults.TrailingIcon(expanded = expanded)\n            },\n            colors = ExposedDropdownMenuDefaults.textFieldColors(),\n            modifier = Modifier.menuAnchor().fillMaxWidth()\n        )\n        ExposedDropdownMenu(\n            expanded = expanded,\n            onDismissRequest = { expanded = false },\n            modifier = Modifier.fillMaxWidth(),\n        ) {\n            MapType.entries.forEach {\n                DropdownMenuItem(\n                    text = { Text(text = it.name) },\n                    onClick = {\n                        onMapTypeClick(it)\n                        expanded = false\n                    },\n                    contentPadding = ExposedDropdownMenuDefaults.ItemContentPadding\n                )\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Google Maps&lt;/string&gt;\n    &lt;string name=\"map_type\"&gt;Map Type&lt;/string&gt;\n&lt;/resources&gt;\n</pre>"},{"location":"modules/google-maps/STEP_090_REPO.html","title":"Current Location","text":"<p>Note</p> <p>You only need to add the Google Play Services support here if your application needs to display the user's current location.</p> <p>Next, let's add the user's current location. A little later we'll use this for the initial map position and to keep track of where the user parked their car.</p> <p>The user's Location is determined by the \"Fused Location Provider\". This service uses technologies such as GPS, cell towers, and wi-fi to determine the current location. Some of these provide precise location (such as GPS), while others might only be able to approximate user location.</p> <p>Because an application could send location information somewhere else (a server on the internet, for example), location is considered a \"dangerous\" permission, and we must ask the user if it's ok to use while the application is running.</p> <p>The user has a choice: they can allow precise or approximate location information, for all runs of the application or just the current run, or deny the request. Ideally, your application should gracefully handle denied function. For our car-finder application, if the user denies current location tracking, we could, for example, allow the user to tap the location of their car on the map rather than automatically using the current location. (For this example application, we won't do that; we'll just tell the user the application cannot function without location.)</p> <p>Note</p> <p>Requesting permissions at runtime can be a bit tricky, and support for permissions when using Jetpack Compose is still experimental (and a bit difficult to use properly). For now, we'll be requesting permissions and listening for location using the <code>Activity</code> and updating a view model with the reported locations.</p> <p>Any needed permissions must be declared first in the <code>AndroidManifest.xml</code>. Here we declare </p> show in full file  app/src/main/AndroidManifest.xml <pre>// ...\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n\n    &lt;application\n        // ...\n&lt;/manifest&gt;</pre> <ul> <li>Coarse Location (for \"approximate\" location)</li> <li>Fine Location (for \"precise\" location)</li> </ul> <p>Both of these are \"dangerous\" permissions and must be requested at runtime.</p> <p>The Google Play Location Services allows us to set up a listener to receive location updates. We'll want to store the current location somewhere, and we'll need it when setting the car's location. The car's location will be persisted and we want to ensure it stays across configuration changes. This sounds like a job for a View Model.</p> <p>We access Play Location Services by adding a new dependency. While we're here we'll also add lifecycle support for compose.</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\n//\nmaps-compose = \"6.2.1\"\nlocation-services = \"21.3.0\"\nlifecycle-runtime-compose = \"2.8.7\"\n\n[libraries]\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\nlifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-runtime-compose\" }\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\n// ...\n[plugins]\n// ...</pre> show in full file  app/build.gradle.kts <pre>// ...\n\ndependencies {\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    // ...\n}\n// ...</pre> <p>We'll need to track the location. We create a <code>CarViewModel</code> and set up a <code>MutableStateFlow</code> as a <code>private</code> property in the view model. By convention, we prefix it with an underscore, indicating it's the actual flow that we'll emit to. We want our view model to keep control of emitted values, so we only expose a read-only <code>Flow</code> publicly.</p> <p>But our <code>MainActivity</code> will be the thing that actually talks with the Fused Location Provider; it'll need to update the current location (by calling <code>updateLocation</code>).</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/CarViewModel.kt <pre>// ...\nimport kotlinx.coroutines.flow.MutableStateFlow\n\nclass CarViewModel(application: Application) : AndroidViewModel(application) {\n    private val _currentLocation = MutableStateFlow&lt;Location?&gt;(null)\n\n    val currentLocation: Flow&lt;Location?&gt;\n        get() = _currentLocation\n\n    fun updateLocation(location: Location?) {\n        _currentLocation.value = location\n    }\n}</pre> <p>In the <code>MainActivity</code>, we define properties for the fused location provider client and the callback that we'll register to receive location updates.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\n\nclass MainActivity : ComponentActivity() {\n//  override fun onCreate(savedInstanceState: Bundle?) {\n//      super.onCreate(savedInstanceState)\n    private val viewModel: CarViewModel by viewModels()\n\n    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient\n    private val locationCallback = object : LocationCallback() {\n        override fun onLocationResult(locationResult: LocationResult) {\n            viewModel.updateLocation(locationResult.lastLocation)\n        }\n    }\n\n    private val getLocationPermission =\n        // ...\n}</pre> <p>We have to set up a new sequence of events to start our activity. This sequence looks like</p> <pre><code>graph TD\n    A{Check Google Play Services}\n    X[Cannot run - exit]\n    X2[Cannot run - exit]\n    A --&gt;|Not Available|X\n    A --&gt;|Available|B\n\n    B{Do we have location permission?}\n    B --&gt;|Yes|C\n    B --&gt;|No|E\n    C[Start location request]\n    C --&gt; D\n    D[Setup Map]\n\n    E[Request Location Permissions]\n    E --&gt; F\n    F{Were permissions granted?}\n    F --&gt;|No|G\n    F --&gt;|Yes|C\n    G[Show rationale]\n    G --&gt; H\n    H{Does user agree?}\n    H --&gt;|Yes|I\n    H --&gt;|No|X2\n    I[Application Info Screen to change permissions - exits application]</code></pre> <p>We move the UI setup out of <code>onCreate</code> (we'll see it again soon), and check Google Play Services Availability. If Play Services aren't available,  we can't run and must exit.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        GoogleApiAvailability.getInstance()\n            .makeGooglePlayServicesAvailable(this)\n            .addOnSuccessListener {\n                if (ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_FINE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED &amp;&amp;\n                    ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_COARSE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    getLocationPermission.launch(\n                        arrayOf(\n                            android.Manifest.permission.ACCESS_FINE_LOCATION,\n                            android.Manifest.permission.ACCESS_COARSE_LOCATION,\n                        )\n                    )\n                } else {\n                    startLocationAndMap()\n                }\n            }.addOnFailureListener(this) {\n                Toast.makeText(\n                    this,\n                    \"Google Play services required (or upgrade required)\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                finish()\n            }\n\n    }\n}</pre> <p>If Play Services are available, we check if we have location permissions. If not, we request permission. If so, we just go ahead and start our location request and set up the UI.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        GoogleApiAvailability.getInstance()\n            .makeGooglePlayServicesAvailable(this)\n            .addOnSuccessListener {\n                if (ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_FINE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED &amp;&amp;\n                    ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_COARSE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    getLocationPermission.launch(\n                        arrayOf(\n                            android.Manifest.permission.ACCESS_FINE_LOCATION,\n                            android.Manifest.permission.ACCESS_COARSE_LOCATION,\n                        )\n                    )\n                } else {\n                    startLocationAndMap()\n                }\n            }.addOnFailureListener(this) {\n                Toast.makeText(\n                    // ...\n            }\n    // ...\n    }\n}</pre> <p>Requesting permissions has gotten a bit easier over the years... We register a launcher that will invoke the system permission requester and return whether the user granted or denied permissions. If granted, we go ahead and start the location request and set up the UI. If not granted, we go into rationale mode.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    }\n\n    private val getLocationPermission =\n        registerForActivityResult(\n            ActivityResultContracts.RequestMultiplePermissions()\n        ) { isGranted -&gt;\n            if (isGranted.values.any { it }) {\n                startLocationAndMap()\n            } else {\n                // if the user denied permissions, tell them they\n                //   cannot use the app without them. In general,\n                //   you should try to just reduce function and let the\n                //   user continue, but location is a key part of this\n                //   application.\n                //   (Note that a real version of this application\n                //   might allow the user to manually click on the map\n                //   to set their current location, and we wouldn't\n                //   show this dialog, or perhaps only show it once)\n                // NOTE: This is a normal Android-View-based dialog, not a compose one!\n                AlertDialog.Builder(this)\n                    .setTitle(\"Permissions Needed\")\n                    .setMessage(\n                        \"We need coarse-location or fine-location permission \" +\n                                \"to locate a car (fine location is highly \" +\n                                \"recommended for accurate car locating). \" +\n                                \"Please allow these permissions via App Info \" +\n                                \"settings\")\n                    .setCancelable(false)\n                    .setNegativeButton(\"Quit\") { _, _ -&gt; finish() }\n                    .setPositiveButton(\"App Info\") { _, _ -&gt;\n                        startActivity(\n                            Intent(\n                                Settings.ACTION_APPLICATION_DETAILS_SETTINGS\n                            ).apply {\n                                data = Uri.parse(\"package:$packageName\")\n                            }\n                        )\n                        finish()\n                    }\n                    .show()\n            }\n        }\n\n    @SuppressLint(\"MissingPermission\")\n    // ...\n}</pre> <p>We've decided that our car finder simply cannot run without knowing the current location, so we display this rationale to the user in a dialog. (Note that this is an old-style \"views\" dialog, not a Jetpack Compose dialog.) The user can agree to go change the permissions (and we'll send them to the system Application Info screen to do so), or they can say \"nope!\" and we'll quit the application by calling <code>finish()</code> on the <code>Activity</code> (which pops it off the back stack - because we only have one <code>Activity</code> on the back stack, the application exits).</p> <p>After all of the availability and permission checking, we can finally start the application in <code>startLocationAndMap()</code>. The first thing we do is request location updates from the fused location provider, which will use our <code>locationCallback</code> to send the results to the view model.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n        }\n\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        val locationRequest =\n            LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n                .setWaitForAccurateLocation(false)\n                .setMinUpdateIntervalMillis(0)\n                .setMaxUpdateDelayMillis(5000)\n                .build()\n        fusedLocationProviderClient =\n            LocationServices.getFusedLocationProviderClient(this)\n        fusedLocationProviderClient.requestLocationUpdates(\n            locationRequest,\n            locationCallback,\n            Looper.getMainLooper()\n        )\n\n        enableEdgeToEdge()\n        // ...\n    }\n    // ...\n}</pre> <p>This will emit the location, which is collected and made available to our composition.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                    // ...\n                    }\n\n                    val currentLocation by viewModel.currentLocation.collectAsStateWithLifecycle(\n                        initialValue = null\n                    )\n\n                    GoogleMapDisplay(\n//                      place = googleHQ,\n//                      placeDescription = \"Google HQ\",\n                        currentLocation = currentLocation,\n                        cameraPositionState = cameraPositionState,\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    )\n                }\n            }\n        }\n    // ...\n    }\n    // ...\n}</pre> <p>We pass the location to the <code>GoogleMapDisplay</code> and create a <code>MarkerState</code> to give us a location for a new <code>Marker</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n//  place: LatLng,\n//  placeDescription: String,\n    currentLocation: Location?,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n//  val placeState =\n//      rememberMarkerState(key = place.toString(), position = place)\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    Box(\n        // ...\n    ) {\n        Column(\n            // ...\n        ) {\n            // ...\n            GoogleMap(\n                // ...\n                    .weight(1f),\n            ) {\n                currentLocationState?.let {\n                    MarkerInfoWindowContent(\n//                  state = placeState,\n//                  title = placeDescription,\n//                  onClick = {\n//                      placeState.showInfoWindow()\n//                      true\n//                  }\n                        state = it,\n                        anchor = Offset(0.5f, 0.5f),\n                        title = stringResource(\n                            id = R.string.current_location\n                        ),\n                    )\n                }\n            }\n        }\n        // ...\n    }\n}</pre> <p>When we run the app, the location marker appears when it's available.</p> <p>Note</p> <p>You can use the \"Extended Controls\" at the top of the emulator to set a fake location. This will prove very useful when testing this application, as we can set a location, save the car at that location, change the location to simulate walking away from the car, then press navigate to see how to get back to the car.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.google.google.maps\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.google.google.maps\"\n        minSdk = 24\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}\n</pre> CHANGED: app/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n    &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n\n    &lt;application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.GoogleMaps\"\n        tools:targetApi=\"31\"&gt;\n\n        &lt;meta-data\n            android:name=\"com.google.android.geo.API_KEY\"\n            android:value=\"${MAPS_API_KEY}\" /&gt;\n\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/Theme.GoogleMaps\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/google/google/maps/CarViewModel.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.app.Application\nimport android.location.Location\nimport androidx.lifecycle.AndroidViewModel\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\n\nclass CarViewModel(application: Application) : AndroidViewModel(application) {\n    private val _currentLocation = MutableStateFlow&lt;Location?&gt;(null)\n\n    val currentLocation: Flow&lt;Location?&gt;\n        get() = _currentLocation\n\n    fun updateLocation(location: Location?) {\n        _currentLocation.value = location\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.location.Location\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\n\n@Composable\nfun GoogleMapDisplay(\n//  place: LatLng,\n//  placeDescription: String,\n    currentLocation: Location?,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n//  val placeState =\n//      rememberMarkerState(key = place.toString(), position = place)\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    Box(\n        modifier = modifier,\n    ) {\n        Column(\n            modifier = Modifier.fillMaxSize()\n        ) {\n            MapTypeSelector(\n                currentValue = currentMapType,\n                modifier = Modifier.fillMaxWidth(),\n            ) {\n                mapProperties = mapProperties.copy(mapType = it)\n                currentMapType = it\n            }\n            GoogleMap(\n                cameraPositionState = cameraPositionState,\n                onMapLoaded = {\n                    mapLoaded = true\n                },\n                properties = mapProperties,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n            ) {\n                currentLocationState?.let {\n                    MarkerInfoWindowContent(\n//                  state = placeState,\n//                  title = placeDescription,\n//                  onClick = {\n//                      placeState.showInfoWindow()\n//                      true\n//                  }\n                        state = it,\n                        anchor = Offset(0.5f, 0.5f),\n                        title = stringResource(\n                            id = R.string.current_location\n                        ),\n                    )\n                }\n            }\n        }\n\n        if (!mapLoaded) {\n            AnimatedVisibility(\n                visible = true,\n                modifier = Modifier.fillMaxSize(),\n                enter = EnterTransition.None,\n                exit = fadeOut()\n            ) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .background(MaterialTheme.colorScheme.background)\n                        .wrapContentSize()\n                )\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.annotation.SuppressLint\nimport android.app.AlertDialog\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Bundle\nimport android.os.Looper\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.core.app.ActivityCompat\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.android.gms.common.GoogleApiAvailability\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.LocationServices\nimport com.google.android.gms.location.Priority\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.rememberCameraPositionState\n\nclass MainActivity : ComponentActivity() {\n//  override fun onCreate(savedInstanceState: Bundle?) {\n//      super.onCreate(savedInstanceState)\n    private val viewModel: CarViewModel by viewModels()\n\n    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient\n    private val locationCallback = object : LocationCallback() {\n        override fun onLocationResult(locationResult: LocationResult) {\n            viewModel.updateLocation(locationResult.lastLocation)\n        }\n    }\n\n    private val getLocationPermission =\n        registerForActivityResult(\n            ActivityResultContracts.RequestMultiplePermissions()\n        ) { isGranted -&gt;\n            if (isGranted.values.any { it }) {\n                startLocationAndMap()\n            } else {\n                // if the user denied permissions, tell them they\n                //   cannot use the app without them. In general,\n                //   you should try to just reduce function and let the\n                //   user continue, but location is a key part of this\n                //   application.\n                //   (Note that a real version of this application\n                //   might allow the user to manually click on the map\n                //   to set their current location, and we wouldn't\n                //   show this dialog, or perhaps only show it once)\n                // NOTE: This is a normal Android-View-based dialog, not a compose one!\n                AlertDialog.Builder(this)\n                    .setTitle(\"Permissions Needed\")\n                    .setMessage(\n                        \"We need coarse-location or fine-location permission \" +\n                                \"to locate a car (fine location is highly \" +\n                                \"recommended for accurate car locating). \" +\n                                \"Please allow these permissions via App Info \" +\n                                \"settings\")\n                    .setCancelable(false)\n                    .setNegativeButton(\"Quit\") { _, _ -&gt; finish() }\n                    .setPositiveButton(\"App Info\") { _, _ -&gt;\n                        startActivity(\n                            Intent(\n                                Settings.ACTION_APPLICATION_DETAILS_SETTINGS\n                            ).apply {\n                                data = Uri.parse(\"package:$packageName\")\n                            }\n                        )\n                        finish()\n                    }\n                    .show()\n            }\n        }\n\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        val locationRequest =\n            LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n                .setWaitForAccurateLocation(false)\n                .setMinUpdateIntervalMillis(0)\n                .setMaxUpdateDelayMillis(5000)\n                .build()\n        fusedLocationProviderClient =\n            LocationServices.getFusedLocationProviderClient(this)\n        fusedLocationProviderClient.requestLocationUpdates(\n            locationRequest,\n            locationCallback,\n            Looper.getMainLooper()\n        )\n\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                    val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                    val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                    val cameraPositionState = rememberCameraPositionState {\n                        position = defaultCameraPosition\n                    }\n\n                    val currentLocation by viewModel.currentLocation.collectAsStateWithLifecycle(\n                        initialValue = null\n                    )\n\n                    GoogleMapDisplay(\n//                      place = googleHQ,\n//                      placeDescription = \"Google HQ\",\n                        currentLocation = currentLocation,\n                        cameraPositionState = cameraPositionState,\n                        modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    )\n                }\n            }\n        }\n\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        GoogleApiAvailability.getInstance()\n            .makeGooglePlayServicesAvailable(this)\n            .addOnSuccessListener {\n                if (ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_FINE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED &amp;&amp;\n                    ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_COARSE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    getLocationPermission.launch(\n                        arrayOf(\n                            android.Manifest.permission.ACCESS_FINE_LOCATION,\n                            android.Manifest.permission.ACCESS_COARSE_LOCATION,\n                        )\n                    )\n                } else {\n                    startLocationAndMap()\n                }\n            }.addOnFailureListener(this) {\n                Toast.makeText(\n                    this,\n                    \"Google Play services required (or upgrade required)\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                finish()\n            }\n\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Google Maps&lt;/string&gt;\n    &lt;string name=\"map_type\"&gt;Map Type&lt;/string&gt;\n    &lt;string name=\"current_location\"&gt;Current Location&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nsecrets = \"2.0.1\"\n//\nmaps-compose = \"6.2.1\"\nlocation-services = \"21.3.0\"\nlifecycle-runtime-compose = \"2.8.7\"\n\n[libraries]\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\nlifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-runtime-compose\" }\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\n//\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }\n</pre>"},{"location":"modules/google-maps/STEP_100_REPO.html","title":"Jump to Current Location","text":"<p>Let's jump to the current location when it's first available and use a custom icon instead of the default marker.</p> <p>First, our custom icon. We need to get a <code>BitmapDescriptor</code>. There's no way to do that yet from Compose, so we'll define a drawable vector image resource for this.</p> <p>You can create icons using File-&gt;New-&gt;Vector Asset, and select an icon or pull in an SVG. But for this task, the icon is just a blue circle with a white border.</p> <p>The icon will use a custom color, which must be defined in a resource file, rather than through Compose for now.</p> show in full file  app/src/main/res/values/colors.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;color name=\"my_location\"&gt;#FF0000FF&lt;/color&gt;\n    &lt;color name=\"purple_200\"&gt;#FFBB86FC&lt;/color&gt;\n    &lt;color name=\"purple_500\"&gt;#FF6200EE&lt;/color&gt;\n    // ...\n&lt;/resources&gt;</pre> <p>To create the shape, we define an Android <code>&lt;shape&gt;</code> resource. This defines the <code>&lt;shape&gt;</code> as an <code>oval</code>, but because we use the same <code>android:width</code> and <code>android:height</code>, we get a circle. The <code>&lt;stroke&gt;</code> defines the border color of the circle, and <code>&lt;solid&gt;</code> defines the fill color. </p> show in full file  app/src/main/res/drawable/ic_current_location.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;shape android:shape=\"oval\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;size android:height=\"24dp\" android:width=\"24dp\" /&gt;\n    &lt;stroke android:color=\"@android:color/white\" android:width=\"3dp\"/&gt;\n    &lt;solid android:color=\"@color/my_location\" /&gt;\n&lt;/shape&gt;</pre> <p>To simplify loading the icon, I've defined some helper functions. These are used to load the <code>Drawable</code> resource, convert it to a <code>Bitmap</code>, and get a <code>BitmapDescriptor</code> for the map to use. </p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/DrawableHelpers.kt <pre>// ...\n// markdown and use another tool to generate something prettier...\n\n/**\n * Returns a [Bitmap] for the intrinsic size of any [Drawable]. If the\n * drawable is a [BitmapDrawable], we just return it. Otherwise, we create a\n * new [Bitmap] of the intrinsic size of the [Drawable], draw the [Drawable]\n * to it, and return the [Bitmap].\n *\n * @sample com.androidbyexample.compose.google.google.maps.loadBitmap\n * @receiver Any [Drawable]\n * @return a [Bitmap] representation of the [Drawable]\n */\nfun Drawable.toBitmap(): Bitmap =\n    when {\n        // if it's already a bitmap; just return it\n        this is BitmapDrawable -&gt; bitmap\n        // otherwise, create a bitmap and draw the drawable to it\n        intrinsicWidth == 0 || intrinsicHeight == 0 -&gt;\n            throw IllegalArgumentException(\n                \"Drawable cannot be converted to a Bitmap; it must have \" +\n                        \"non-zero intrinsic width and height\")\n        else -&gt;\n            Bitmap.createBitmap(\n                intrinsicWidth,\n                intrinsicHeight,\n                Bitmap.Config.ARGB_8888\n            ).apply {\n                val canvas = Canvas(this)\n                setBounds(0, 0, canvas.width, canvas.height)\n                draw(canvas)\n            }\n    }\n\n/**\n * Loads a [Bitmap] by the resource id of a [Drawable].\n *\n * @sample com.androidbyexample.compose.google.google.maps.loadBitmapDescriptor\n * @receiver [Context] to load the [Drawable]\n * @param id [Int] the resource id of the [Drawable]\n * @return a [Bitmap] representation of the [Drawable]\n */\nfun Context.loadBitmap(@DrawableRes id: Int): Bitmap =\n    ContextCompat.getDrawable(this, id)?.toBitmap()\n        ?: throw Resources.NotFoundException(resources.getResourceName(id))\n\n/**\n * Loads a [BitmapDescriptor] by the resource id of a [Drawable].\n *\n * @sample com.androidbyexample.compose.google.google.maps.MainActivity.onCreate\n * @receiver [Context] to load the [Drawable]\n * @param id [Int] the resource id of the [Drawable]\n * @return a [Bitmap] representation of the [Drawable]\n */\n// they actually are resolved by dokka 'samples' config\nfun Context.loadBitmapDescriptor(@DrawableRes id: Int): BitmapDescriptor =\n    loadBitmap(id).toBitmapDescriptor()\n\n/**\n * Converts a [Bitmap] to a [BitmapDescriptor]\n *\n * @sample com.androidbyexample.compose.google.google.maps.loadBitmapDescriptor\n */\nfun Bitmap.toBitmapDescriptor(): BitmapDescriptor =\n    BitmapDescriptorFactory.fromBitmap(this)</pre> <p>I've added KDoc comments to these helper functions to demonstrate how you can generate API documentation. I've set up Dokka</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nlocation-services = \"21.3.0\"\nlifecycle-runtime-compose = \"2.8.7\"\ndokka = \"1.9.20\"\n\n[libraries]\n// ...\n[plugins]\n// ...\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }\ndokka = { id = \"org.jetbrains.dokka\", version.ref = \"dokka\" }</pre> show in full file  app/build.gradle.kts <pre>plugins {\n    // ...\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n    alias(libs.plugins.dokka)\n}\n\n// ...</pre> <p>which you can use to generate documentation using tasks like</p> <pre><code>./gradlew dokkaHtml\n./gradlew dokkaGfm\n</code></pre> <p>(Gfm is \"Github-flavored Markdown\")</p> <p>We can use these helpers to load the icon in a coroutine once the map has loaded. </p> <p>To load the icon resource, we need</p> <ul> <li>An Android <code>Context</code>, which in this case will be the <code>Activity</code>. The <code>Context</code> provides      access to the current device configuration and resources.</li> <li>A bucket to store the icon once it's loaded, <code>currentLocationItem</code></li> <li>A coroutine <code>scope</code> to load the icon asynchronously</li> </ul> <p>Finally, we set the icon on the <code>Marker</code>. </p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    }\n\n    val context = LocalContext.current\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    // ...\n    Box(\n        // ...\n    ) {\n        Column(\n            // ...\n        ) {\n            // ...\n            GoogleMap(\n                // ...\n                onMapLoaded = {\n                    mapLoaded = true\n                    scope.launch(Dispatchers.IO) {\n                        currentLocationIcon =\n                            context.loadBitmapDescriptor(\n                                R.drawable.ic_current_location\n                            )\n                    }\n                },\n                properties = mapProperties,\n                // ...\n            ) {\n                currentLocationState?.let {\n                    MarkerInfoWindowContent(\n                        state = it,\n                        icon = currentLocationIcon,\n                        anchor = Offset(0.5f, 0.5f),\n                        title = stringResource(\n                            // ...\n                    )\n                }\n            }\n        }\n        // ...\n    }\n}</pre> <p>Note</p> <p>The factory for the <code>BitmapDescriptor</code> sometimes isn't available until the map has loaded. It's best to wait until the map is successfully loaded before trying to load the icons. We do this by placing the call inside the <code>onMapReady</code> lambda parameter to <code>GoogleMap</code></p> <p>The <code>anchor</code> parameter defines how the location matches up with the icon.</p> <p>Using an <code>Offset(0.5, 0.5)</code> means the center of the icon is pinned to the location. For the default icons, the bottom center (the pointy tip) marks the location, so we'd use <code>Offset(0.5, 1.0)</code>.</p> <p>Mea culpa: I accidentally copied the <code>Offset(0.5, 0.5)</code> (as seen above) when I first created the location marker in a previous step. It was using the default marker, so it should have used <code>Offset(0.5, 1.0)</code>. <code>Offset(0.5, 0.5)</code> is appropriate for this circle marker, so we leave it as is.</p> <p>Running the application now shows (but you have to manually pan to it)</p> <p></p> <p>Jumping to the current location on startup is done with a <code>LaunchedEffect</code> keyed off <code>mapLoaded</code> and <code>currentLocation</code>. The first time this <code>LaunchedEffect</code> is run, <code>mapLoaded</code> is <code>false</code> and the <code>currentLocation</code> is null, so it doesn't do anything.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n        if (mapLoaded) {\n            if (currentLocation != null) {\n                if (!initialBoundsSet) {\n                    initialBoundsSet = true\n                    val current =\n                        LatLng(currentLocation.latitude, currentLocation.longitude)\n                    cameraPositionState.animate(\n                        CameraUpdateFactory.newLatLngZoom(\n                            current,\n                            16f\n                        ), 1000\n                    )\n                }\n            }\n        }\n    }\n\n    Box(\n        // ...\n}</pre> <p>When either <code>mapLoaded</code> or <code>currentLocation</code> changes, the <code>LaunchedEffect</code> is restarted. It's important that we use both of these keys, as we have no idea which of the map or the current location will be available first. If we only used <code>currentLocation</code>, and the location were available before the map was ready, we'd be stuck in our original location.</p> <p>Once both are available, the <code>LaunchedEffect</code> asks the <code>cameraPositionState</code> to change via a <code>CameraUpdate</code> command. We set <code>initialBoundsSet</code> to <code>true</code> so we won't move again.</p> <p>Note</p> <p>I'm using the name <code>initialBoundsSet</code> because later we'll be setting a bounding box based on the current location and set car location.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n    alias(libs.plugins.dokka)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.google.google.maps\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.google.google.maps\"\n        minSdk = 24\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/google/google/maps/DrawableHelpers.kt <pre>package com.androidbyexample.compose.google.google.maps\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport android.content.Context\nimport android.content.res.Resources\nimport android.graphics.Bitmap\nimport android.graphics.Canvas\nimport android.graphics.drawable.BitmapDrawable\nimport android.graphics.drawable.Drawable\nimport androidx.annotation.DrawableRes\nimport androidx.core.content.ContextCompat\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.BitmapDescriptorFactory\n\n// NOTE: I wanted to show an example of a set of extensions nicely-documented\n// for KDoc generation using the Dokka tool. There's an example of the setup\n// in the build scripts. Note that Dokka is still pretty young and doesn't\n// generate the prettiest documentation... But you can use it to generate\n// markdown and use another tool to generate something prettier...\n\n/**\n * Returns a [Bitmap] for the intrinsic size of any [Drawable]. If the\n * drawable is a [BitmapDrawable], we just return it. Otherwise, we create a\n * new [Bitmap] of the intrinsic size of the [Drawable], draw the [Drawable]\n * to it, and return the [Bitmap].\n *\n * @sample com.androidbyexample.compose.google.google.maps.loadBitmap\n * @receiver Any [Drawable]\n * @return a [Bitmap] representation of the [Drawable]\n */\nfun Drawable.toBitmap(): Bitmap =\n    when {\n        // if it's already a bitmap; just return it\n        this is BitmapDrawable -&gt; bitmap\n        // otherwise, create a bitmap and draw the drawable to it\n        intrinsicWidth == 0 || intrinsicHeight == 0 -&gt;\n            throw IllegalArgumentException(\n                \"Drawable cannot be converted to a Bitmap; it must have \" +\n                        \"non-zero intrinsic width and height\")\n        else -&gt;\n            Bitmap.createBitmap(\n                intrinsicWidth,\n                intrinsicHeight,\n                Bitmap.Config.ARGB_8888\n            ).apply {\n                val canvas = Canvas(this)\n                setBounds(0, 0, canvas.width, canvas.height)\n                draw(canvas)\n            }\n    }\n\n/**\n * Loads a [Bitmap] by the resource id of a [Drawable].\n *\n * @sample com.androidbyexample.compose.google.google.maps.loadBitmapDescriptor\n * @receiver [Context] to load the [Drawable]\n * @param id [Int] the resource id of the [Drawable]\n * @return a [Bitmap] representation of the [Drawable]\n */\nfun Context.loadBitmap(@DrawableRes id: Int): Bitmap =\n    ContextCompat.getDrawable(this, id)?.toBitmap()\n        ?: throw Resources.NotFoundException(resources.getResourceName(id))\n\n/**\n * Loads a [BitmapDescriptor] by the resource id of a [Drawable].\n *\n * @sample com.androidbyexample.compose.google.google.maps.MainActivity.onCreate\n * @receiver [Context] to load the [Drawable]\n * @param id [Int] the resource id of the [Drawable]\n * @return a [Bitmap] representation of the [Drawable]\n */\n// they actually are resolved by dokka 'samples' config\nfun Context.loadBitmapDescriptor(@DrawableRes id: Int): BitmapDescriptor =\n    loadBitmap(id).toBitmapDescriptor()\n\n/**\n * Converts a [Bitmap] to a [BitmapDescriptor]\n *\n * @sample com.androidbyexample.compose.google.google.maps.loadBitmapDescriptor\n */\nfun Bitmap.toBitmapDescriptor(): BitmapDescriptor =\n    BitmapDescriptorFactory.fromBitmap(this)\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.location.Location\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    val context = LocalContext.current\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n        if (mapLoaded) {\n            if (currentLocation != null) {\n                if (!initialBoundsSet) {\n                    initialBoundsSet = true\n                    val current =\n                        LatLng(currentLocation.latitude, currentLocation.longitude)\n                    cameraPositionState.animate(\n                        CameraUpdateFactory.newLatLngZoom(\n                            current,\n                            16f\n                        ), 1000\n                    )\n                }\n            }\n        }\n    }\n\n    Box(\n        modifier = modifier,\n    ) {\n        Column(\n            modifier = Modifier.fillMaxSize()\n        ) {\n            MapTypeSelector(\n                currentValue = currentMapType,\n                modifier = Modifier.fillMaxWidth(),\n            ) {\n                mapProperties = mapProperties.copy(mapType = it)\n                currentMapType = it\n            }\n            GoogleMap(\n                cameraPositionState = cameraPositionState,\n                onMapLoaded = {\n                    mapLoaded = true\n                    scope.launch(Dispatchers.IO) {\n                        currentLocationIcon =\n                            context.loadBitmapDescriptor(\n                                R.drawable.ic_current_location\n                            )\n                    }\n                },\n                properties = mapProperties,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .weight(1f),\n            ) {\n                currentLocationState?.let {\n                    MarkerInfoWindowContent(\n                        state = it,\n                        icon = currentLocationIcon,\n                        anchor = Offset(0.5f, 0.5f),\n                        title = stringResource(\n                            id = R.string.current_location\n                        ),\n                    )\n                }\n            }\n        }\n\n        if (!mapLoaded) {\n            AnimatedVisibility(\n                visible = true,\n                modifier = Modifier.fillMaxSize(),\n                enter = EnterTransition.None,\n                exit = fadeOut()\n            ) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .background(MaterialTheme.colorScheme.background)\n                        .wrapContentSize()\n                )\n            }\n        }\n    }\n}\n</pre> ADDED: app/src/main/res/drawable/ic_current_location.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;shape android:shape=\"oval\"\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;size android:height=\"24dp\" android:width=\"24dp\" /&gt;\n    &lt;stroke android:color=\"@android:color/white\" android:width=\"3dp\"/&gt;\n    &lt;solid android:color=\"@color/my_location\" /&gt;\n&lt;/shape&gt;\n</pre> CHANGED: app/src/main/res/values/colors.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;color name=\"my_location\"&gt;#FF0000FF&lt;/color&gt;\n    &lt;color name=\"purple_200\"&gt;#FFBB86FC&lt;/color&gt;\n    &lt;color name=\"purple_500\"&gt;#FF6200EE&lt;/color&gt;\n    &lt;color name=\"purple_700\"&gt;#FF3700B3&lt;/color&gt;\n    &lt;color name=\"teal_200\"&gt;#FF03DAC5&lt;/color&gt;\n    &lt;color name=\"teal_700\"&gt;#FF018786&lt;/color&gt;\n    &lt;color name=\"black\"&gt;#FF000000&lt;/color&gt;\n    &lt;color name=\"white\"&gt;#FFFFFFFF&lt;/color&gt;\n&lt;/resources&gt;\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nsecrets = \"2.0.1\"\nmaps-compose = \"6.2.1\"\nlocation-services = \"21.3.0\"\nlifecycle-runtime-compose = \"2.8.7\"\ndokka = \"1.9.20\"\n\n[libraries]\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\nlifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-runtime-compose\" }\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }\ndokka = { id = \"org.jetbrains.dokka\", version.ref = \"dokka\" }\n</pre>"},{"location":"modules/google-maps/STEP_110_REPO.html","title":"Add Top Bar","text":"<p>Now we'll add a top bar that provides action buttons to</p> <ul> <li>Go to the current location</li> <li>Remember the car is parked at the current location</li> <li>Navigate using the Google Map application from the current position to the car (in walk mode)</li> <li>Forget the car location</li> </ul> <p>These actions will use icons from the Extended Icon Set, so we add its dependency and sync the project. (We'll copy the icons in the next step so we can remove the huge dependency.)</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nlifecycle-runtime-compose = \"2.8.7\"\ndokka = \"1.9.20\"\nicons-extended = \"1.7.5\"\n\n[libraries]\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended\", version.ref = \"icons-extended\" }\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\nlifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-runtime-compose\" }\n// ...\n[plugins]\n// ...</pre> show in full file  app/build.gradle.kts <pre>// ...\n\ndependencies {\n    implementation(libs.icons.extended)\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    // ...\n}\n// ...</pre> <p>We Define the top bar with the above actions calling event parameters. </p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/CarTopBar.kt <pre>// ...\nimport com.google.android.gms.maps.model.LatLng\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun CarTopBar(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    onSetCarLocation: () -&gt; Unit,\n    onGoToCurrentLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    onWalkToCar: () -&gt; Unit,\n) {\n    TopAppBar(\n        title = { Text(text = stringResource(id = R.string.app_name)) },\n        actions = {\n            currentLocation?.let {\n                IconButton(onClick = onGoToCurrentLocation) {\n                    Icon(\n                        imageVector = Icons.Filled.GpsFixed,\n                        contentDescription =\n                        stringResource(id = R.string.go_to_current_location),\n                    )\n                }\n                IconButton(onClick = onSetCarLocation) {\n                    Icon(\n                        imageVector = Icons.Filled.Star,\n                        contentDescription =\n                        stringResource(id = R.string.remember_location),\n                    )\n                }\n            }\n            carLatLng?.let {\n                IconButton(onClick = onWalkToCar) {\n                    Icon(\n                        imageVector = Icons.AutoMirrored.Filled.DirectionsWalk,\n                        contentDescription =\n                        stringResource(id = R.string.navigate),\n                    )\n                }\n                IconButton(onClick = onClearCarLocation) {\n                    Icon(\n                        imageVector = Icons.Filled.Delete,\n                        contentDescription =\n                        stringResource(id = R.string.forget_location),\n                    )\n                }\n            }\n        },\n    )\n}</pre> <p>We're going to set up a <code>Scaffold</code> for the <code>GoogleMapDisplay</code> itself, so we'll remove the one in <code>MainActivity</code> (or we'll get extra padding at the top)</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n//              Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                val cameraPositionState = rememberCameraPositionState {\n                    position = defaultCameraPosition\n                }\n\n                val currentLocation by viewModel.currentLocation.collectAsStateWithLifecycle(\n                    initialValue = null\n                )\n\n                GoogleMapDisplay(\n                    currentLocation = currentLocation,\n                    cameraPositionState = cameraPositionState,\n//                      modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    modifier = Modifier.fillMaxSize(),\n                )\n            }\n        }\n//              }\n//          }\n//      }\n//\n    }\n    // ...\n}</pre> <p>Set up a <code>Scaffold</code>, wrapping our <code>Box</code>, that will move the camera to the current location, and placeholders for the functions we're not implementing yet. </p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    }\n\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                currentLocation = currentLocation,\n                carLatLng = null,\n                onSetCarLocation = { TODO() },\n                onClearCarLocation = { TODO() },\n                onWalkToCar = { TODO() },\n                onGoToCurrentLocation = {\n                    currentLocation?.let { curr -&gt;\n                        scope.launch {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    LatLng(curr.latitude, curr.longitude),\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    } ?: Toast.makeText(\n                        context,\n                        \"No current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n            )\n        },\n        content = { paddingValues -&gt;\n            Box(\n//      modifier = modifier,\n                modifier = modifier.padding(paddingValues),\n            ) {\n                Column(\n                    // ...\n            }\n        }\n    )\n}</pre> <p>Note</p> <p>Kotlin's <code>TODO()</code> function throws an exception. Much nicer than having a TODO comment that just does nothing silently. In this case, if we tap any of the buttons that call <code>TODO()</code>, the application will crash.</p> <p>Our application now looks like</p> <p></p> <p>If we pan away from the current location and tap the location button on the Top Bar, Google Maps will animate back to the current location over one second.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n    alias(libs.plugins.dokka)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.google.google.maps\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.google.google.maps\"\n        minSdk = 24\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(libs.icons.extended)\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/google/google/maps/CarTopBar.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.location.Location\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.DirectionsWalk\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.GpsFixed\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.model.LatLng\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun CarTopBar(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    onSetCarLocation: () -&gt; Unit,\n    onGoToCurrentLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    onWalkToCar: () -&gt; Unit,\n) {\n    TopAppBar(\n        title = { Text(text = stringResource(id = R.string.app_name)) },\n        actions = {\n            currentLocation?.let {\n                IconButton(onClick = onGoToCurrentLocation) {\n                    Icon(\n                        imageVector = Icons.Filled.GpsFixed,\n                        contentDescription =\n                        stringResource(id = R.string.go_to_current_location),\n                    )\n                }\n                IconButton(onClick = onSetCarLocation) {\n                    Icon(\n                        imageVector = Icons.Filled.Star,\n                        contentDescription =\n                        stringResource(id = R.string.remember_location),\n                    )\n                }\n            }\n            carLatLng?.let {\n                IconButton(onClick = onWalkToCar) {\n                    Icon(\n                        imageVector = Icons.AutoMirrored.Filled.DirectionsWalk,\n                        contentDescription =\n                        stringResource(id = R.string.navigate),\n                    )\n                }\n                IconButton(onClick = onClearCarLocation) {\n                    Icon(\n                        imageVector = Icons.Filled.Delete,\n                        contentDescription =\n                        stringResource(id = R.string.forget_location),\n                    )\n                }\n            }\n        },\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.location.Location\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    cameraPositionState: CameraPositionState,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    val context = LocalContext.current\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n        if (mapLoaded) {\n            if (currentLocation != null) {\n                if (!initialBoundsSet) {\n                    initialBoundsSet = true\n                    val current =\n                        LatLng(currentLocation.latitude, currentLocation.longitude)\n                    cameraPositionState.animate(\n                        CameraUpdateFactory.newLatLngZoom(\n                            current,\n                            16f\n                        ), 1000\n                    )\n                }\n            }\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                currentLocation = currentLocation,\n                carLatLng = null,\n                onSetCarLocation = { TODO() },\n                onClearCarLocation = { TODO() },\n                onWalkToCar = { TODO() },\n                onGoToCurrentLocation = {\n                    currentLocation?.let { curr -&gt;\n                        scope.launch {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    LatLng(curr.latitude, curr.longitude),\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    } ?: Toast.makeText(\n                        context,\n                        \"No current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n            )\n        },\n        content = { paddingValues -&gt;\n            Box(\n//      modifier = modifier,\n                modifier = modifier.padding(paddingValues),\n            ) {\n                Column(\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    MapTypeSelector(\n                        currentValue = currentMapType,\n                        modifier = Modifier.fillMaxWidth(),\n                    ) {\n                        mapProperties = mapProperties.copy(mapType = it)\n                        currentMapType = it\n                    }\n                    GoogleMap(\n                        cameraPositionState = cameraPositionState,\n                        onMapLoaded = {\n                            mapLoaded = true\n                            scope.launch(Dispatchers.IO) {\n                                currentLocationIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_current_location\n                                    )\n                            }\n                        },\n                        properties = mapProperties,\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .weight(1f),\n                    ) {\n                        currentLocationState?.let {\n                            MarkerInfoWindowContent(\n                                state = it,\n                                icon = currentLocationIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.current_location\n                                ),\n                            )\n                        }\n                    }\n                }\n\n                if (!mapLoaded) {\n                    AnimatedVisibility(\n                        visible = true,\n                        modifier = Modifier.fillMaxSize(),\n                        enter = EnterTransition.None,\n                        exit = fadeOut()\n                    ) {\n                        CircularProgressIndicator(\n                            modifier = Modifier\n                                .background(MaterialTheme.colorScheme.background)\n                                .wrapContentSize()\n                        )\n                    }\n                }\n            }\n        }\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.annotation.SuppressLint\nimport android.app.AlertDialog\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Bundle\nimport android.os.Looper\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.core.app.ActivityCompat\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.android.gms.common.GoogleApiAvailability\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.LocationServices\nimport com.google.android.gms.location.Priority\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.rememberCameraPositionState\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel: CarViewModel by viewModels()\n\n    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient\n    private val locationCallback = object : LocationCallback() {\n        override fun onLocationResult(locationResult: LocationResult) {\n            viewModel.updateLocation(locationResult.lastLocation)\n        }\n    }\n\n    private val getLocationPermission =\n        registerForActivityResult(\n            ActivityResultContracts.RequestMultiplePermissions()\n        ) { isGranted -&gt;\n            if (isGranted.values.any { it }) {\n                startLocationAndMap()\n            } else {\n                // if the user denied permissions, tell them they\n                //   cannot use the app without them. In general,\n                //   you should try to just reduce function and let the\n                //   user continue, but location is a key part of this\n                //   application.\n                //   (Note that a real version of this application\n                //   might allow the user to manually click on the map\n                //   to set their current location, and we wouldn't\n                //   show this dialog, or perhaps only show it once)\n                // NOTE: This is a normal Android-View-based dialog, not a compose one!\n                AlertDialog.Builder(this)\n                    .setTitle(\"Permissions Needed\")\n                    .setMessage(\n                        \"We need coarse-location or fine-location permission \" +\n                                \"to locate a car (fine location is highly \" +\n                                \"recommended for accurate car locating). \" +\n                                \"Please allow these permissions via App Info \" +\n                                \"settings\")\n                    .setCancelable(false)\n                    .setNegativeButton(\"Quit\") { _, _ -&gt; finish() }\n                    .setPositiveButton(\"App Info\") { _, _ -&gt;\n                        startActivity(\n                            Intent(\n                                Settings.ACTION_APPLICATION_DETAILS_SETTINGS\n                            ).apply {\n                                data = Uri.parse(\"package:$packageName\")\n                            }\n                        )\n                        finish()\n                    }\n                    .show()\n            }\n        }\n\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        val locationRequest =\n            LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n                .setWaitForAccurateLocation(false)\n                .setMinUpdateIntervalMillis(0)\n                .setMaxUpdateDelayMillis(5000)\n                .build()\n        fusedLocationProviderClient =\n            LocationServices.getFusedLocationProviderClient(this)\n        fusedLocationProviderClient.requestLocationUpdates(\n            locationRequest,\n            locationCallback,\n            Looper.getMainLooper()\n        )\n\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n//              Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                val cameraPositionState = rememberCameraPositionState {\n                    position = defaultCameraPosition\n                }\n\n                val currentLocation by viewModel.currentLocation.collectAsStateWithLifecycle(\n                    initialValue = null\n                )\n\n                GoogleMapDisplay(\n                    currentLocation = currentLocation,\n                    cameraPositionState = cameraPositionState,\n//                      modifier = Modifier.padding(innerPadding).fillMaxSize(),\n                    modifier = Modifier.fillMaxSize(),\n                )\n            }\n        }\n//              }\n//          }\n//      }\n//\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        GoogleApiAvailability.getInstance()\n            .makeGooglePlayServicesAvailable(this)\n            .addOnSuccessListener {\n                if (ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_FINE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED &amp;&amp;\n                    ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_COARSE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    getLocationPermission.launch(\n                        arrayOf(\n                            android.Manifest.permission.ACCESS_FINE_LOCATION,\n                            android.Manifest.permission.ACCESS_COARSE_LOCATION,\n                        )\n                    )\n                } else {\n                    startLocationAndMap()\n                }\n            }.addOnFailureListener(this) {\n                Toast.makeText(\n                    this,\n                    \"Google Play services required (or upgrade required)\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                finish()\n            }\n//\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Google Maps&lt;/string&gt;\n    &lt;string name=\"map_type\"&gt;Map Type&lt;/string&gt;\n    &lt;string name=\"current_location\"&gt;Current Location&lt;/string&gt;\n    &lt;string name=\"go_to_current_location\"&gt;Go to current location&lt;/string&gt;\n    &lt;string name=\"remember_location\"&gt;Remember Location&lt;/string&gt;\n    &lt;string name=\"navigate\"&gt;Walk to Car&lt;/string&gt;\n    &lt;string name=\"forget_location\"&gt;Forget Location&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nsecrets = \"2.0.1\"\nmaps-compose = \"6.2.1\"\nlocation-services = \"21.3.0\"\nlifecycle-runtime-compose = \"2.8.7\"\ndokka = \"1.9.20\"\nicons-extended = \"1.7.5\"\n\n[libraries]\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended\", version.ref = \"icons-extended\" }\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\nlifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-runtime-compose\" }\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }\ndokka = { id = \"org.jetbrains.dokka\", version.ref = \"dokka\" }\n</pre>"},{"location":"modules/google-maps/STEP_120_REPO.html","title":"Copy Icons","text":"<p>To keep our application size and build-time reasonable, we never want to include the full extended icon set. We'll copy the icons that we don't have.</p> <p>We'll do this the same way we did for the Movie example. Copy the <code>DirectionsWalk</code> and <code>GpsFixed</code> icons, then comment out the extended icon dependency.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n    alias(libs.plugins.dokka)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.google.google.maps\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.google.google.maps\"\n        minSdk = 24\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n//  implementation(libs.icons.extended)\n//    implementation(libs.icons.extended)\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}\n</pre> ADDED: app/src/main/java/androidx/compose/material/icons/automirrored/filled/DirectionsWalk.kt <pre>/*\n * Copyright 2024 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage androidx.compose.material.icons.automirrored.filled\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.materialIcon\nimport androidx.compose.material.icons.materialPath\nimport androidx.compose.ui.graphics.vector.ImageVector\n\npublic val Icons.AutoMirrored.Filled.DirectionsWalk: ImageVector\n    get() {\n        if (_directionsWalk != null) {\n            return _directionsWalk!!\n        }\n        _directionsWalk = materialIcon(name = \"AutoMirrored.Filled.DirectionsWalk\", autoMirror =\n        true) {\n            materialPath {\n                moveTo(13.5f, 5.5f)\n                curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f)\n                reflectiveCurveToRelative(-0.9f, -2.0f, -2.0f, -2.0f)\n                reflectiveCurveToRelative(-2.0f, 0.9f, -2.0f, 2.0f)\n                reflectiveCurveToRelative(0.9f, 2.0f, 2.0f, 2.0f)\n                close()\n                moveTo(9.8f, 8.9f)\n                lineTo(7.0f, 23.0f)\n                horizontalLineToRelative(2.1f)\n                lineToRelative(1.8f, -8.0f)\n                lineToRelative(2.1f, 2.0f)\n                verticalLineToRelative(6.0f)\n                horizontalLineToRelative(2.0f)\n                verticalLineToRelative(-7.5f)\n                lineToRelative(-2.1f, -2.0f)\n                lineToRelative(0.6f, -3.0f)\n                curveTo(14.8f, 12.0f, 16.8f, 13.0f, 19.0f, 13.0f)\n                verticalLineToRelative(-2.0f)\n                curveToRelative(-1.9f, 0.0f, -3.5f, -1.0f, -4.3f, -2.4f)\n                lineToRelative(-1.0f, -1.6f)\n                curveToRelative(-0.4f, -0.6f, -1.0f, -1.0f, -1.7f, -1.0f)\n                curveToRelative(-0.3f, 0.0f, -0.5f, 0.1f, -0.8f, 0.1f)\n                lineTo(6.0f, 8.3f)\n                verticalLineTo(13.0f)\n                horizontalLineToRelative(2.0f)\n                verticalLineTo(9.6f)\n                lineToRelative(1.8f, -0.7f)\n            }\n        }\n        return _directionsWalk!!\n    }\n\nprivate var _directionsWalk: ImageVector? = null\n</pre> ADDED: app/src/main/java/androidx/compose/material/icons/filled/GpsFixed.kt <pre>/*\n * Copyright 2024 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage androidx.compose.material.icons.filled\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.materialIcon\nimport androidx.compose.material.icons.materialPath\nimport androidx.compose.ui.graphics.vector.ImageVector\n\npublic val Icons.Filled.GpsFixed: ImageVector\n    get() {\n        if (_gpsFixed != null) {\n            return _gpsFixed!!\n        }\n        _gpsFixed = materialIcon(name = \"Filled.GpsFixed\") {\n            materialPath {\n                moveTo(12.0f, 8.0f)\n                curveToRelative(-2.21f, 0.0f, -4.0f, 1.79f, -4.0f, 4.0f)\n                reflectiveCurveToRelative(1.79f, 4.0f, 4.0f, 4.0f)\n                reflectiveCurveToRelative(4.0f, -1.79f, 4.0f, -4.0f)\n                reflectiveCurveToRelative(-1.79f, -4.0f, -4.0f, -4.0f)\n                close()\n                moveTo(20.94f, 11.0f)\n                curveToRelative(-0.46f, -4.17f, -3.77f, -7.48f, -7.94f, -7.94f)\n                lineTo(13.0f, 1.0f)\n                horizontalLineToRelative(-2.0f)\n                verticalLineToRelative(2.06f)\n                curveTo(6.83f, 3.52f, 3.52f, 6.83f, 3.06f, 11.0f)\n                lineTo(1.0f, 11.0f)\n                verticalLineToRelative(2.0f)\n                horizontalLineToRelative(2.06f)\n                curveToRelative(0.46f, 4.17f, 3.77f, 7.48f, 7.94f, 7.94f)\n                lineTo(11.0f, 23.0f)\n                horizontalLineToRelative(2.0f)\n                verticalLineToRelative(-2.06f)\n                curveToRelative(4.17f, -0.46f, 7.48f, -3.77f, 7.94f, -7.94f)\n                lineTo(23.0f, 13.0f)\n                verticalLineToRelative(-2.0f)\n                horizontalLineToRelative(-2.06f)\n                close()\n                moveTo(12.0f, 19.0f)\n                curveToRelative(-3.87f, 0.0f, -7.0f, -3.13f, -7.0f, -7.0f)\n                reflectiveCurveToRelative(3.13f, -7.0f, 7.0f, -7.0f)\n                reflectiveCurveToRelative(7.0f, 3.13f, 7.0f, 7.0f)\n                reflectiveCurveToRelative(-3.13f, 7.0f, -7.0f, 7.0f)\n                close()\n            }\n        }\n        return _gpsFixed!!\n    }\n\nprivate var _gpsFixed: ImageVector? = null\n</pre>"},{"location":"modules/google-maps/STEP_130_REPO.html","title":"Manage Car Location","text":"<p>We need to keep track of our car across application runs. To do this, we'll use a Preferences Datastore to store the latitude and longitude of the car.</p> <p>The Datastore API exposes the data from the preference as a Kotlin <code>Flow</code>; whenever the preference is updated, the new value is emitted. We'll expose the car location to the UI from the view model, allowing new values to be collected. The preferences data store is a simple file that stores values. This is useful when a database would be overkill for storing small amounts of data. The datastore is typically used to hold simple application state across application runs.</p> <p>We start by Adding the Datastore Dependency.</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\ndokka = \"1.9.20\"\nicons-extended = \"1.7.5\"\ndatastore-preferences = \"1.1.1\"\n\n[libraries]\ndatastore-preferences = { group = \"androidx.datastore\", name = \"datastore-preferences\", version.ref = \"datastore-preferences\" }\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended\", version.ref = \"icons-extended\" }\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\n// ...\n[plugins]\n// ...</pre> show in full file  app/build.gradle.kts <pre>// ...\n\ndependencies {\n    implementation(libs.datastore.preferences)\n//    implementation(libs.icons.extended)\n    implementation(libs.location.services)\n    // ...\n}\n// ...</pre> <p>Then we can store and load the car's location.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/CarViewModel.kt <pre>// ...\nclass CarViewModel(application: Application) : AndroidViewModel(application) {\n    // ...\n    }\n\n    private val Context.preferencesDataStore:\n            DataStore&lt;Preferences&gt; by preferencesDataStore(name = \"carfinder\")\n    val carLatLng = application.preferencesDataStore.data.map { preferences -&gt;\n        preferences[LAT_PREF]?.let { latString -&gt;\n            preferences[LON_PREF]?.let { lonString -&gt;\n                LatLng(latString.toDouble(), lonString.toDouble())\n            }\n        }\n    }\n    fun clearCarLocation() {\n        viewModelScope.launch {\n            getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                preferences.remove(LAT_PREF)\n                preferences.remove(LON_PREF)\n            }\n        }\n    }\n    fun setCarLocation() {\n        viewModelScope.launch {\n            _currentLocation.value?.let { location -&gt;\n                getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                    preferences[LAT_PREF] = location.latitude.toString()\n                    preferences[LON_PREF] = location.longitude.toString()\n                }\n            } ?: run {\n                clearCarLocation()\n            }\n        }\n    }\n}</pre> <ul> <li><code>carLatLng</code> is a <code>Flow</code> created by mapping the data store's <code>Flow</code> into a <code>LatLng</code> instance.      If either latitude or longitude are missing, a <code>null</code> is emitted.</li> <li><code>clearCarLocation</code> removes the latitude and longitude from the data store.</li> <li><code>setCarLocation</code> stores the current location's latitude and longitude in datastore (or removes      them if there is no current location)</li> </ul> <p>When <code>clearCarLocation</code> or <code>setCarLocation</code> change the latitude/longitude in the data store, new data is emitted to the data store <code>Flow</code>, which will trigger the <code>carLatLng</code> to emit a new <code>LatLng</code> or null.</p> <p>We'll need a new icon for the Car. I found a nice free car Marker, made by Vectors Market https://www.flaticon.com/authors/vectors-market from https://www.flaticon.com.</p> show in full file  app/src/main/res/drawable/ic_car.xml <pre>&lt;!--\nCar icon made by Vectors Market (https://www.flaticon.com/authors/vectors-market) from https://www.flaticon.com\n--&gt;\n&lt;vector android:height=\"48dp\" android:viewportHeight=\"496.474\"\n    android:viewportWidth=\"496.474\" android:width=\"48dp\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;path android:fillColor=\"#E95353\" android:pathData=\"M489.544,269.628c-0.729,-14.739 -6.206,-28.858 -15.205,-40.572c-20.294,-26.422 -24.25,-47.399 -24.25,-47.399c-15.934,-41.751 -30.099,-69.57 -40.51,-87.226c-10.954,-18.541 -29.898,-31.03 -51.262,-33.776c-42.961,-5.554 -177.23,-5.554 -220.191,0c-21.349,2.762 -40.293,15.251 -51.247,33.776c-10.411,17.656 -24.56,45.475 -40.51,87.226c0,0 -3.956,20.977 -24.25,47.399c-8.983,11.714 -14.476,25.833 -15.189,40.572c-1.536,31.977 7.727,39.005 16.012,111.368c0.652,5.694 5.461,9.976 11.202,9.976h428.203c5.741,0 10.55,-4.298 11.202,-9.976c2.327,-20.294 9.232,-61.456 9.232,-61.456C488.83,299.076 490.149,282.397 489.544,269.628z\"/&gt;\n    &lt;path android:fillColor=\"#168DE2\" android:pathData=\"M441.074,179.982c-12.567,-31.449 -25.383,-58.911 -38.136,-80.803c-9.666,-16.555 -26.717,-28.113 -45.583,-30.642c-43.055,-5.71 -175.476,-5.663 -218.221,0c-18.866,2.529 -35.918,14.088 -45.584,30.642c-12.924,22.171 -25.91,50.005 -38.291,80.803C183.662,190.082 312.655,190.082 441.074,179.982z\"/&gt;\n    &lt;path android:fillColor=\"#FFFFFF\" android:pathData=\"M422.844,216.349c-4.903,1.536 -9.464,3.693 -13.281,5.834c-6.951,3.879 -14.088,7.494 -21.535,10.318c-12.35,4.686 -14.445,11.683 -14.445,11.683c-0.372,0.481 -0.729,0.962 -1.071,1.458c-9.371,13.917 2.932,32.442 19.549,30.084c24.033,-3.398 43.83,-10.364 53.884,-14.398c5.756,-2.312 10.255,-7.121 11.729,-13.157c0.14,-0.574 0.264,-1.148 0.372,-1.707C461.74,226.543 442.191,210.314 422.844,216.349z\"/&gt;\n    &lt;path android:fillColor=\"#FFE21F\" android:pathData=\"M448.522,327.857h-26.733c-4.018,0 -6.035,4.856 -3.196,7.711l26.733,26.733c2.839,2.839 7.711,0.822 7.711,-3.196v-26.733C453.036,329.874 451.019,327.857 448.522,327.857z\"/&gt;\n    &lt;path android:fillColor=\"#454545\" android:pathData=\"M473.547,380.965c-0.652,5.71 -5.477,10.007 -11.217,10.007h-51.433v29.851c0,10.566 8.564,19.146 19.146,19.146h32.303c10.566,0 19.146,-8.564 19.146,-19.146v-93.448C479.366,340.315 475.239,366.179 473.547,380.965z\"/&gt;\n    &lt;path android:fillColor=\"#ED6262\" android:pathData=\"M496.107,159.083c-1.552,-6.951 -8.083,-11.667 -15.205,-11.667h-12.909c-8.27,0 -14.972,6.703 -14.972,14.972v9.2h-6.842l3.925,9.325h15.05c7.789,0 15.5,-1.676 22.575,-4.918C494.105,173.078 497.674,166.096 496.107,159.083z\"/&gt;\n    &lt;path android:fillColor=\"#FFBD49\" android:pathData=\"M431.315,240.46m-18.82,0a18.82,18.82 0,1 1,37.64 0a18.82,18.82 0,1 1,-37.64 0\"/&gt;\n    &lt;path android:fillColor=\"#FFDB6F\" android:pathData=\"M393.458,255.308m-13.824,0a13.824,13.824 0,1 1,27.648 0a13.824,13.824 0,1 1,-27.648 0\"/&gt;\n    &lt;path android:fillColor=\"#6F6F6F\" android:pathData=\"M357.634,255.324l-21.613,37.639l-175.569,0l-21.613,-37.639z\"/&gt;\n    &lt;path android:fillColor=\"#FFFFFF\" android:pathData=\"M123.945,245.642c-0.326,-0.496 -0.683,-0.977 -1.071,-1.458c0,0 -2.095,-6.997 -14.445,-11.683c-7.447,-2.824 -14.569,-6.439 -21.535,-10.318c-3.832,-2.141 -8.378,-4.298 -13.281,-5.834c-19.332,-6.051 -38.896,10.193 -35.219,30.115c0.109,0.574 0.233,1.133 0.357,1.707c1.474,6.035 5.973,10.845 11.729,13.157c10.054,4.034 29.851,11 53.9,14.398C121.012,278.084 133.316,259.559 123.945,245.642z\"/&gt;\n    &lt;path android:fillColor=\"#FFE21F\" android:pathData=\"M74.684,327.857H47.951c-2.498,0 -4.515,2.017 -4.515,4.515v26.733c0,4.018 4.872,6.035 7.711,3.196l26.733,-26.733C80.719,332.729 78.702,327.857 74.684,327.857z\"/&gt;\n    &lt;path android:fillColor=\"#777777\" android:pathData=\"M426.226,374.511c-27.834,-48.159 -59.842,-46.654 -59.842,-46.654H130.073c0,0 -31.992,-1.505 -59.842,46.654H22.119l0.59,6.206c0.543,5.834 5.415,10.256 11.248,10.256h428.56c5.834,0 10.705,-4.422 11.249,-10.255l0.59,-6.206L426.226,374.511L426.226,374.511z\"/&gt;\n    &lt;path android:fillColor=\"#454545\" android:pathData=\"M34.143,390.988c-5.741,0 -10.566,-4.313 -11.217,-10.007c-1.691,-14.786 -5.834,-40.665 -7.944,-53.589v93.448c0,10.566 8.564,19.146 19.146,19.146H66.43c10.566,0 19.146,-8.564 19.146,-19.146v-29.851H34.143z\"/&gt;\n    &lt;path android:fillColor=\"#ED6262\" android:pathData=\"M43.436,171.588v-9.2c0,-8.27 -6.703,-14.972 -14.957,-14.972H15.571c-7.121,0 -13.653,4.717 -15.205,11.667c-1.567,6.997 2.017,13.995 8.378,16.896c7.09,3.243 14.786,4.918 22.575,4.918h15.05l3.925,-9.325h-6.858V171.588z\"/&gt;\n    &lt;path android:fillColor=\"#FFBD49\" android:pathData=\"M65.142,240.46m-18.82,0a18.82,18.82 0,1 1,37.64 0a18.82,18.82 0,1 1,-37.64 0\"/&gt;\n    &lt;path android:fillColor=\"#FFDB6F\" android:pathData=\"M103.03,255.308m-13.824,0a13.824,13.824 0,1 1,27.648 0a13.824,13.824 0,1 1,-27.648 0\"/&gt;\n    &lt;path android:fillColor=\"#6F6F6F\" android:pathData=\"M348.294,341.029H148.179c-3.134,0 -5.663,2.544 -5.663,5.663c0,3.134 2.529,5.663 5.663,5.663h200.099c3.134,0 5.663,-2.544 5.663,-5.663C353.957,343.558 351.412,341.029 348.294,341.029z\"/&gt;\n    &lt;path android:fillColor=\"#6F6F6F\" android:pathData=\"M348.294,363.635H148.179c-3.134,0 -5.663,2.544 -5.663,5.663c0,3.134 2.529,5.663 5.663,5.663h200.099c3.134,0 5.663,-2.544 5.663,-5.663C353.957,366.164 351.412,363.635 348.294,363.635z\"/&gt;\n    &lt;path android:fillColor=\"#3AA2EB\" android:pathData=\"M420.098,132.009v1.939c0,7.804 -6.408,14.057 -14.367,13.731c-7.339,-0.465 -12.955,-7.028 -12.955,-14.522v-27.834c0,-6.563 -5.461,-11.559 -12.024,-11.388c-0.155,0 -0.155,0 -0.31,0c0,0 0,0 -0.155,0c-6.563,-0.155 -12.024,4.841 -12.024,11.388v25.181c0,7.804 -6.718,14.057 -14.522,13.576c-7.339,-0.31 -12.955,-7.028 -12.955,-14.367v-21.892c0,-6.563 -5.461,-12.024 -12.179,-12.024h-0.931c-6.253,0 -11.404,5.151 -11.404,11.404v28.47c0,7.804 -6.563,14.041 -14.522,13.731c-7.339,-0.465 -12.8,-7.028 -12.8,-14.522V96.712c0,-6.082 -5.306,-11.233 -11.559,-10.768h-0.931c-6.408,0 -11.543,5.151 -11.543,11.404v39.021c0,7.494 -6.082,13.731 -13.731,13.731c-7.339,0 -13.421,-5.927 -13.576,-13.265v-32.752c0,-7.494 -5.616,-14.041 -12.955,-14.522c-7.959,-0.31 -14.367,5.927 -14.367,13.731l-0.155,30.255c0,7.804 -6.392,14.041 -14.367,13.731c-7.199,-0.45 -12.66,-6.78 -12.878,-13.948V97.829c0,-7.37 -5.539,-13.964 -12.909,-14.398c-7.897,-0.341 -14.414,5.88 -14.414,13.7v37.19c-0.217,7.618 -6.609,13.684 -14.445,13.374c-7.339,-0.465 -12.8,-7.028 -12.8,-14.522v-27.85c0,-6.563 -5.616,-11.559 -12.179,-11.388c-0.155,0 -0.155,0 -0.155,0c-0.155,0 -0.155,0 -0.155,0c-6.718,-0.155 -12.179,4.841 -12.179,11.388v25.181c0,7.804 -6.563,14.057 -14.367,13.576c-6.796,-0.264 -11.854,-5.942 -12.722,-12.521c-7.215,14.941 -14.367,31.123 -21.318,48.407c128.403,10.116 257.412,10.116 385.815,0C434.139,162.636 427.126,146.655 420.098,132.009z\"/&gt;\n&lt;/vector&gt;</pre> <p>To use these in the map, we add some new parameters, set up some state, pass the state and management functions to the top bar, load the icon as we did the location icon, and display the car marker on the map</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    cameraPositionState: CameraPositionState,\n    onSetCarLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    modifier: Modifier,\n) {\n    // ...\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val carState = rememberMarkerState(\"car\")\n    var carIcon by remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    // ...\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                currentLocation = currentLocation,\n//              carLatLng = null,\n//              onSetCarLocation = { TODO() },\n//              onClearCarLocation = { TODO() },\n                carLatLng = carLatLng,\n                onSetCarLocation = onSetCarLocation,\n                onClearCarLocation = onClearCarLocation,\n                onWalkToCar = { TODO() },\n                onGoToCurrentLocation = {\n                    // ...\n            )\n        },\n        content = { paddingValues -&gt;\n            Box(\n                // ...\n            ) {\n                Column(\n                    // ...\n                ) {\n                    // ...\n                    GoogleMap(\n                        // ...\n                        onMapLoaded = {\n                            // ...\n                            scope.launch(Dispatchers.IO) {\n                                // ...\n                                        R.drawable.ic_current_location\n                                    )\n                                carIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_car\n                                    )\n                            }\n                        },\n                        // ...\n                    ) {\n                        // ...\n                            )\n                        }\n                        carLatLng?.let {\n                            carState.position = it\n                            MarkerInfoWindowContent(\n                                state = carState,\n                                icon = carIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.car_location\n                                ),\n                            )\n                        }\n                    }\n                }\n                // ...\n            }\n        }\n    )\n}</pre> <p>Finally, we collect and pass the location and management functions to the <code>GoogleMapDisplay</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n                // ...\n                GoogleMapDisplay(\n                    currentLocation = currentLocation,\n                    carLatLng = carLatLng,\n                    cameraPositionState = cameraPositionState,\n                    onSetCarLocation = viewModel::setCarLocation,\n                    onClearCarLocation = viewModel::clearCarLocation,\n                    modifier = Modifier.fillMaxSize(),\n                )\n            }\n        }\n    }\n    // ...\n}</pre> <p>When we run the application, we can press the star icon to save the current location as the car's location. This will cause the car icon to be added to the map.</p> <p>The location is saved in the preferences datastore, so if you close and reopen the app, the location will appear again.</p> <p>Pressing the trash can will remove the location from the datastore, causing the icon to be removed.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.secrets)\n    alias(libs.plugins.dokka)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.google.google.maps\"\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.google.google.maps\"\n        minSdk = 24\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(libs.datastore.preferences)\n//    implementation(libs.icons.extended)\n    implementation(libs.location.services)\n    implementation(libs.lifecycle.runtime.compose)\n    implementation(libs.maps.compose)\n    implementation(libs.maps.compose.utils)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n\nsecrets {\n    propertiesFileName = \"secrets.properties\"\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/CarViewModel.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.app.Application\nimport android.content.Context\nimport android.location.Location\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\nimport androidx.datastore.preferences.core.edit\nimport androidx.datastore.preferences.core.stringPreferencesKey\nimport androidx.datastore.preferences.preferencesDataStore\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.google.android.gms.maps.model.LatLng\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.launch\n\nclass CarViewModel(application: Application) : AndroidViewModel(application) {\n    private val LAT_PREF = stringPreferencesKey(\"lat\")\n    private val LON_PREF = stringPreferencesKey(\"lon\")\n\n    private val _currentLocation = MutableStateFlow&lt;Location?&gt;(null)\n\n    val currentLocation: Flow&lt;Location?&gt;\n        get() = _currentLocation\n\n    fun updateLocation(location: Location?) {\n        _currentLocation.value = location\n    }\n\n    private val Context.preferencesDataStore:\n            DataStore&lt;Preferences&gt; by preferencesDataStore(name = \"carfinder\")\n    val carLatLng = application.preferencesDataStore.data.map { preferences -&gt;\n        preferences[LAT_PREF]?.let { latString -&gt;\n            preferences[LON_PREF]?.let { lonString -&gt;\n                LatLng(latString.toDouble(), lonString.toDouble())\n            }\n        }\n    }\n    fun clearCarLocation() {\n        viewModelScope.launch {\n            getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                preferences.remove(LAT_PREF)\n                preferences.remove(LON_PREF)\n            }\n        }\n    }\n    fun setCarLocation() {\n        viewModelScope.launch {\n            _currentLocation.value?.let { location -&gt;\n                getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                    preferences[LAT_PREF] = location.latitude.toString()\n                    preferences[LON_PREF] = location.longitude.toString()\n                }\n            } ?: run {\n                clearCarLocation()\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.location.Location\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    cameraPositionState: CameraPositionState,\n    onSetCarLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    val context = LocalContext.current\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val carState = rememberMarkerState(\"car\")\n    var carIcon by remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n        if (mapLoaded) {\n            if (currentLocation != null) {\n                if (!initialBoundsSet) {\n                    initialBoundsSet = true\n                    val current =\n                        LatLng(currentLocation.latitude, currentLocation.longitude)\n                    cameraPositionState.animate(\n                        CameraUpdateFactory.newLatLngZoom(\n                            current,\n                            16f\n                        ), 1000\n                    )\n                }\n            }\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                currentLocation = currentLocation,\n//              carLatLng = null,\n//              onSetCarLocation = { TODO() },\n//              onClearCarLocation = { TODO() },\n                carLatLng = carLatLng,\n                onSetCarLocation = onSetCarLocation,\n                onClearCarLocation = onClearCarLocation,\n                onWalkToCar = { TODO() },\n                onGoToCurrentLocation = {\n                    currentLocation?.let { curr -&gt;\n                        scope.launch {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    LatLng(curr.latitude, curr.longitude),\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    } ?: Toast.makeText(\n                        context,\n                        \"No current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n            )\n        },\n        content = { paddingValues -&gt;\n            Box(\n                modifier = modifier.padding(paddingValues),\n            ) {\n                Column(\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    MapTypeSelector(\n                        currentValue = currentMapType,\n                        modifier = Modifier.fillMaxWidth(),\n                    ) {\n                        mapProperties = mapProperties.copy(mapType = it)\n                        currentMapType = it\n                    }\n                    GoogleMap(\n                        cameraPositionState = cameraPositionState,\n                        onMapLoaded = {\n                            mapLoaded = true\n                            scope.launch(Dispatchers.IO) {\n                                currentLocationIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_current_location\n                                    )\n                                carIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_car\n                                    )\n                            }\n                        },\n                        properties = mapProperties,\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .weight(1f),\n                    ) {\n                        currentLocationState?.let {\n                            MarkerInfoWindowContent(\n                                state = it,\n                                icon = currentLocationIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.current_location\n                                ),\n                            )\n                        }\n                        carLatLng?.let {\n                            carState.position = it\n                            MarkerInfoWindowContent(\n                                state = carState,\n                                icon = carIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.car_location\n                                ),\n                            )\n                        }\n                    }\n                }\n\n                if (!mapLoaded) {\n                    AnimatedVisibility(\n                        visible = true,\n                        modifier = Modifier.fillMaxSize(),\n                        enter = EnterTransition.None,\n                        exit = fadeOut()\n                    ) {\n                        CircularProgressIndicator(\n                            modifier = Modifier\n                                .background(MaterialTheme.colorScheme.background)\n                                .wrapContentSize()\n                        )\n                    }\n                }\n            }\n        }\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.annotation.SuppressLint\nimport android.app.AlertDialog\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Bundle\nimport android.os.Looper\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.core.app.ActivityCompat\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.android.gms.common.GoogleApiAvailability\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.LocationServices\nimport com.google.android.gms.location.Priority\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.rememberCameraPositionState\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel: CarViewModel by viewModels()\n\n    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient\n    private val locationCallback = object : LocationCallback() {\n        override fun onLocationResult(locationResult: LocationResult) {\n            viewModel.updateLocation(locationResult.lastLocation)\n        }\n    }\n\n    private val getLocationPermission =\n        registerForActivityResult(\n            ActivityResultContracts.RequestMultiplePermissions()\n        ) { isGranted -&gt;\n            if (isGranted.values.any { it }) {\n                startLocationAndMap()\n            } else {\n                // if the user denied permissions, tell them they\n                //   cannot use the app without them. In general,\n                //   you should try to just reduce function and let the\n                //   user continue, but location is a key part of this\n                //   application.\n                //   (Note that a real version of this application\n                //   might allow the user to manually click on the map\n                //   to set their current location, and we wouldn't\n                //   show this dialog, or perhaps only show it once)\n                // NOTE: This is a normal Android-View-based dialog, not a compose one!\n                AlertDialog.Builder(this)\n                    .setTitle(\"Permissions Needed\")\n                    .setMessage(\n                        \"We need coarse-location or fine-location permission \" +\n                                \"to locate a car (fine location is highly \" +\n                                \"recommended for accurate car locating). \" +\n                                \"Please allow these permissions via App Info \" +\n                                \"settings\")\n                    .setCancelable(false)\n                    .setNegativeButton(\"Quit\") { _, _ -&gt; finish() }\n                    .setPositiveButton(\"App Info\") { _, _ -&gt;\n                        startActivity(\n                            Intent(\n                                Settings.ACTION_APPLICATION_DETAILS_SETTINGS\n                            ).apply {\n                                data = Uri.parse(\"package:$packageName\")\n                            }\n                        )\n                        finish()\n                    }\n                    .show()\n            }\n        }\n\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        val locationRequest =\n            LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n                .setWaitForAccurateLocation(false)\n                .setMinUpdateIntervalMillis(0)\n                .setMaxUpdateDelayMillis(5000)\n                .build()\n        fusedLocationProviderClient =\n            LocationServices.getFusedLocationProviderClient(this)\n        fusedLocationProviderClient.requestLocationUpdates(\n            locationRequest,\n            locationCallback,\n            Looper.getMainLooper()\n        )\n\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n                val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                val cameraPositionState = rememberCameraPositionState {\n                    position = defaultCameraPosition\n                }\n\n                val currentLocation by viewModel.currentLocation.collectAsStateWithLifecycle(\n                    initialValue = null\n                )\n\n                val carLatLng by\n                    viewModel.carLatLng.collectAsStateWithLifecycle(initialValue = null)\n\n                GoogleMapDisplay(\n                    currentLocation = currentLocation,\n                    carLatLng = carLatLng,\n                    cameraPositionState = cameraPositionState,\n                    onSetCarLocation = viewModel::setCarLocation,\n                    onClearCarLocation = viewModel::clearCarLocation,\n                    modifier = Modifier.fillMaxSize(),\n                )\n            }\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        GoogleApiAvailability.getInstance()\n            .makeGooglePlayServicesAvailable(this)\n            .addOnSuccessListener {\n                if (ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_FINE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED &amp;&amp;\n                    ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_COARSE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    getLocationPermission.launch(\n                        arrayOf(\n                            android.Manifest.permission.ACCESS_FINE_LOCATION,\n                            android.Manifest.permission.ACCESS_COARSE_LOCATION,\n                        )\n                    )\n                } else {\n                    startLocationAndMap()\n                }\n            }.addOnFailureListener(this) {\n                Toast.makeText(\n                    this,\n                    \"Google Play services required (or upgrade required)\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                finish()\n            }\n    }\n}\n</pre> ADDED: app/src/main/res/drawable/ic_car.xml <pre>&lt;!--\nCar icon made by Vectors Market (https://www.flaticon.com/authors/vectors-market) from https://www.flaticon.com\n--&gt;\n&lt;vector android:height=\"48dp\" android:viewportHeight=\"496.474\"\n    android:viewportWidth=\"496.474\" android:width=\"48dp\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n    &lt;path android:fillColor=\"#E95353\" android:pathData=\"M489.544,269.628c-0.729,-14.739 -6.206,-28.858 -15.205,-40.572c-20.294,-26.422 -24.25,-47.399 -24.25,-47.399c-15.934,-41.751 -30.099,-69.57 -40.51,-87.226c-10.954,-18.541 -29.898,-31.03 -51.262,-33.776c-42.961,-5.554 -177.23,-5.554 -220.191,0c-21.349,2.762 -40.293,15.251 -51.247,33.776c-10.411,17.656 -24.56,45.475 -40.51,87.226c0,0 -3.956,20.977 -24.25,47.399c-8.983,11.714 -14.476,25.833 -15.189,40.572c-1.536,31.977 7.727,39.005 16.012,111.368c0.652,5.694 5.461,9.976 11.202,9.976h428.203c5.741,0 10.55,-4.298 11.202,-9.976c2.327,-20.294 9.232,-61.456 9.232,-61.456C488.83,299.076 490.149,282.397 489.544,269.628z\"/&gt;\n    &lt;path android:fillColor=\"#168DE2\" android:pathData=\"M441.074,179.982c-12.567,-31.449 -25.383,-58.911 -38.136,-80.803c-9.666,-16.555 -26.717,-28.113 -45.583,-30.642c-43.055,-5.71 -175.476,-5.663 -218.221,0c-18.866,2.529 -35.918,14.088 -45.584,30.642c-12.924,22.171 -25.91,50.005 -38.291,80.803C183.662,190.082 312.655,190.082 441.074,179.982z\"/&gt;\n    &lt;path android:fillColor=\"#FFFFFF\" android:pathData=\"M422.844,216.349c-4.903,1.536 -9.464,3.693 -13.281,5.834c-6.951,3.879 -14.088,7.494 -21.535,10.318c-12.35,4.686 -14.445,11.683 -14.445,11.683c-0.372,0.481 -0.729,0.962 -1.071,1.458c-9.371,13.917 2.932,32.442 19.549,30.084c24.033,-3.398 43.83,-10.364 53.884,-14.398c5.756,-2.312 10.255,-7.121 11.729,-13.157c0.14,-0.574 0.264,-1.148 0.372,-1.707C461.74,226.543 442.191,210.314 422.844,216.349z\"/&gt;\n    &lt;path android:fillColor=\"#FFE21F\" android:pathData=\"M448.522,327.857h-26.733c-4.018,0 -6.035,4.856 -3.196,7.711l26.733,26.733c2.839,2.839 7.711,0.822 7.711,-3.196v-26.733C453.036,329.874 451.019,327.857 448.522,327.857z\"/&gt;\n    &lt;path android:fillColor=\"#454545\" android:pathData=\"M473.547,380.965c-0.652,5.71 -5.477,10.007 -11.217,10.007h-51.433v29.851c0,10.566 8.564,19.146 19.146,19.146h32.303c10.566,0 19.146,-8.564 19.146,-19.146v-93.448C479.366,340.315 475.239,366.179 473.547,380.965z\"/&gt;\n    &lt;path android:fillColor=\"#ED6262\" android:pathData=\"M496.107,159.083c-1.552,-6.951 -8.083,-11.667 -15.205,-11.667h-12.909c-8.27,0 -14.972,6.703 -14.972,14.972v9.2h-6.842l3.925,9.325h15.05c7.789,0 15.5,-1.676 22.575,-4.918C494.105,173.078 497.674,166.096 496.107,159.083z\"/&gt;\n    &lt;path android:fillColor=\"#FFBD49\" android:pathData=\"M431.315,240.46m-18.82,0a18.82,18.82 0,1 1,37.64 0a18.82,18.82 0,1 1,-37.64 0\"/&gt;\n    &lt;path android:fillColor=\"#FFDB6F\" android:pathData=\"M393.458,255.308m-13.824,0a13.824,13.824 0,1 1,27.648 0a13.824,13.824 0,1 1,-27.648 0\"/&gt;\n    &lt;path android:fillColor=\"#6F6F6F\" android:pathData=\"M357.634,255.324l-21.613,37.639l-175.569,0l-21.613,-37.639z\"/&gt;\n    &lt;path android:fillColor=\"#FFFFFF\" android:pathData=\"M123.945,245.642c-0.326,-0.496 -0.683,-0.977 -1.071,-1.458c0,0 -2.095,-6.997 -14.445,-11.683c-7.447,-2.824 -14.569,-6.439 -21.535,-10.318c-3.832,-2.141 -8.378,-4.298 -13.281,-5.834c-19.332,-6.051 -38.896,10.193 -35.219,30.115c0.109,0.574 0.233,1.133 0.357,1.707c1.474,6.035 5.973,10.845 11.729,13.157c10.054,4.034 29.851,11 53.9,14.398C121.012,278.084 133.316,259.559 123.945,245.642z\"/&gt;\n    &lt;path android:fillColor=\"#FFE21F\" android:pathData=\"M74.684,327.857H47.951c-2.498,0 -4.515,2.017 -4.515,4.515v26.733c0,4.018 4.872,6.035 7.711,3.196l26.733,-26.733C80.719,332.729 78.702,327.857 74.684,327.857z\"/&gt;\n    &lt;path android:fillColor=\"#777777\" android:pathData=\"M426.226,374.511c-27.834,-48.159 -59.842,-46.654 -59.842,-46.654H130.073c0,0 -31.992,-1.505 -59.842,46.654H22.119l0.59,6.206c0.543,5.834 5.415,10.256 11.248,10.256h428.56c5.834,0 10.705,-4.422 11.249,-10.255l0.59,-6.206L426.226,374.511L426.226,374.511z\"/&gt;\n    &lt;path android:fillColor=\"#454545\" android:pathData=\"M34.143,390.988c-5.741,0 -10.566,-4.313 -11.217,-10.007c-1.691,-14.786 -5.834,-40.665 -7.944,-53.589v93.448c0,10.566 8.564,19.146 19.146,19.146H66.43c10.566,0 19.146,-8.564 19.146,-19.146v-29.851H34.143z\"/&gt;\n    &lt;path android:fillColor=\"#ED6262\" android:pathData=\"M43.436,171.588v-9.2c0,-8.27 -6.703,-14.972 -14.957,-14.972H15.571c-7.121,0 -13.653,4.717 -15.205,11.667c-1.567,6.997 2.017,13.995 8.378,16.896c7.09,3.243 14.786,4.918 22.575,4.918h15.05l3.925,-9.325h-6.858V171.588z\"/&gt;\n    &lt;path android:fillColor=\"#FFBD49\" android:pathData=\"M65.142,240.46m-18.82,0a18.82,18.82 0,1 1,37.64 0a18.82,18.82 0,1 1,-37.64 0\"/&gt;\n    &lt;path android:fillColor=\"#FFDB6F\" android:pathData=\"M103.03,255.308m-13.824,0a13.824,13.824 0,1 1,27.648 0a13.824,13.824 0,1 1,-27.648 0\"/&gt;\n    &lt;path android:fillColor=\"#6F6F6F\" android:pathData=\"M348.294,341.029H148.179c-3.134,0 -5.663,2.544 -5.663,5.663c0,3.134 2.529,5.663 5.663,5.663h200.099c3.134,0 5.663,-2.544 5.663,-5.663C353.957,343.558 351.412,341.029 348.294,341.029z\"/&gt;\n    &lt;path android:fillColor=\"#6F6F6F\" android:pathData=\"M348.294,363.635H148.179c-3.134,0 -5.663,2.544 -5.663,5.663c0,3.134 2.529,5.663 5.663,5.663h200.099c3.134,0 5.663,-2.544 5.663,-5.663C353.957,366.164 351.412,363.635 348.294,363.635z\"/&gt;\n    &lt;path android:fillColor=\"#3AA2EB\" android:pathData=\"M420.098,132.009v1.939c0,7.804 -6.408,14.057 -14.367,13.731c-7.339,-0.465 -12.955,-7.028 -12.955,-14.522v-27.834c0,-6.563 -5.461,-11.559 -12.024,-11.388c-0.155,0 -0.155,0 -0.31,0c0,0 0,0 -0.155,0c-6.563,-0.155 -12.024,4.841 -12.024,11.388v25.181c0,7.804 -6.718,14.057 -14.522,13.576c-7.339,-0.31 -12.955,-7.028 -12.955,-14.367v-21.892c0,-6.563 -5.461,-12.024 -12.179,-12.024h-0.931c-6.253,0 -11.404,5.151 -11.404,11.404v28.47c0,7.804 -6.563,14.041 -14.522,13.731c-7.339,-0.465 -12.8,-7.028 -12.8,-14.522V96.712c0,-6.082 -5.306,-11.233 -11.559,-10.768h-0.931c-6.408,0 -11.543,5.151 -11.543,11.404v39.021c0,7.494 -6.082,13.731 -13.731,13.731c-7.339,0 -13.421,-5.927 -13.576,-13.265v-32.752c0,-7.494 -5.616,-14.041 -12.955,-14.522c-7.959,-0.31 -14.367,5.927 -14.367,13.731l-0.155,30.255c0,7.804 -6.392,14.041 -14.367,13.731c-7.199,-0.45 -12.66,-6.78 -12.878,-13.948V97.829c0,-7.37 -5.539,-13.964 -12.909,-14.398c-7.897,-0.341 -14.414,5.88 -14.414,13.7v37.19c-0.217,7.618 -6.609,13.684 -14.445,13.374c-7.339,-0.465 -12.8,-7.028 -12.8,-14.522v-27.85c0,-6.563 -5.616,-11.559 -12.179,-11.388c-0.155,0 -0.155,0 -0.155,0c-0.155,0 -0.155,0 -0.155,0c-6.718,-0.155 -12.179,4.841 -12.179,11.388v25.181c0,7.804 -6.563,14.057 -14.367,13.576c-6.796,-0.264 -11.854,-5.942 -12.722,-12.521c-7.215,14.941 -14.367,31.123 -21.318,48.407c128.403,10.116 257.412,10.116 385.815,0C434.139,162.636 427.126,146.655 420.098,132.009z\"/&gt;\n&lt;/vector&gt;\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Google Maps&lt;/string&gt;\n    &lt;string name=\"map_type\"&gt;Map Type&lt;/string&gt;\n    &lt;string name=\"current_location\"&gt;Current Location&lt;/string&gt;\n    &lt;string name=\"go_to_current_location\"&gt;Go to current location&lt;/string&gt;\n    &lt;string name=\"remember_location\"&gt;Remember Location&lt;/string&gt;\n    &lt;string name=\"navigate\"&gt;Walk to Car&lt;/string&gt;\n    &lt;string name=\"forget_location\"&gt;Forget Location&lt;/string&gt;\n    &lt;string name=\"car_location\"&gt;Car Location&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nsecrets = \"2.0.1\"\nmaps-compose = \"6.2.1\"\nlocation-services = \"21.3.0\"\nlifecycle-runtime-compose = \"2.8.7\"\ndokka = \"1.9.20\"\nicons-extended = \"1.7.5\"\ndatastore-preferences = \"1.1.1\"\n\n[libraries]\ndatastore-preferences = { group = \"androidx.datastore\", name = \"datastore-preferences\", version.ref = \"datastore-preferences\" }\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended\", version.ref = \"icons-extended\" }\nlocation-services = { group = \"com.google.android.gms\", name = \"play-services-location\", version.ref = \"location-services\" }\nlifecycle-runtime-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-runtime-compose\" }\nmaps-compose = { group = \"com.google.maps.android\", name = \"maps-compose\", version.ref = \"maps-compose\" }\nmaps-compose-utils = { group = \"com.google.maps.android\", name = \"maps-compose-utils\", version.ref = \"maps-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nsecrets = { id = \"com.google.android.libraries.mapsplatform.secrets-gradle-plugin\", version.ref = \"secrets\" }\ndokka = { id = \"org.jetbrains.dokka\", version.ref = \"dokka\" }\n</pre>"},{"location":"modules/google-maps/STEP_140_REPO.html","title":"Dragging a Marker","text":"<p>Sometimes the location isn't as accurate as we'd like. For example, if you're driving in New York City, GPS signals can bounce off the tall buildings making it appear you're in a different location (this is called the \"canyon effect\"). Or perhaps the user selected \"approximate\" location.</p> <p>If we allow the user to drag the marker, they can position it more accurately to where the car is located.</p> <p>The first thing we need to do is tell Google Map that the icon should be draggable. The user can then long-press on the marker to activate drag mode and move it to another location. The MarkerState is updated with the new location.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    Scaffold(\n        // ...\n        content = { paddingValues -&gt;\n            Box(\n                // ...\n            ) {\n                Column(\n                    // ...\n                ) {\n                    // ...\n                    GoogleMap(\n                        // ...\n                    ) {\n                        // ...\n                        carLatLng?.let {\n                            // ...\n                            MarkerInfoWindowContent(\n                                state = carState,\n                                draggable = true,\n                                icon = carIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                // ...\n                            )\n                        }\n                    }\n                }\n                // ...\n            }\n        }\n    )\n}</pre> <p>Note</p> <p>When dragging a marker, it pops up a bit to clear your finger (so you can see it). If you're using an emulator with a mouse, this may seem odd, but think about visibility of the marker when you're using a finger on a real device.</p> <p>We need to watch for changes to the marker position and report it via an <code>onMoveCar</code> event parameter.</p> <p>First, we need a new function in the view model to explicitly set the car's location.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/CarViewModel.kt <pre>// ...\nclass CarViewModel(application: Application) : AndroidViewModel(application) {\n    // ...\n        }\n    }\n    fun setCarLocation(latLng: LatLng) {\n        viewModelScope.launch {\n            getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                preferences[LAT_PREF] = latLng.latitude.toString()\n                preferences[LON_PREF] = latLng.longitude.toString()\n            }\n        }\n    }\n}</pre> <p>We can pass it as an event parameter to the <code>GoogleMapDisplay</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n    onSetCarLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    onMoveCar: (LatLng) -&gt; Unit,\n    modifier: Modifier,\n) {\n    // ...\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        // ...\n        setContent {\n            GoogleMapsTheme {\n                // ...\n                GoogleMapDisplay(\n                    // ...\n                    onSetCarLocation = viewModel::setCarLocation,\n                    onClearCarLocation = viewModel::clearCarLocation,\n                    onMoveCar = viewModel::setCarLocation,\n                    modifier = Modifier.fillMaxSize(),\n                )\n            }\n        }\n    }\n    // ...\n}</pre> <p>The Google Maps Compose API doesn't directly expose an event function on <code>MarkerState</code>, so we have to be a little more clever. 'MarkerState' is a Jetpack Compose state holder. Its properties are delegated to Compose <code>State</code> (using <code>by mutableStateOf(...)</code>). From the outside, they look like normal properties.</p> <p>The cool trick is that the getter and setter for these properties inform the snapshot system of who is reading the state and when the state changes. </p> <p>We can ask the snapshot system to tell up about changes using <code>snapshotFlow</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    }\n\n    LaunchedEffect(true) {\n        var draggedAtLeastOnce = false\n        snapshotFlow { carState.isDragging }\n            .collect { dragging -&gt;\n                // Make sure we've seen at least one drag state before updating\n                //   the view model. Otherwise we'll see the initial (0.0, 0.0)\n                //   value that was set when the MarkerState was created\n                if (dragging) {\n                    draggedAtLeastOnce = true\n                } else if (draggedAtLeastOnce) {\n                    draggedAtLeastOnce = false\n                    onMoveCar(carState.position)\n                }\n            }\n    }\n\n    Scaffold(\n        // ...\n}</pre> <p>The gist of this function is</p> <ol> <li><code>snapshotFlow</code> creates a new <code>Flow</code> to report changes to the value of its lambda's value.</li> <li>An observer is set up to be notified whenever a new snapshot is taken. This can happen for any       Compose state change, but is often applied to a group of state changes.</li> <li>Whenever a new snapshot is taken, the lambda passed to <code>snapshotFlow</code> is evaluated to get       a value.</li> <li>The value is compared to the lambda's previous value (if any). If it's changed, the new value       is emitted to the created <code>Flow</code></li> </ol> <p>There are two properties that we're interested in here:</p> <ul> <li><code>isDragging</code> - whether the icon is being dragged.</li> <li><code>position</code> - the current position of the marker.</li> </ul> <p>When the <code>MarkerState</code> is initially set up, its is assigned a <code>position</code> of (0.0, 0.0). The <code>isDragging</code> property will be false, meaning the marker has a position, but we do not want to treat that as a location. We watch <code>isDragging</code> to see when the marker is being dragged. Once we've seen it has been dragged at least once, we know that when we see <code>isDragging == false</code> we have a new <code>position</code> that we should care about and move the car to it. We pass that position to <code>onCarMoved</code> so the view model can be informed to update the data store with the new position.</p> <p>After implementing this, when we press the star button to remember the car's location, the value is persisted to the datastore. When we quit the application and later return to it, the car location is loaded and displayed.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/CarViewModel.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.app.Application\nimport android.content.Context\nimport android.location.Location\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\nimport androidx.datastore.preferences.core.edit\nimport androidx.datastore.preferences.core.stringPreferencesKey\nimport androidx.datastore.preferences.preferencesDataStore\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.google.android.gms.maps.model.LatLng\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.launch\n\nclass CarViewModel(application: Application) : AndroidViewModel(application) {\n    private val LAT_PREF = stringPreferencesKey(\"lat\")\n    private val LON_PREF = stringPreferencesKey(\"lon\")\n\n    private val _currentLocation = MutableStateFlow&lt;Location?&gt;(null)\n\n    val currentLocation: Flow&lt;Location?&gt;\n        get() = _currentLocation\n\n    fun updateLocation(location: Location?) {\n        _currentLocation.value = location\n    }\n\n    private val Context.preferencesDataStore:\n            DataStore&lt;Preferences&gt; by preferencesDataStore(name = \"carfinder\")\n    val carLatLng = application.preferencesDataStore.data.map { preferences -&gt;\n        preferences[LAT_PREF]?.let { latString -&gt;\n            preferences[LON_PREF]?.let { lonString -&gt;\n                LatLng(latString.toDouble(), lonString.toDouble())\n            }\n        }\n    }\n    fun clearCarLocation() {\n        viewModelScope.launch {\n            getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                preferences.remove(LAT_PREF)\n                preferences.remove(LON_PREF)\n            }\n        }\n    }\n    fun setCarLocation() {\n        viewModelScope.launch {\n            _currentLocation.value?.let { location -&gt;\n                getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                    preferences[LAT_PREF] = location.latitude.toString()\n                    preferences[LON_PREF] = location.longitude.toString()\n                }\n            } ?: run {\n                clearCarLocation()\n            }\n        }\n    }\n    fun setCarLocation(latLng: LatLng) {\n        viewModelScope.launch {\n            getApplication&lt;Application&gt;().preferencesDataStore.edit { preferences -&gt;\n                preferences[LAT_PREF] = latLng.latitude.toString()\n                preferences[LON_PREF] = latLng.longitude.toString()\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.location.Location\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.runtime.snapshotFlow\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    cameraPositionState: CameraPositionState,\n    onSetCarLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    onMoveCar: (LatLng) -&gt; Unit,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    val context = LocalContext.current\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val carState = rememberMarkerState(\"car\")\n    var carIcon by remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n        if (mapLoaded) {\n            if (currentLocation != null) {\n                if (!initialBoundsSet) {\n                    initialBoundsSet = true\n                    val current =\n                        LatLng(currentLocation.latitude, currentLocation.longitude)\n                    cameraPositionState.animate(\n                        CameraUpdateFactory.newLatLngZoom(\n                            current,\n                            16f\n                        ), 1000\n                    )\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(true) {\n        var draggedAtLeastOnce = false\n        snapshotFlow { carState.isDragging }\n            .collect { dragging -&gt;\n                // Make sure we've seen at least one drag state before updating\n                //   the view model. Otherwise we'll see the initial (0.0, 0.0)\n                //   value that was set when the MarkerState was created\n                if (dragging) {\n                    draggedAtLeastOnce = true\n                } else if (draggedAtLeastOnce) {\n                    draggedAtLeastOnce = false\n                    onMoveCar(carState.position)\n                }\n            }\n    }\n\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                currentLocation = currentLocation,\n                carLatLng = carLatLng,\n                onSetCarLocation = onSetCarLocation,\n                onClearCarLocation = onClearCarLocation,\n                onWalkToCar = { TODO() },\n                onGoToCurrentLocation = {\n                    currentLocation?.let { curr -&gt;\n                        scope.launch {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    LatLng(curr.latitude, curr.longitude),\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    } ?: Toast.makeText(\n                        context,\n                        \"No current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n            )\n        },\n        content = { paddingValues -&gt;\n            Box(\n                modifier = modifier.padding(paddingValues),\n            ) {\n                Column(\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    MapTypeSelector(\n                        currentValue = currentMapType,\n                        modifier = Modifier.fillMaxWidth(),\n                    ) {\n                        mapProperties = mapProperties.copy(mapType = it)\n                        currentMapType = it\n                    }\n                    GoogleMap(\n                        cameraPositionState = cameraPositionState,\n                        onMapLoaded = {\n                            mapLoaded = true\n                            scope.launch(Dispatchers.IO) {\n                                currentLocationIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_current_location\n                                    )\n                                carIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_car\n                                    )\n                            }\n                        },\n                        properties = mapProperties,\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .weight(1f),\n                    ) {\n                        currentLocationState?.let {\n                            MarkerInfoWindowContent(\n                                state = it,\n                                icon = currentLocationIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.current_location\n                                ),\n                            )\n                        }\n                        carLatLng?.let {\n                            carState.position = it\n                            MarkerInfoWindowContent(\n                                state = carState,\n                                draggable = true,\n                                icon = carIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.car_location\n                                ),\n                            )\n                        }\n                    }\n                }\n\n                if (!mapLoaded) {\n                    AnimatedVisibility(\n                        visible = true,\n                        modifier = Modifier.fillMaxSize(),\n                        enter = EnterTransition.None,\n                        exit = fadeOut()\n                    ) {\n                        CircularProgressIndicator(\n                            modifier = Modifier\n                                .background(MaterialTheme.colorScheme.background)\n                                .wrapContentSize()\n                        )\n                    }\n                }\n            }\n        }\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/MainActivity.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.annotation.SuppressLint\nimport android.app.AlertDialog\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Bundle\nimport android.os.Looper\nimport android.provider.Settings\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.core.app.ActivityCompat\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.google.google.maps.ui.theme.GoogleMapsTheme\nimport com.google.android.gms.common.GoogleApiAvailability\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationCallback\nimport com.google.android.gms.location.LocationRequest\nimport com.google.android.gms.location.LocationResult\nimport com.google.android.gms.location.LocationServices\nimport com.google.android.gms.location.Priority\nimport com.google.android.gms.maps.model.CameraPosition\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.rememberCameraPositionState\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel: CarViewModel by viewModels()\n\n    private lateinit var fusedLocationProviderClient: FusedLocationProviderClient\n    private val locationCallback = object : LocationCallback() {\n        override fun onLocationResult(locationResult: LocationResult) {\n            viewModel.updateLocation(locationResult.lastLocation)\n        }\n    }\n\n    private val getLocationPermission =\n        registerForActivityResult(\n            ActivityResultContracts.RequestMultiplePermissions()\n        ) { isGranted -&gt;\n            if (isGranted.values.any { it }) {\n                startLocationAndMap()\n            } else {\n                // if the user denied permissions, tell them they\n                //   cannot use the app without them. In general,\n                //   you should try to just reduce function and let the\n                //   user continue, but location is a key part of this\n                //   application.\n                //   (Note that a real version of this application\n                //   might allow the user to manually click on the map\n                //   to set their current location, and we wouldn't\n                //   show this dialog, or perhaps only show it once)\n                // NOTE: This is a normal Android-View-based dialog, not a compose one!\n                AlertDialog.Builder(this)\n                    .setTitle(\"Permissions Needed\")\n                    .setMessage(\n                        \"We need coarse-location or fine-location permission \" +\n                                \"to locate a car (fine location is highly \" +\n                                \"recommended for accurate car locating). \" +\n                                \"Please allow these permissions via App Info \" +\n                                \"settings\")\n                    .setCancelable(false)\n                    .setNegativeButton(\"Quit\") { _, _ -&gt; finish() }\n                    .setPositiveButton(\"App Info\") { _, _ -&gt;\n                        startActivity(\n                            Intent(\n                                Settings.ACTION_APPLICATION_DETAILS_SETTINGS\n                            ).apply {\n                                data = Uri.parse(\"package:$packageName\")\n                            }\n                        )\n                        finish()\n                    }\n                    .show()\n            }\n        }\n\n    @SuppressLint(\"MissingPermission\")\n    fun startLocationAndMap() {\n        val locationRequest =\n            LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)\n                .setWaitForAccurateLocation(false)\n                .setMinUpdateIntervalMillis(0)\n                .setMaxUpdateDelayMillis(5000)\n                .build()\n        fusedLocationProviderClient =\n            LocationServices.getFusedLocationProviderClient(this)\n        fusedLocationProviderClient.requestLocationUpdates(\n            locationRequest,\n            locationCallback,\n            Looper.getMainLooper()\n        )\n\n        enableEdgeToEdge()\n        setContent {\n            GoogleMapsTheme {\n                val googleHQ = LatLng(37.42423291057923, -122.08811454627153)\n\n                val defaultCameraPosition = CameraPosition.fromLatLngZoom(googleHQ, 11f)\n\n                val cameraPositionState = rememberCameraPositionState {\n                    position = defaultCameraPosition\n                }\n\n                val currentLocation by viewModel.currentLocation.collectAsStateWithLifecycle(\n                    initialValue = null\n                )\n\n                val carLatLng by\n                    viewModel.carLatLng.collectAsStateWithLifecycle(initialValue = null)\n\n                GoogleMapDisplay(\n                    currentLocation = currentLocation,\n                    carLatLng = carLatLng,\n                    cameraPositionState = cameraPositionState,\n                    onSetCarLocation = viewModel::setCarLocation,\n                    onClearCarLocation = viewModel::clearCarLocation,\n                    onMoveCar = viewModel::setCarLocation,\n                    modifier = Modifier.fillMaxSize(),\n                )\n            }\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        GoogleApiAvailability.getInstance()\n            .makeGooglePlayServicesAvailable(this)\n            .addOnSuccessListener {\n                if (ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_FINE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED &amp;&amp;\n                    ActivityCompat.checkSelfPermission(\n                        this,\n                        android.Manifest.permission.ACCESS_COARSE_LOCATION\n                    ) != PackageManager.PERMISSION_GRANTED\n                ) {\n                    getLocationPermission.launch(\n                        arrayOf(\n                            android.Manifest.permission.ACCESS_FINE_LOCATION,\n                            android.Manifest.permission.ACCESS_COARSE_LOCATION,\n                        )\n                    )\n                } else {\n                    startLocationAndMap()\n                }\n            }.addOnFailureListener(this) {\n                Toast.makeText(\n                    this,\n                    \"Google Play services required (or upgrade required)\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                finish()\n            }\n    }\n}\n</pre>"},{"location":"modules/google-maps/STEP_150_REPO.html","title":"Navigating","text":"<p>The Google Map SDK for Android's terms of use forbids using Google's navigation data for real-time navigation in your own application. If you want to show the user how to get from point A to B in real time, you need to launch the Google Maps application itself.</p> <p>We launch navigation using an Android <code>Intent</code>. An <code>Intent</code> describes something you would like to do, typically with a different application or system service. This intent contains a URI that represents the navigation request:</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n) {\n    // ...\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                // ...\n                onSetCarLocation = onSetCarLocation,\n                onClearCarLocation = onClearCarLocation,\n//              onWalkToCar = { TODO() },\n                onWalkToCar = {\n                    currentLocation?.let { curr -&gt;\n                        carLatLng?.let { car -&gt;\n                            val uri =\n                                Uri.parse(\n                                    \"https://www.google.com/maps/dir/\" +\n                                            \"?api=1&amp;origin=${curr.latitude},\" +\n                                            \"${curr.longitude}&amp;\" +\n                                            \"destination=${car.latitude},\" +\n                                            \"${car.longitude}&amp;travelmode=walking\")\n                            context.startActivity(\n                                Intent(\n                                    Intent.ACTION_VIEW,\n                                    uri\n                                ).apply {\n                                    setPackage(\"com.google.android.apps.maps\")\n                                })\n                        } ?: Toast.makeText(\n                            context,\n                            \"Cannot navigate; no car location available\",\n                            Toast.LENGTH_LONG\n                        ).show()\n                    } ?: Toast.makeText(\n                        context,\n                        \"Cannot navigate; no current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n                onGoToCurrentLocation = {\n                    currentLocation?.let { curr -&gt;\n                        // ...\n            )\n        },\n        // ...\n    )\n}</pre> <pre><code>https://www.google.com/maps/dir/?api=1&amp;origin=${curr.latitude},${curr.longitude}&amp;destination=${car.latitude},${car.longitude}&amp;travelmode=walking\n</code></pre> <p>The Google Maps application registers <code>IntentFilters</code> that watch for URIs starting with \"https://www.google.com/maps\". The Android platform directs this <code>Intent</code> to Google Maps, and it presents navigation options:</p> <p></p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.content.Intent\nimport android.location.Location\nimport android.net.Uri\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.runtime.snapshotFlow\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    cameraPositionState: CameraPositionState,\n    onSetCarLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    onMoveCar: (LatLng) -&gt; Unit,\n    modifier: Modifier,\n) {\n    var mapLoaded by remember { mutableStateOf(false) }\n\n    var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n    var mapProperties by remember {\n        mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n    }\n\n    val currentLocationState = remember(currentLocation) {\n        currentLocation?.let {\n            MarkerState(\n                LatLng(\n                    it.latitude,\n                    it.longitude\n                )\n            )\n        }\n    }\n\n    val context = LocalContext.current\n    var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val carState = rememberMarkerState(\"car\")\n    var carIcon by remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n    val scope = rememberCoroutineScope()\n\n    var initialBoundsSet by remember { mutableStateOf(false) }\n    LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n        if (mapLoaded) {\n            if (currentLocation != null) {\n                if (!initialBoundsSet) {\n                    initialBoundsSet = true\n                    val current =\n                        LatLng(currentLocation.latitude, currentLocation.longitude)\n                    cameraPositionState.animate(\n                        CameraUpdateFactory.newLatLngZoom(\n                            current,\n                            16f\n                        ), 1000\n                    )\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(true) {\n        var draggedAtLeastOnce = false\n        snapshotFlow { carState.isDragging }\n            .collect { dragging -&gt;\n                // Make sure we've seen at least one drag state before updating\n                //   the view model. Otherwise we'll see the initial (0.0, 0.0)\n                //   value that was set when the MarkerState was created\n                if (dragging) {\n                    draggedAtLeastOnce = true\n                } else if (draggedAtLeastOnce) {\n                    draggedAtLeastOnce = false\n                    onMoveCar(carState.position)\n                }\n            }\n    }\n\n    Scaffold(\n        topBar = {\n            CarTopBar(\n                currentLocation = currentLocation,\n                carLatLng = carLatLng,\n                onSetCarLocation = onSetCarLocation,\n                onClearCarLocation = onClearCarLocation,\n//              onWalkToCar = { TODO() },\n                onWalkToCar = {\n                    currentLocation?.let { curr -&gt;\n                        carLatLng?.let { car -&gt;\n                            val uri =\n                                Uri.parse(\n                                    \"https://www.google.com/maps/dir/\" +\n                                            \"?api=1&amp;origin=${curr.latitude},\" +\n                                            \"${curr.longitude}&amp;\" +\n                                            \"destination=${car.latitude},\" +\n                                            \"${car.longitude}&amp;travelmode=walking\")\n                            context.startActivity(\n                                Intent(\n                                    Intent.ACTION_VIEW,\n                                    uri\n                                ).apply {\n                                    setPackage(\"com.google.android.apps.maps\")\n                                })\n                        } ?: Toast.makeText(\n                            context,\n                            \"Cannot navigate; no car location available\",\n                            Toast.LENGTH_LONG\n                        ).show()\n                    } ?: Toast.makeText(\n                        context,\n                        \"Cannot navigate; no current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n                onGoToCurrentLocation = {\n                    currentLocation?.let { curr -&gt;\n                        scope.launch {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    LatLng(curr.latitude, curr.longitude),\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    } ?: Toast.makeText(\n                        context,\n                        \"No current location available\",\n                        Toast.LENGTH_LONG\n                    ).show()\n                },\n            )\n        },\n        content = { paddingValues -&gt;\n            Box(\n                modifier = modifier.padding(paddingValues),\n            ) {\n                Column(\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    MapTypeSelector(\n                        currentValue = currentMapType,\n                        modifier = Modifier.fillMaxWidth(),\n                    ) {\n                        mapProperties = mapProperties.copy(mapType = it)\n                        currentMapType = it\n                    }\n                    GoogleMap(\n                        cameraPositionState = cameraPositionState,\n                        onMapLoaded = {\n                            mapLoaded = true\n                            scope.launch(Dispatchers.IO) {\n                                currentLocationIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_current_location\n                                    )\n                                carIcon =\n                                    context.loadBitmapDescriptor(\n                                        R.drawable.ic_car\n                                    )\n                            }\n                        },\n                        properties = mapProperties,\n                        modifier = Modifier\n                            .fillMaxWidth()\n                            .weight(1f),\n                    ) {\n                        currentLocationState?.let {\n                            MarkerInfoWindowContent(\n                                state = it,\n                                icon = currentLocationIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.current_location\n                                ),\n                            )\n                        }\n                        carLatLng?.let {\n                            carState.position = it\n                            MarkerInfoWindowContent(\n                                state = carState,\n                                draggable = true,\n                                icon = carIcon,\n                                anchor = Offset(0.5f, 0.5f),\n                                title = stringResource(\n                                    id = R.string.car_location\n                                ),\n                            )\n                        }\n                    }\n                }\n\n                if (!mapLoaded) {\n                    AnimatedVisibility(\n                        visible = true,\n                        modifier = Modifier.fillMaxSize(),\n                        enter = EnterTransition.None,\n                        exit = fadeOut()\n                    ) {\n                        CircularProgressIndicator(\n                            modifier = Modifier\n                                .background(MaterialTheme.colorScheme.background)\n                                .wrapContentSize()\n                        )\n                    }\n                }\n            }\n        }\n    )\n}\n</pre>"},{"location":"modules/google-maps/STEP_160_REPO.html","title":"Lat/Lon Bounds","text":"<p>We've seen how Google maps lets you animate panning and zooming to a location. You can also do this to a region defined by two points.</p> <p><code>LatLngBounds</code> is an immutable type that you can use to expand a region as points are added to it. Think about a real-estate application that has a list of houses for sale, and you'd like to show all of the houses on the map. You would start with a single point</p> <pre><code>var bounds = LatLngBounds(point1, point1)\n</code></pre> <p>and then expand it by including other points:</p> <pre><code>bounds = bounds.including(nextPoint)\n</code></pre> <p>Note that <code>including</code> returns a a new instance of <code>LatLngBounds</code>; it does not update the existing instance.</p> <p>We can <code>LatLngBounds</code> to include the car and current location if both are defined. Here we've expanded the auto-location logic that was based on the <code>currentLocation</code> to check if a car location had been saved. If so, we animate to a <code>LatLngBounds</code>; if not, we animate to just the current location with a zoom level.</p> <p>When moving the camera position to a <code>LatLngBounds</code>, you must pass in a pixel value for how much space to leave around the edges of the map. Pixel values aren't consistent across devices, as many devices have different screen densities. We'd like to use density-independent pixels, but that means we need to convert dp to px.</p> <p>Using <code>LocalDensity</code>, we can ask for the current screen density and use it access the <code>toPx()</code> function. Now we can have a consistent <code>48.dp</code> map margin on all devices.</p> show in full file  app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>// ...\n\n@Composable\nfun GoogleMapDisplay(\n    // ...\n    modifier: Modifier,\n) {\n    with(LocalDensity.current) {\n        val boundsPadding = 48.dp.toPx()\n        var mapLoaded by remember { mutableStateOf(false) }\n\n        // ...\n        LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n            if (mapLoaded) {\n                if (currentLocation != null) {\n                    if (!initialBoundsSet) {\n                        initialBoundsSet = true\n                        val current =\n                            LatLng(currentLocation.latitude, currentLocation.longitude)\n                        carLatLng?.let { car -&gt;\n                            val bounds =\n                                LatLngBounds(current, current).including(car)\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngBounds(\n                                    bounds,\n                                    boundsPadding.toInt()\n                                ), 1000\n                            )\n                        } ?: run {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    current,\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    }\n                }\n            }\n        }\n        // ...\n    }\n}</pre> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/google/google/maps/GoogleMapDisplay.kt <pre>package com.androidbyexample.compose.google.google.maps\n\nimport android.content.Intent\nimport android.location.Location\nimport android.net.Uri\nimport android.widget.Toast\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.EnterTransition\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.wrapContentSize\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.runtime.setValue\nimport androidx.compose.runtime.snapshotFlow\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.geometry.Offset\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalDensity\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.google.android.gms.maps.CameraUpdateFactory\nimport com.google.android.gms.maps.model.BitmapDescriptor\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.android.gms.maps.model.LatLngBounds\nimport com.google.maps.android.compose.CameraPositionState\nimport com.google.maps.android.compose.GoogleMap\nimport com.google.maps.android.compose.MapProperties\nimport com.google.maps.android.compose.MapType\nimport com.google.maps.android.compose.MarkerInfoWindowContent\nimport com.google.maps.android.compose.MarkerState\nimport com.google.maps.android.compose.rememberMarkerState\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun GoogleMapDisplay(\n    currentLocation: Location?,\n    carLatLng: LatLng?,\n    cameraPositionState: CameraPositionState,\n    onSetCarLocation: () -&gt; Unit,\n    onClearCarLocation: () -&gt; Unit,\n    onMoveCar: (LatLng) -&gt; Unit,\n    modifier: Modifier,\n) {\n    with(LocalDensity.current) {\n        val boundsPadding = 48.dp.toPx()\n        var mapLoaded by remember { mutableStateOf(false) }\n\n        var currentMapType by remember { mutableStateOf(MapType.NORMAL) }\n        var mapProperties by remember {\n            mutableStateOf(MapProperties(mapType = MapType.NORMAL))\n        }\n\n        val currentLocationState = remember(currentLocation) {\n            currentLocation?.let {\n                MarkerState(\n                    LatLng(\n                        it.latitude,\n                        it.longitude\n                    )\n                )\n            }\n        }\n\n        val context = LocalContext.current\n        var currentLocationIcon by\n        remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n        val carState = rememberMarkerState(\"car\")\n        var carIcon by remember { mutableStateOf&lt;BitmapDescriptor?&gt;(null) }\n        val scope = rememberCoroutineScope()\n\n        var initialBoundsSet by remember { mutableStateOf(false) }\n        LaunchedEffect(key1 = mapLoaded, key2 = currentLocation) {\n            if (mapLoaded) {\n                if (currentLocation != null) {\n                    if (!initialBoundsSet) {\n                        initialBoundsSet = true\n                        val current =\n                            LatLng(currentLocation.latitude, currentLocation.longitude)\n                        carLatLng?.let { car -&gt;\n                            val bounds =\n                                LatLngBounds(current, current).including(car)\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngBounds(\n                                    bounds,\n                                    boundsPadding.toInt()\n                                ), 1000\n                            )\n                        } ?: run {\n                            cameraPositionState.animate(\n                                CameraUpdateFactory.newLatLngZoom(\n                                    current,\n                                    16f\n                                ), 1000\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        LaunchedEffect(true) {\n            var draggedAtLeastOnce = false\n            snapshotFlow { carState.isDragging }\n                .collect { dragging -&gt;\n                    // Make sure we've seen at least one drag state before updating\n                    //   the view model. Otherwise we'll see the initial (0.0, 0.0)\n                    //   value that was set when the MarkerState was created\n                    if (dragging) {\n                        draggedAtLeastOnce = true\n                    } else if (draggedAtLeastOnce) {\n                        draggedAtLeastOnce = false\n                        onMoveCar(carState.position)\n                    }\n                }\n        }\n\n        Scaffold(\n            topBar = {\n                CarTopBar(\n                    currentLocation = currentLocation,\n                    carLatLng = carLatLng,\n                    onSetCarLocation = onSetCarLocation,\n                    onClearCarLocation = onClearCarLocation,\n                    onWalkToCar = {\n                        currentLocation?.let { curr -&gt;\n                            carLatLng?.let { car -&gt;\n                                val uri =\n                                    Uri.parse(\n                                        \"https://www.google.com/maps/dir/\" +\n                                                \"?api=1&amp;origin=${curr.latitude},\" +\n                                                \"${curr.longitude}&amp;\" +\n                                                \"destination=${car.latitude},\" +\n//                                          \"${car.longitude}&amp;travelmode=walking\")\n                                                \"${car.longitude}&amp;travelmode=walking\"\n                                    )\n                                context.startActivity(\n                                    Intent(\n                                        Intent.ACTION_VIEW,\n                                        uri\n                                    ).apply {\n                                        setPackage(\"com.google.android.apps.maps\")\n                                    })\n                            } ?: Toast.makeText(\n                                context,\n                                \"Cannot navigate; no car location available\",\n                                Toast.LENGTH_LONG\n                            ).show()\n                        } ?: Toast.makeText(\n                            context,\n                            \"Cannot navigate; no current location available\",\n                            Toast.LENGTH_LONG\n                        ).show()\n                    },\n                    onGoToCurrentLocation = {\n                        currentLocation?.let { curr -&gt;\n                            scope.launch {\n                                cameraPositionState.animate(\n                                    CameraUpdateFactory.newLatLngZoom(\n                                        LatLng(curr.latitude, curr.longitude),\n                                        16f\n                                    ), 1000\n                                )\n                            }\n                        } ?: Toast.makeText(\n                            context,\n                            \"No current location available\",\n                            Toast.LENGTH_LONG\n                        ).show()\n                    },\n                )\n            },\n            content = { paddingValues -&gt;\n                Box(\n                    modifier = modifier.padding(paddingValues),\n                ) {\n                    Column(\n                        modifier = Modifier.fillMaxSize()\n                    ) {\n                        MapTypeSelector(\n                            currentValue = currentMapType,\n                            modifier = Modifier.fillMaxWidth(),\n                        ) {\n                            mapProperties = mapProperties.copy(mapType = it)\n                            currentMapType = it\n                        }\n                        GoogleMap(\n                            cameraPositionState = cameraPositionState,\n                            onMapLoaded = {\n                                mapLoaded = true\n                                scope.launch(Dispatchers.IO) {\n                                    currentLocationIcon =\n                                        context.loadBitmapDescriptor(\n                                            R.drawable.ic_current_location\n                                        )\n                                    carIcon =\n                                        context.loadBitmapDescriptor(\n                                            R.drawable.ic_car\n                                        )\n                                }\n                            },\n                            properties = mapProperties,\n                            modifier = Modifier\n                                .fillMaxWidth()\n                                .weight(1f),\n                        ) {\n                            currentLocationState?.let {\n                                MarkerInfoWindowContent(\n                                    state = it,\n                                    icon = currentLocationIcon,\n                                    anchor = Offset(0.5f, 0.5f),\n                                    title = stringResource(\n                                        id = R.string.current_location\n                                    ),\n                                )\n                            }\n                            carLatLng?.let {\n                                carState.position = it\n                                MarkerInfoWindowContent(\n                                    state = carState,\n                                    draggable = true,\n                                    icon = carIcon,\n                                    anchor = Offset(0.5f, 0.5f),\n                                    title = stringResource(\n                                        id = R.string.car_location\n                                    ),\n                                )\n                            }\n                        }\n                    }\n\n                    if (!mapLoaded) {\n                        AnimatedVisibility(\n                            visible = true,\n                            modifier = Modifier.fillMaxSize(),\n                            enter = EnterTransition.None,\n                            exit = fadeOut()\n                        ) {\n                            CircularProgressIndicator(\n                                modifier = Modifier\n                                    .background(MaterialTheme.colorScheme.background)\n                                    .wrapContentSize()\n                            )\n                        }\n                    }\n                }\n            }\n        )\n    }\n}\n</pre>"},{"location":"modules/google-maps/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/google-maps. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>google-maps</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/google-maps\n</code></pre>"},{"location":"modules/introduction/STEP_010_FULL.html","title":"About This Site","text":"<p>This is the content site for Johns Hopkins University Whiting School of Engineering's 605.686 Mobile Development for the Android Platform.</p> <p>All code and content is open source and free for use. Please see the <code>LICENSE-code.md</code> and <code>LICENSE-content.md</code> files for license details.</p>"},{"location":"modules/introduction/STEP_010_FULL.html#using-this-site","title":"Using this site","text":"<p>I recommend viewing this site on a desktop or laptop, full screen.</p> <p>Navigation links will be visible on the left if there is enough screen space. Otherwise, a \"hamburger menu\" navigation button will appear in the upper left corner of the site; click on it and you can navigate. </p> <p>If the search box isn't focused, you can hit <code>P</code> or <code>,</code> to go to the previous page and <code>N</code> or <code>.</code> to go to the next page.</p>"},{"location":"modules/introduction/STEP_020_FULL.html","title":"About Your Instructor","text":""},{"location":"modules/introduction/STEP_020_FULL.html#scott-stanchfield","title":"Scott Stanchfield","text":"<p>By day, Scott works at Google in Android Developer Relations. They usually tell him to go play with some (colorful) blocks in the corner (so everyone else can actually get some work done).</p> <p>By night, Scott can be found teaching Android Mobile Application Development and Kotlin programming for the JHU Whiting School. He also enjoys swing dancing, singing Karaoke and attending musicals whenever they stop in DC.</p> <p>Scott's been a Software Developer/Architect for over 30 years. Some highlights:</p> <ul> <li> <p>Worked for Tom McCabe, creator of the Cyclomatic Complexity metric. </p> </li> <li> <p>Worked for Frank DeRemer and Tom Penello, inventors of LALR parsing (the type of parsing used by the lex and yacc parser-generation tools)</p> </li> <li> <p>Worked for Terence Parr (creator of PCCS/ANTLR - which use LL parsing), created a debugger for ANTLR and taught Java world-wide for four years.</p> </li> <li> <p>Was on the ANSI C++ 1998 Standardization committee (don't blame him; he was only in the last two sessions and tried to stop it...)</p> </li> <li> <p>Wrote Effective VisualAge for Java, Version 3.5 in the late 90's</p> </li> <li> <p>Held the world record on Discs of Tron (arcade) in the mid 80's. Currently #3 at Twin Galaxies, and #3 on Arcade1Up's machine.</p> </li> </ul>"},{"location":"modules/introduction/STEP_020_FULL.html#a-few-pictures","title":"A Few Pictures","text":""},{"location":"modules/introduction/STEP_020_FULL.html#best-glasses-ever","title":"Best. Glasses. Ever!","text":"<p>Part of my MC-3P0 costume.</p> <p></p>"},{"location":"modules/introduction/STEP_020_FULL.html#welcome-to-the-hallcade","title":"Welcome to the Hallcade","text":"<p>Had to do something with this awkward hall...</p> <p></p>"},{"location":"modules/introduction/STEP_020_FULL.html#education-history","title":"Education History","text":"<ul> <li> <p>Bachelor of Arts Computer Science, The University of Michigan</p> </li> <li> <p>Master of Science Computer Science, The Johns Hopkins University</p> </li> </ul>"},{"location":"modules/introduction/STEP_020_FULL.html#publications","title":"Publications","text":"<p>Please see http://www.javadude.com/publications/</p>"},{"location":"modules/introduction/STEP_020_FULL.html#contact-information","title":"Contact Information","text":"<p>Website: https://javadude.com</p> <p>JHU Email: scott.stanchfield@jhu.edu (use for all class communication)</p> <p>Personal Email: scott@javadude.com (only use for non-class communication)</p>"},{"location":"modules/introduction/STEP_040_FULL.html","title":"Content License","text":""},{"location":"modules/introduction/STEP_040_FULL.html#overview","title":"Overview","text":"<p>This is the LICENSE for all non-code content in this repository.</p> <p>This covers all markdown files, such as README.md, as well as linked course videos hosted on youtube. </p> <p>See Source Code License for the license for source code in this repository</p> <p>The gist of the license: https://creativecommons.org/licenses/by-sa/2.0/</p> <p>You can share with attribution as long as you include this license AND license any modifications with the same license</p>"},{"location":"modules/introduction/STEP_040_FULL.html#full-license-text","title":"Full License Text","text":"<p>This text is also available at https://creativecommons.org/licenses/by-sa/2.0/legalcode</p> <pre><code>Creative Commons\n\nCreative Commons Legal Code\nAttribution-ShareAlike 2.0\n\nCREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS INFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM ITS USE.\nLicense\n\nTHE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE (\"CCPL\" OR \"LICENSE\"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.\n\nBY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.\n\n1. Definitions\n\n\"Collective Work\" means a work, such as a periodical issue, anthology or encyclopedia, in which the Work in its entirety in unmodified form, along with a number of other contributions, constituting separate and independent works in themselves, are assembled into a collective whole. A work that constitutes a Collective Work will not be considered a Derivative Work (as defined below) for the purposes of this License.\n\"Derivative Work\" means a work based upon the Work or upon the Work and other pre-existing works, such as a translation, musical arrangement, dramatization, fictionalization, motion picture version, sound recording, art reproduction, abridgment, condensation, or any other form in which the Work may be recast, transformed, or adapted, except that a work that constitutes a Collective Work will not be considered a Derivative Work for the purpose of this License. For the avoidance of doubt, where the Work is a musical composition or sound recording, the synchronization of the Work in timed-relation with a moving image (\"synching\") will be considered a Derivative Work for the purpose of this License.\n\"Licensor\" means the individual or entity that offers the Work under the terms of this License.\n\"Original Author\" means the individual or entity who created the Work.\n\"Work\" means the copyrightable work of authorship offered under the terms of this License.\n\"You\" means an individual or entity exercising rights under this License who has not previously violated the terms of this License with respect to the Work, or who has received express permission from the Licensor to exercise rights under this License despite a previous violation.\n\"License Elements\" means the following high-level license attributes as selected by Licensor and indicated in the title of this License: Attribution, ShareAlike.\n2. Fair Use Rights. Nothing in this license is intended to reduce, limit, or restrict any rights arising from fair use, first sale or other limitations on the exclusive rights of the copyright owner under copyright law or other applicable laws.\n\n3. License Grant. Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to exercise the rights in the Work as stated below:\n\nto reproduce the Work, to incorporate the Work into one or more Collective Works, and to reproduce the Work as incorporated in the Collective Works;\nto create and reproduce Derivative Works;\nto distribute copies or phonorecords of, display publicly, perform publicly, and perform publicly by means of a digital audio transmission the Work including as incorporated in Collective Works;\nto distribute copies or phonorecords of, display publicly, perform publicly, and perform publicly by means of a digital audio transmission Derivative Works.\nFor the avoidance of doubt, where the work is a musical composition:\n\nPerformance Royalties Under Blanket Licenses. Licensor waives the exclusive right to collect, whether individually or via a performance rights society (e.g. ASCAP, BMI, SESAC), royalties for the public performance or public digital performance (e.g. webcast) of the Work.\nMechanical Rights and Statutory Royalties. Licensor waives the exclusive right to collect, whether individually or via a music rights society or designated agent (e.g. Harry Fox Agency), royalties for any phonorecord You create from the Work (\"cover version\") and distribute, subject to the compulsory license created by 17 USC Section 115 of the US Copyright Act (or the equivalent in other jurisdictions).\nWebcasting Rights and Statutory Royalties. For the avoidance of doubt, where the Work is a sound recording, Licensor waives the exclusive right to collect, whether individually or via a performance-rights society (e.g. SoundExchange), royalties for the public digital performance (e.g. webcast) of the Work, subject to the compulsory license created by 17 USC Section 114 of the US Copyright Act (or the equivalent in other jurisdictions).\nThe above rights may be exercised in all media and formats whether now known or hereafter devised. The above rights include the right to make such modifications as are technically necessary to exercise the rights in other media and formats. All rights not expressly granted by Licensor are hereby reserved.\n\n4. Restrictions.The license granted in Section 3 above is expressly made subject to and limited by the following restrictions:\n\nYou may distribute, publicly display, publicly perform, or publicly digitally perform the Work only under the terms of this License, and You must include a copy of, or the Uniform Resource Identifier for, this License with every copy or phonorecord of the Work You distribute, publicly display, publicly perform, or publicly digitally perform. You may not offer or impose any terms on the Work that alter or restrict the terms of this License or the recipients' exercise of the rights granted hereunder. You may not sublicense the Work. You must keep intact all notices that refer to this License and to the disclaimer of warranties. You may not distribute, publicly display, publicly perform, or publicly digitally perform the Work with any technological measures that control access or use of the Work in a manner inconsistent with the terms of this License Agreement. The above applies to the Work as incorporated in a Collective Work, but this does not require the Collective Work apart from the Work itself to be made subject to the terms of this License. If You create a Collective Work, upon notice from any Licensor You must, to the extent practicable, remove from the Collective Work any reference to such Licensor or the Original Author, as requested. If You create a Derivative Work, upon notice from any Licensor You must, to the extent practicable, remove from the Derivative Work any reference to such Licensor or the Original Author, as requested.\nYou may distribute, publicly display, publicly perform, or publicly digitally perform a Derivative Work only under the terms of this License, a later version of this License with the same License Elements as this License, or a Creative Commons iCommons license that contains the same License Elements as this License (e.g. Attribution-ShareAlike 2.0 Japan). You must include a copy of, or the Uniform Resource Identifier for, this License or other license specified in the previous sentence with every copy or phonorecord of each Derivative Work You distribute, publicly display, publicly perform, or publicly digitally perform. You may not offer or impose any terms on the Derivative Works that alter or restrict the terms of this License or the recipients' exercise of the rights granted hereunder, and You must keep intact all notices that refer to this License and to the disclaimer of warranties. You may not distribute, publicly display, publicly perform, or publicly digitally perform the Derivative Work with any technological measures that control access or use of the Work in a manner inconsistent with the terms of this License Agreement. The above applies to the Derivative Work as incorporated in a Collective Work, but this does not require the Collective Work apart from the Derivative Work itself to be made subject to the terms of this License.\nIf you distribute, publicly display, publicly perform, or publicly digitally perform the Work or any Derivative Works or Collective Works, You must keep intact all copyright notices for the Work and give the Original Author credit reasonable to the medium or means You are utilizing by conveying the name (or pseudonym if applicable) of the Original Author if supplied; the title of the Work if supplied; to the extent reasonably practicable, the Uniform Resource Identifier, if any, that Licensor specifies to be associated with the Work, unless such URI does not refer to the copyright notice or licensing information for the Work; and in the case of a Derivative Work, a credit identifying the use of the Work in the Derivative Work (e.g., \"French translation of the Work by Original Author,\" or \"Screenplay based on original Work by Original Author\"). Such credit may be implemented in any reasonable manner; provided, however, that in the case of a Derivative Work or Collective Work, at a minimum such credit will appear where any other comparable authorship credit appears and in a manner at least as prominent as such other comparable authorship credit.\n5. Representations, Warranties and Disclaimer\n\nUNLESS OTHERWISE AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE MATERIALS, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.\n\n6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n7. Termination\n\nThis License and the rights granted hereunder will terminate automatically upon any breach by You of the terms of this License. Individuals or entities who have received Derivative Works or Collective Works from You under this License, however, will not have their licenses terminated provided such individuals or entities remain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this License.\nSubject to the above terms and conditions, the license granted here is perpetual (for the duration of the applicable copyright in the Work). Notwithstanding the above, Licensor reserves the right to release the Work under different license terms or to stop distributing the Work at any time; provided, however that any such election will not serve to withdraw this License (or any other license that has been, or is required to be, granted under the terms of this License), and this License will continue in full force and effect unless terminated as stated above.\n8. Miscellaneous\n\nEach time You distribute or publicly digitally perform the Work or a Collective Work, the Licensor offers to the recipient a license to the Work on the same terms and conditions as the license granted to You under this License.\nEach time You distribute or publicly digitally perform a Derivative Work, Licensor offers to the recipient a license to the original Work on the same terms and conditions as the license granted to You under this License.\nIf any provision of this License is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this License, and without further action by the parties to this agreement, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable.\nNo term or provision of this License shall be deemed waived and no breach consented to unless such waiver or consent shall be in writing and signed by the party to be charged with such waiver or consent.\nThis License constitutes the entire agreement between the parties with respect to the Work licensed here. There are no understandings, agreements or representations with respect to the Work not specified here. Licensor shall not be bound by any additional provisions that may appear in any communication from You. This License may not be modified without the mutual written agreement of the Licensor and You.\nCreative Commons is not a party to this License, and makes no warranty whatsoever in connection with the Work. Creative Commons will not be liable to You or any party on any legal theory for any damages whatsoever, including without limitation any general, special, incidental or consequential damages arising in connection to this license. Notwithstanding the foregoing two (2) sentences, if Creative Commons has expressly identified itself as the Licensor hereunder, it shall have all rights and obligations of Licensor.\n\nExcept for the limited purpose of indicating to the public that the Work is licensed under the CCPL, neither party will use the trademark \"Creative Commons\" or any related trademark or logo of Creative Commons without the prior written consent of Creative Commons. Any permitted use will be in compliance with Creative Commons' then-current trademark usage guidelines, as may be published on its website or otherwise made available upon request from time to time.\n\nCreative Commons may be contacted at https://creativecommons.org/.\n</code></pre>"},{"location":"modules/introduction/STEP_050_FULL.html","title":"Source Code License","text":""},{"location":"modules/introduction/STEP_050_FULL.html#overview","title":"Overview","text":"<p>This is the LICENSE for all source code in this repository This does not include written content such as README.md files - see Content License for those files</p> <p>All source code examples are licensed under the Apache License, version 2.0. Full details of this license appear below.</p> <p>See https://tldrlegal.com/license/apache-license-2.0-(apache-2.0) for a quick summary of this license.</p>"},{"location":"modules/introduction/STEP_050_FULL.html#full-license-text","title":"Full License Text","text":"<pre><code>                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2024 Android Development 2024 Refresh\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n</code></pre>"},{"location":"modules/introduction/STEP_060_FULL.html","title":"Welcome!","text":"<p>Note</p> <p>All of the content in this Introduction module is critical to your success in this class. I know it's not the most thrilling read, but please be sure to read it thoroughly.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#course-content","title":"Course Content","text":"<p>All course content and the course sample repository are free for use to anyone. Feel free to pass these links to friends and co-workers.</p> <p>For those viewing the content who are not enrolled in 605.686, please ignore any references to the Canvas site, assignments or syllabus.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#your-actions","title":"Your Actions","text":"<p>Please do the following</p> <ul> <li> <p>Check that your email and phone numbers are correct in JHED and SIS. I'll use these to send announcements. If you saw this announcement in your email you should be ok.</p> </li> <li> <p>Please post in the \"Introductions\" forum as described in the thread header. Note that there is only one thread; you cannot create separate threads for your introduction.</p> </li> </ul>"},{"location":"modules/introduction/STEP_060_FULL.html#welcome","title":"Welcome!","text":"<p>Hi there! I'm Scott Stanchfield. Welcome to 605.686, Mobile Application Development for the Android Platform! </p> <p>We'll be exploring Android application development, covering all sorts of topics including creation of user interfaces, storing data, and communicating with servers. You can see the full list of topics on this course site, broken down by week.</p> <p>Note</p> <p>This site is required for online sections of the class, and supplmentary for face-to-face or virtual-live sections.</p> <p>Please be sure to read this entire note, the syllabus (on the Canvas site), and all sections in this Introduction module. There are lots of very important things in there that I will hold you accountable for. In particular, please pay attention to the academic integrity (I'm good at catching cheaters!) and \"Holistic\" grading (so you understand what your grades actually mean) sections.</p> <p>The syllabus is available via the \"Syllabus\" link on the left menu in Canvas. Note that we've migrated to a common syllabus management tool to ensure all the common university-level information is consistent and up-to-date across all courses. There's an Export button when viewing the Syllabus if you'd like to download and print it.</p> <p>The Introduction module goes into more detail on assignment expectations and grading.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#content","title":"Content","text":"<p>Note</p> <p>This applies to online sections of the course. If you are taking the class face-to-face/virtual-live, you are responsible for material covered in class (which will be recorded and posted), and the https://androidbyexample.com site is provided only as additional information.</p> <p>I'm posting the course content that would normally appear in Canvas on https://androidbyexample.com. This allows a more custom experience. Some material appears in a textual format, and other material appears in a video format.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#sample-code","title":"Sample Code","text":"<p>Note</p> <p>This applies to online sections of the course. If you are taking the class face-to-face/virtual-live, you are responsible for material covered in class (which will be recorded and posted), and the course samples site is only provided as supplemental material.</p> <p>All sample code is available at https://gitlab.com/605-686/spring-2025-refresh/modules</p> <p>Please install git and clone this repository. If I update during the course, I'll direct you to pull changes when I announce that new content is available.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#if-you-havent-used-git-before","title":"If you haven't used git before...","text":"<p>For this example, I'll use <code>https://gitlab.com/605-686/spring-2025-refresh/modules/compose-concepts</code> as the source code module to download. You'll need to download individual modules referenced by content on this site. Each module is a separate git repository.</p> <ol> <li> <p>Download and install git from https://git-scm.com/</p> </li> <li> <p>Create a directory to hold your git repositories. (I use d:\\users\\scott\\git on my windows machine, but you can put it anywhere you would like)</p> </li> <li> <p>Open a command prompt/terminal and change to that directory</p> </li> <li> <p>Run</p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/compose-concepts\n</code></pre> <p>(This will create a <code>compose-concepts</code> directory inside your git directory)</p> </li> </ol>"},{"location":"modules/introduction/STEP_060_FULL.html#kotlin-note","title":"Kotlin Note","text":"<p>All assignments must be written in Kotlin. The text and videos in the course will work through development environment setup and implementation using Kotlin and describe some of the concepts behind Kotlin along the way.</p> <p>I also teach a course in Kotlin (605.603) but it is not required for this course. It will, however, go into much more detail on the Kotlin language and I recommend everyone take it. Because, ya know, Kotlin is cool. Very, very cool.</p> <p>There is a Kotlin Primer module included in this course that can help get you up to speed with most of the concepts you'll need to know.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#online-video-tips","title":"Online Video Tips","text":"<p>Some modules will link to video content. All videos are hosted on YouTube, and I've enabled automatic closed captions/transcript. The transcript is useful for searching. </p> <p>To search videos:</p> <ol> <li> <p>Click the \"...\" button under the video</p> </li> <li> <p>Choose \"Open Transcript\"</p> </li> <li> <p>Pause the video</p> </li> <li> <p>Press control-f (or whatever your browser's \"find\" command is)</p> </li> <li> <p>Type what you want to find</p> </li> <li> <p>Click on the transcript line you want to jump to and the video will jump there.</p> </li> <li> <p>Press play</p> </li> </ol> <p>Note that the automatic transcripts are not perfect, but they can help you find what you're looking for.</p> <p>All videos were recorded and rendered at 1920x1080 (HD). That's the ideal size to watch them. If you're watching non full-screen, with the transcript, you'll want to have your resolution set higher to reduce artifacts. Make sure the settings for the video playback are HD/1080p for the best image. I've increased the font size in Android Studio when recording, but you'll want to be sure things are as clear as possible.</p> <p>Keep in mind that YouTube allows you to change the playback speed. Some students like to speed up or (more likely, as I talk quickly at times) slow down a bit.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#office-hours","title":"Office Hours","text":"<p>Office Hours are on-demand. Please email me to arrange a time if you need some help.</p>"},{"location":"modules/introduction/STEP_060_FULL.html#questions","title":"Questions","text":"<p>If you have questions during the course, please:</p> <ol> <li> <p>Search using Google or StackOverflow for ideas. You can often find a response faster than I will see your question and respond. </p> </li> <li> <p>Check the course forum on Canvas to see if the question has been asked</p> </li> <li> <p>If the question isn't private (such as a question about your grades), please post it in the discussion forums</p> </li> <li> <p>If it's a private matter, please email me at scott.stanchfield@jhu.edu. To comply with FERPA rules, please do not email me at my personal email address.</p> </li> </ol> <p>Please use the forums as much as possible for questions; many students often have the same questions and this makes it easy for everyone to learn.</p> <p>As you progress through the course, if you have comments about the content (things you really like, dislike, or how things can be done better), please post in the Course Feedback forum or keep a log of your thoughts to send to me after the course is finished. For those who are not enrolled in the course, please email me at scott@javadude.com with any comments or suggestions.</p> <p>If you have any questions or concerns while going through this course you may post them in the General Questions thread, located under Discussions on the left menu in Canvas or you may contact me directly at scott.stanchfield@jhu.edu. Additionally, you can refer to Help &amp; Support on the left menu for a listing of all the student services and support available to you.</p> <p>Here's to a great term! -- Scott</p>"},{"location":"modules/introduction/STEP_070_FULL.html","title":"Course Hardware and Software","text":""},{"location":"modules/introduction/STEP_070_FULL.html#hardware","title":"Hardware","text":"<p>You do not need an Android device for your coursework, but if you have access to one (or want to purchase one for your coursework), development feels more realistic.</p> <p>The minimum recommended RAM for Android Studio is 8GB RAM with an SSD. More memory is better, as Android Studio and the Android emulator love to use lots of memory. Ideally you'll have 16GB or more RAM.</p> <p>If you have only 8GB RAM, I strongly recommend you either upgrade your RAM or purchase an inexpensive Android phone for classwork. Many pay-as-you-go phones (which you do not have to activate) can be found for under $100 and will greatly improve your development experience. (Note, however, a physical device is not required for this course.)</p>"},{"location":"modules/introduction/STEP_070_FULL.html#software","title":"Software","text":"<p>The following are the required versions of tools for this term. </p> <p>Warning</p> <p>Do not upgrade any versions after the first module unless I instruct you to do so! I want to make sure we're using the same version of everything that you are when I grade your assignment submissions.</p> <p>Be sure to use the Kotlin DSL + Gradle Version Catalogs option for Build configuration language when creating new projects.</p> <p>Please double-check these versions when creating new projects!</p> Name Version Android StudioInstall via Jetbrains Toolbox Ladybug 2024.2.1 Patch 3 Gradle in <code>distributionUrl</code> in <code>gradle/wrapper/gradle-wrapper.properties</code> 8.9 Android Gradle Plugin<code>agp</code> in <code>gradle/libs.versions.toml</code> 8.7.3 Kotlin<code>kotlin</code> in <code>gradle/libs.versions.toml</code> 2.0.21 KSPwhen adding <code>ksp</code> in <code>gradle/libs.versions.toml</code> 2.0.21-1.0.28 Jetpack Compose Bill of Materials<code>compose_bom</code> in <code>gradle/libs.versions.toml</code> 2024.11.00 Android minimum APIminSdk in <code>app/build.gradle</code> 24 Android target APItargetSdk in <code>app/build.gradle</code> 35 Android compile APIcompileSdk in <code>app/build.gradle</code> 35"},{"location":"modules/introduction/STEP_070_FULL.html#sample-code","title":"Sample Code","text":"<p>See the \"Welcome\" module for download and usage instructions</p> <p>If you see any problems in the sample code, please let me know and I'll update it.</p>"},{"location":"modules/introduction/STEP_080_FULL.html","title":"Assignments","text":""},{"location":"modules/introduction/STEP_080_FULL.html#late-submissions","title":"Late Submissions","text":"<p>Late submissions will be reduced by one letter grade (1 point off 4-point assignments; 2 points off 8-pouint assignments) for each DAY (or partial day) late (no exceptions without timely prior coordination with the instructors). See the grading policy for assignment grading details.</p> <p>Note</p> <p>If you expect any issues with turning in work on time, please contact the instructor as soon as you know. If I know in advance about travel, expected high workloads or other issues, I can work with you. However, letting me know a day or two before an assignment is due is not acceptable (If an emergency occurs, please let me know as soon as possible afterwards.)</p> <p>Note</p> <p>If you encounter issues while trying to submit your assignment, please immediately send me an email with your submission zip and a note stating that Canvas is being your best friend. If you submit in this manner, I will not count your submission as late.</p> <p>Note that the easiest way to get a lower grade is to turn in your assignments late. If you know that something is coming up (business/vacation travel, expected very busy week at work, medical, expected baby) please let me know and I'm happy to work with you.</p>"},{"location":"modules/introduction/STEP_080_FULL.html#commit-often","title":"Commit Often!!!","text":"<p>Note: I highly recommend that you store your code in a version control system such as git. However, if you host your project on a public site like github, gitlab or bitbucket, you must make the repositories private! Any non-private repositories that I find online will automatically set your grade to \"F\" for sharing code.</p> <p>Be sure to control your source code! Lost code will not be accepted as an excuse for late or missing assignments.</p>"},{"location":"modules/introduction/STEP_080_FULL.html#general-guidelines-for-grade-ranges","title":"General guidelines for grade ranges","text":"<p>These are general guidelines, not absolute descriptions of a grading level. Your overall grade on an assignment depends on the overall quality and functionality of your submission. Again, these are general guidelines. You can get lower grades for very significant problems in your submissions and very late submissions.</p> Letter Grade Common Reasons for the Grade A On time ANDWorking ANDGood design B Missing required functionalityNot quite workingBad design/bad styleOne day late (but would have otherwise been an \"A\") C Many missing functionsWill not compileWill not execute properlyVery bad designOne day late (but would have been an \"B\")Two days late (but would have been an \"A\") F Little apparent effortPlagiarismThree or more days lateNot turned in <p>I grade on the following aspects of your submissions. Note that there is no specific percentage allocation for each of these concepts.</p> Aspect What I Look For Design Does the design use the patterns discussed in class properly?Does the design fit the problem?Is the program designed with a maintenance programmer in mind?Can I determine why you did things the way you did by reading code and comments? Function Is all required function present?Is any non-required function present? (grade deduction)Does present function work properly? Style and Coding Conventions Is the code readable?Can I easily figure out what it's doing just by reading the code?Does the code follow the required coding conventions?Note: Not following the required coding conventions, even once in a submission, maximizes your assignment grade at A- Timeliness Was the assignment submitted on time?one day late = 1-point grade deductiontwo days late = 2-point grade deduction... <p>Note</p> <p>I expect your assignments to follow the approaches I demonstrate in the class examples. When I see other approaches in your submissions, it sends up warning flags for me that you may be plagiarising (I've caught several students this way). I'll spend a good bit of time examining your code and online code that feels similar. Sometimes I'll notice approaches that I used to teach in previous terms, and then find a previous-student submission that matches.</p> <p>Please make my grading easier and your grades safer - follow the class example approaches and don't copy code from other students in previous or the current class sessions.</p> <p>Violation of the academic integrity policies will result in a minimum penalty of a 0 for the assignment in question, but there could be higher penalties depending on the circumstances.</p>"},{"location":"modules/introduction/STEP_080_FULL.html#coding-conventions","title":"Coding Conventions","text":"<p>All assignments must observe the following coding conventions.</p> <p>Why? I read your code</p> <p>Sometimes your code doesn't work correctly. Before I decide on the grade to give you, I carefully read the code to try to figure out why it didn't work. If the reason is a small, subtle thing, I'll often give more credit (rather than simply saying \"doesn't work; you get a C\") I often have to do this for multiple assignments. If the code is readable, using meaningful variable, method and class names, I can often find the problems more quickly.</p> <ul> <li> <p>Indentation must be consistent. Use either leading spaces or tabs, but not both!</p> </li> <li> <p>All type names must follow Upper-Camel Case:</p> <ul> <li><code>ShoppingCart</code></li> <li><code>ObjectDrawingApplet</code></li> </ul> </li> <li> <p>All Composable functions that generate user interfaces must follow Upper-Camel Case:</p> <ul> <li><code>MovieDisplayUi()</code></li> <li><code>SettingsUi()</code></li> </ul> </li> <li> <p>All variable and other function names must follow Lower-Camel Case:</p> <ul> <li><code>drawObject()</code></li> <li><code>numberOfObjectsOnScreen</code></li> </ul> </li> <li> <p>Type, variable and method names shall be a series of full words, not abbreviations or single letters.</p> <ul> <li>Standard acronyms are acceptable (such as <code>url</code> or <code>http</code>), but names like <code>c</code> are generally not acceptable. If you aren't sure whether a name is acceptable, feel free to ask me, but remember the rule of thumb: it should sound exactly like what it's being used for.</li> <li>Some Exceptions (based on common, understood usage)<ul> <li>integer counters in loops can be named <code>i</code>, <code>j</code>, <code>k</code></li> <li>the \"current number\" for walking through an array or counting items can be <code>n</code></li> <li><code>e</code> for an exception in a catch block</li> </ul> </li> </ul> </li> <li> <p>All classes and interfaces must be contained in a Kotlin package</p> </li> <li> <p>All Kotlin package names must be completely lower-case and start with <code>lastname.firstname.hw#</code> where the <code>#</code> is the homework number. For example, I might have a project named <code>stanchfield.scott.hw4</code> (with the same Android package name) that contains Kotlin packages:</p> <pre><code>stanchfield.scott.hw4\nstanchfield.scott.hw4.model\nstanchfield.scott.hw4.database\n</code></pre> </li> <li> <p>All projects must be named <code>HW1</code>, <code>HW2</code>, <code>HW3</code> and so forth</p> </li> <li> <p>All submission zip files must be named <code>lastname.firstname.HW1.zip</code>, <code>lastname.firstname.HW2.zip</code>, etc</p> </li> <li> <p>All string literals that would appear for the user (typically text in TextViews, dialogs, toasts, etc) must be externalized into the <code>strings.xml</code> file. This is a really good habit to get into upfront, and you should always do this in any application you create to make localization simpler.</p> </li> </ul> <p>Note</p> <p>This means all user-facing text. Any string constants that the user could see, whether used in your XML files or Kotlin code, must be externalized.</p>"},{"location":"modules/introduction/STEP_090_FULL.html","title":"Grading","text":""},{"location":"modules/introduction/STEP_090_FULL.html#points","title":"Points","text":"<p>Assignments are worth 4 or 8 points each, mapping to GPA letters.</p> <p>I assign letter grades first, then convert them to numbers and apply late penalties. The grading scale from letters to numbers is as follows:</p> Letter Grade Numerical Equivalent A 4.0 A- 3.7 (A/B border) 3.5 B+ 3.3 B 3.0 B- 2.7 (B/C border) 2.5 C+ 2.3 C 2.0 C- 1.7 (C/D border) 1.5 D+ 1.3 D 1.0 D- 0.7 F 0 <p>Note that there is no A+. I had been reserving that for \"exemplary\" submissions, but some students considered an \"A\" as lost points.</p> <p>When you see percents for your average grade, keep in mind that they map to the GPA letters, not the traditional percentage/letter mapping:</p> <ul> <li>100 = 4.0 = A</li> <li>75 = 3.0 = B</li> <li>50 = 2.0 = C</li> <li>25 = 1.0 = D</li> <li>0 = 0.0 = F</li> </ul> <p>This keeps the weight of each letter even, so an F (0) and an A (4) average out to a C, rather than a 0 and 100 averaging to 50 (which would be an F by the traditional scale).</p> <p>Your final grade WILL NOT include +/- designations. A/A- both count as \"A\" and \"4\" for University GPA purposes(and similar for other letter grades).</p>"},{"location":"modules/introduction/STEP_090_FULL.html#late-penalty","title":"Late Penalty","text":"<p>Each day late results in 1 full letter grade deduction (1 point off 4-point assignments; 2 points off 8-point assignments).</p> <p>When grading assignments, I will write comments describing your grade, but I will not note specific point-value deductions (see \"Holistic Grading\" below). Some comments are \"for your information\"/\"helpful hints\" and will be marked to indicate that they have no effect on the grade.</p> <p>If you disagree with a grade you can ask me to review it. Tell me what your concerns are and I'll look at it. Sometimes I may miss something in your code.</p> <p>If I note a problem with a submission that was also noted for a previous submission, I will not count off for it. (If I do, please let me know and I'll correct the grade.)</p>"},{"location":"modules/introduction/STEP_090_FULL.html#holistic-grading","title":"\"Holistic\" Grading","text":"<p>I started out using a rubric to grade. For many reasons, this almost never reflected reality. I came up with a much fairer scheme that I call \"holistic grading\".</p> <p>First, some problems with Rubrics...</p> <ul> <li> <p>Gaming the System</p> <p>When I had point counts next to features, many students would decide which features to implement based on how many points they felt they could afford to lose. Rather than implement all function (the point of which is to exercise important techniques), they would implement a subset just to \"get the grade\". This is frustrating for a teacher because we design exercises to be sure students have had the opportunity to try out important techniques.</p> </li> <li> <p>\"Sum of the Parts\" vs \"The Whole\"</p> <p>Rubrics tend to cut both ways when the points are added up...</p> <p>Sometimes, a few relatively minor things that don't greatly impact the overall submission would numerically push the grade into \"B\" territory or lower. This didn't feel fair to the student based on the overall result, but to be fair to all students I had to stick with the grade based off the rubric.</p> <p>Other times, small things that made an impact when combined could result in an \"A\" that didn't feel right (sometimes because of gaming the system, other times because the small problems really added up).</p> </li> <li> <p>\"That shouldn't be n points off\"</p> <p>The most common complaint would be that either the rubric was unfair in the number of points it assigned to a specific item, or that I was applying a rubric item too broadly to a problem in the submission. Most of the time I would leave the grade as-is, but in some cases it was a matter of a possible alternative interpretation of the assignment requirements, in which case I adjusted the points off.</p> <p>Later, after I stopped using rubrics, but would list points deductions on assignment comments, I'd get the same complaints.</p> <p>In either case, this never made any significant difference in the grade for the assignment, or the course.</p> <p>Students ended up spending a good bit of time trying to figure out which items they could argue to get a few points back, not realizing a few points over the term made no effective difference.</p> </li> </ul> <p>This led me to... \"Holistic Grading\" (If it sounds a little \"New Age\", it's not... \"Holistic\" here simply means \"looking at the whole\")</p> <p>\"This feels like a B+\"...</p> <p>I'll write comments about what I see in the assignment, and don't write specific deductions for each one.</p> <p>I look at the overall result, taking all comments into account, and say \"that's an A\", or \"that's a B-\", or \"that's barely anything more than the sample code\" (at which point I estimate the % of the assignment that was done and assign that number).</p> <p>The letters I assign are converted to numbers. A=4.0, A-=3.7, etc.</p> <p>When coming up with these letters, one of my key concepts is \"things that cap the grade at A-\". There's not a fixed list of such items, but things like \"coding conventions\" fall into this category. If several small things like these happen, a rubric may have pushed the grade into \"B\" territory. When I see several little things but otherwise the overall submission feels like an \"A\", I use \"A-\" as the grade.</p> <p>If the assignment does everything I ask, in the ways I taught in class, meets coding standards, and is on time, that's where \"A\" comes in.</p> <p>Other grades (before late deductions) are usually driven by</p> <ul> <li> <p>Feature omissions or problems</p> <p>Most common: something is missing or doesn't work properly</p> <p>This is often because a student started work a shor time before the assignment was due and didn't have time to ask questions or study the concepts.</p> </li> <li> <p>Crashes and compilation errors</p> <p>Note that I try to make your code work before grading it. Sometimes it's an inverted boolean expression, and if I can get it working and it's something simple, I'll give a better grade than \"doesn't work\".</p> <p>However, sometimes, after spending an hour or two trying to get it to work, I have to give up...</p> </li> <li> <p>Working together or Plagiarism</p> <p>I've caught many students doing this...</p> <p>Sometimes they even try to submit something they found online that doesn't match the assignment description or is very obviously not based on what I've taught.</p> </li> </ul> <p>Bottom line: When you see a \"3.7\" for a submission, don't think of it as \"0.3 points off\". Think of it as a few minor things aren't right and you got an A-. If that's how most of your assignments go, that's an overall \"A\" for the course...</p>"},{"location":"modules/introduction/STEP_090_FULL.html#distribution-of-grades","title":"Distribution of Grades","text":"<p>It is possible (and has happened in past sections) for everyone to get an \"A\" in this course. I will not be applying any sort of curve or other means to artificially distribute grades.</p> <p>I will be looking closely at your efforts in this class when determining your final grades. An \"A\" grade in this course requires a good deal of effort. Do not expect an \"A\" if you start programming a few nights before they are due...</p> <p>Let me repeat that. Do not expect an \"A\" if you start programming assignments a few nights before they are due... This has often been the reason for B and C grades in the course; students do not allow enough time to ask clarifying questions or do the coding.</p> <p>Be sure to at least look over and understand the assignments at the beginning of the week they are assigned! This will give you time to ask questions.</p> <p>If you do all the work well and on-time, you will get an \"A\" for the course. If you do all of the work on-time but are having trouble with the concepts, you'll likely get a \"B\" for the course. If you're in danger of a lower grade, I will speak with you as soon as it becomes apparent to me.</p>"},{"location":"modules/introduction/STEP_100_FULL.html","title":"Using Third-Party and Course Sample Code","text":""},{"location":"modules/introduction/STEP_100_FULL.html#using-third-party-code","title":"Using Third-Party Code","text":"<p>When writing your assignments, you may copy small sections of code and other content you find online if and only if you attribute it and the code is freely copyable with a license that says it's ok to copy. Place a comment above the copied section stating where you found it and the license that applies.</p>"},{"location":"modules/introduction/STEP_100_FULL.html#using-code-from-stackoverflow","title":"Using code from stackoverflow","text":"<p>If you're using code from stackoverflow, note that all code and content is licensed CREATIVE COMMONS - ATTRIBUTION - SHARE-ALIKE (CC-BY-SA 3.0).</p> <p>Warning</p> <p>THIS IS A VIRAL LICENSE!!!</p> <p>This means that any code/content you copy forces you to make your project be licensed CC-BY-SA 3.0!!! This is nearly always a no-no with companies you work for and the government!</p> <p>Note</p> <p>Some code or content may contain additional licenses. For example, when Googlers write code snippets on stackoverflow, they'll add something like</p> <pre><code>// Copyright 2023 Google LLC.\n// SPDX-License-Identifier: Apache-2.0\n</code></pre> <p>at the top of their code to indicate that it's also licensed under the Apache 2.0 license. </p> <p>In this case, it's ok to use the code as long as you adhere to the Apache 2.0 license.</p> <p>For your assignment submissions in this course, copying any content from stackoverflow is fine.</p> <p>In real life, unless the content has a more permissive license, such as Apache 2.0, do not copy code from stackoverflow!</p> <p>To use stackoverflow safely:</p> <ul> <li>Use \"clean room\" approach</li> <li>Read and understand</li> <li>Close the browser</li> <li>Then write your code</li> </ul>"},{"location":"modules/introduction/STEP_100_FULL.html#using-course-sample-code","title":"Using Course Sample Code","text":"<p>You may copy code from my class examples as well. Once again, you must attribute it. Add a comment at the top of your assignment submission source files that states that you're using sample code from the course.</p> <p>Code from the course sample code repository is licensed Apache 2 (see the LICENSE-code.md file in the repository) and can be used/incorporated into your own projects with attribution. Note that this code is generally not well-tested and likely contains bugs. If you find something that doesn't work, please let me know and I'll update the samples.</p> <p>Code that I write live in face-to-face class or post in a discussion forum is not licensed for any use outside this class. You may not post or distribute any this code for any purpose other than writing your assignments.</p>"},{"location":"modules/kotlin-primer/index.html","title":"Video","text":"<p>Kotlin is a fantastic new language that we'll be using to create our Android Applications. In this module, we'll quickly explore the basics of the language from a Java perspective.</p> <p>During the rest of the course, I'll often explain some of these concepts in more detail.</p> <p>Note</p> <p>You can change the quality and playback speed by clicking the  icon when the video is playing. </p> <p>If you would like to search the captions for this video, click Watch on YouTube, press \"...\" and choose Show Transcript.</p>"},{"location":"modules/kotlin-primer/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/kotlin-primer. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>kotlin-primer</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/kotlin-primer\n</code></pre>"},{"location":"modules/legacy-views/index.html","title":"Video","text":"<p>We've talked about Jetpack Compose for the entire class, but it's likely that you'll probably see code that uses the old \"views\" system.</p> <p>In this module, we'll explore view-based user interfaces. The videos contained here are from an older (Summer 2020) face-to-face term, before I converted the content to use Jetpack Compose. I started to write textual content but realized it would be more valuable to make the older videos available. Note that this is a lot of content, but you can select topics you're interested in from the playlist.</p> <p>Note</p> <p>I've updated the examples to use the most recent dependencies and build structure</p> <p>Note</p> <p>None of this content will be used in any assignments; it is only here for your information.</p> <p>Note</p> <p>The \"Room\" videos in this batch are similar in content to the Room material on this site, but use <code>LiveData</code> for asynchronous data fetching rather than Kotlin <code>Flow</code>.</p> <p>Video Playlist: https://www.youtube.com/playlist?list=PLW-6wqFEcgTpc2rBCGhyFNksqaG0OhlvJ</p>"},{"location":"modules/legacy-views/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/legacy-views. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>legacy-views</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/legacy-views\n</code></pre>"},{"location":"modules/movie-db/index.html","title":"Overview","text":"<p>We'll enhance our Movie application with a database to store our movies. For now, it's just read-only, but as we add features to the UI we'll add more functionality to the database to support them.</p>"},{"location":"modules/movie-db/STEP_020_REPO.html","title":"Add new modules","text":"<p>Note</p> <p>You will not need to add any code manually in this step. The displayed diffs are here to show you what gets added when you add the new modules.</p> <p>We start with the basic Movie UI created in Initial Movies UI.</p> <p>The first thing we need to do is add two modules, <code>data</code> and <code>repository</code>. You can name these anything you'd like, but I recommend these names as they represent what you're doing pretty well.</p> <p>To create these modules:</p> <ol> <li>Right-click the top-level project in the Project view</li> <li> <p>Choose New -&gt; Module</p> <p></p> </li> <li> <p>Select the Android Library template</p> <p>Note</p> <p>We choose Android Library here because we'll be using Room, which requires Android dependencies such as a context to create the database instance. If the module did not have any Android dependencies, we could instead create a Java or Kotlin Library module.</p> </li> <li> <p>Enter <code>data</code> as the Module name</p> </li> <li> <p>Update the Package name to lastname.firstname.appname.data</p> <p></p> </li> <li> <p>Press Finish</p> </li> <li> <p>Press Add to add the newly-created files to git</p> <p></p> </li> </ol> <p>Repeat for the <code>repository</code> module.</p> <p>Delete the <code>libs</code> directory in each module (<code>app</code>, <code>data</code>, and <code>repository</code>). This is used to host local copies of jars rather than import them from external repositories or other modules in your project.</p> <p>Note that <code>settings.gradle.kts</code> (at the top level of your project) has been updated to add the two new modules. This is how gradle (and Android Studio) know that these are modules it needs to build.</p> <pre><code>include(\":app\")\ninclude(\":data\")\ninclude(\":repository\")\n</code></pre> All code changes CHANGED: build.gradle.kts <pre>// Top-level build file where you can add configuration options common to all sub-projects/modules.\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.android) apply false\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.android.library) apply false\n}\n</pre> ADDED: data/.gitignore <pre>/build\n</pre> ADDED: data/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.data\"\n    compileSdk = 34\n\n    defaultConfig {\n        minSdk = 24\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre> ADDED: data/src/androidTest/java/com/androidbyexample/compose/movies/data/ExampleInstrumentedTest.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.test.platform.app.InstrumentationRegistry\nimport androidx.test.ext.junit.runners.AndroidJUnit4\n\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\nimport org.junit.Assert.*\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\n@RunWith(AndroidJUnit4::class)\nclass ExampleInstrumentedTest {\n    @Test\n    fun useAppContext() {\n        // Context of the app under test.\n        val appContext = InstrumentationRegistry.getInstrumentation().targetContext\n        assertEquals(\"com.androidbyexample.compose.movies.data.test\", appContext.packageName)\n    }\n}\n</pre> ADDED: data/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n&lt;/manifest&gt;\n</pre> ADDED: data/src/test/java/com/androidbyexample/compose/movies/data/ExampleUnitTest.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport org.junit.Test\n\nimport org.junit.Assert.*\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\nclass ExampleUnitTest {\n    @Test\n    fun addition_isCorrect() {\n        assertEquals(4, 2 + 2)\n    }\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\n\n</pre> ADDED: repository/.gitignore <pre>/build\n</pre> ADDED: repository/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.repository\"\n    compileSdk = 34\n\n    defaultConfig {\n        minSdk = 24\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre> ADDED: repository/src/androidTest/java/com/androidbyexample/compose/movies/repository/ExampleInstrumentedTest.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport androidx.test.platform.app.InstrumentationRegistry\nimport androidx.test.ext.junit.runners.AndroidJUnit4\n\nimport org.junit.Test\nimport org.junit.runner.RunWith\n\nimport org.junit.Assert.*\n\n/**\n * Instrumented test, which will execute on an Android device.\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\n@RunWith(AndroidJUnit4::class)\nclass ExampleInstrumentedTest {\n    @Test\n    fun useAppContext() {\n        // Context of the app under test.\n        val appContext = InstrumentationRegistry.getInstrumentation().targetContext\n        assertEquals(\"com.androidbyexample.compose.movies.repository.test\", appContext.packageName)\n    }\n}\n</pre> ADDED: repository/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n&lt;/manifest&gt;\n</pre> ADDED: repository/src/test/java/com/androidbyexample/compose/movies/repository/ExampleUnitTest.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport org.junit.Test\n\nimport org.junit.Assert.*\n\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * See [testing documentation](http://d.android.com/tools/testing).\n */\nclass ExampleUnitTest {\n    @Test\n    fun addition_isCorrect() {\n        assertEquals(4, 2 + 2)\n    }\n}\n</pre> CHANGED: settings.gradle.kts <pre>pluginManagement {\n    repositories {\n        google {\n            content {\n                includeGroupByRegex(\"com\\\\.android.*\")\n                includeGroupByRegex(\"com\\\\.google.*\")\n                includeGroupByRegex(\"androidx.*\")\n            }\n        }\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\nrootProject.name = \"Movies\"\ninclude(\":app\")\n//\ninclude(\":data\")\ninclude(\":repository\")\n</pre>"},{"location":"modules/movie-db/STEP_030_REPO.html","title":"Add Room dependencies","text":"<p>Next we add the Room dependencies and the Kotlin Symbol Processor (KSP).</p> <p>The Kotlin Symbol Processor is a compiler plugin that loads \"symbol processors\". These processors examine your source code and create new classes as needed, typically looking at annotations in your code. The Room compiler is a symbol processor that generates code based on Room annotations like <code>@Entity</code> and <code>@Database</code>.</p> <p>We add the KSP and Room versions, the Room compiler and runtime libraries, and the KSP plugin</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\n\n[libraries]\n// ...\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\n// ...\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n</pre> <p>Note</p> <p>When choosing a KSP version, you must select a version that starts with the same version as Kotlin. This is because the Kotlin compiler plugin API changes frequently, and compiler plugins such as KSP must match the compiler API. </p> <p>As I'm writing this, the latest version of Kotlin is 2.0.21. Looking at https://github.com/google/ksp/releases, you'll see all available KSP releases, and must choose one that starts with the same version of Kotlin you're using. At this point, the latest matching version of KSP is 2.0.21-1.0.28.</p> <p>We want to specify the version of plugins to use in one place, in case they're used in multiple modules. We do this by adding the plugin to the top-level <code>build.gradle.kts</code>, but don't apply it (so it doesn't actually do anything there other than specify the version to use).</p> show in full file  build.gradle.kts <pre>// ...\nplugins {\n    // ...\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.android.library) apply false\n    alias(libs.plugins.ksp) apply false\n}</pre> <p>Then we tell the <code>data</code> module to apply the KSP plugin and set up the Room dependencies.</p> show in full file  data/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.ksp)\n}\n\n// ...\ndependencies {\n    // ...\n    implementation(libs.material)\n\n    implementation(libs.room.runtime)\n    implementation(libs.room.ktx)\n    ksp(libs.room.compiler)\n\n    testImplementation(libs.junit)\n    // ...\n}</pre> <p>The <code>implementation</code> dependencies will be available for compilation and included in the built application. The <code>ksp</code> dependency will only be added to the classpath used by KSP as a symbol processor to generate code based on the Room annotations.</p> <p>We're only using Room in the <code>data</code> module, so we don't need to add these dependencies in the <code>repository</code> module's <code>build.gradle.kts</code> file.</p> <p>Remember after changing the version catalog and gradle build files to re-synchronize by pressing the elephant icon (or the \"Sync Now\" link at the top of the build files)!</p> <p>At this point, nothing will visibly change in the application, but it should still build and run.</p> All code changes CHANGED: build.gradle.kts <pre>// Top-level build file where you can add configuration options common to all sub-projects/modules.\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.android) apply false\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.android.library) apply false\n    alias(libs.plugins.ksp) apply false\n}\n</pre> CHANGED: data/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.ksp)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.data\"\n    compileSdk = 34\n\n    defaultConfig {\n        minSdk = 24\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n\n    implementation(libs.room.runtime)\n    implementation(libs.room.ktx)\n    ksp(libs.room.compiler)\n\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n\n</pre>"},{"location":"modules/movie-db/STEP_035_REPO.html","title":"Add Android SDK and JDK to version catalog","text":"<p>Each of the modules contains its own <code>build.gradle.kts</code>. There are several versions listed in these modules, and it's a good idea to keep them in sync. To do this, we'll add them to our version catalog and reference them in the build scripts.</p> <p>First, we add the versions we want to use to the version catalog. Note that you should use the versions specified in Course Hardware and Software.</p> <p>We can do something similar for the Java versions</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nksp = \"2.0.21-1.0.28\"\n\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\n\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\n\n[libraries]\n// ...\n[plugins]\n// ...</pre> <p>Now we replace the hardcoded versions in <code>app/build.gradle.kts</code>, <code>data/build.gradle.kts</code>, and <code>repository/build.gradle.kts</code>. The changes in all three files will look the same.</p> show in full file  app/build.gradle.kts <pre>// ...\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n//  compileSdk = 35\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n//      minSdk = 24\n//      targetSdk = 35\n        minSdk = libs.versions.minSdk.get().toInt()\n        targetSdk = libs.versions.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n        // ...\n    }\n    // ...\n    }\n    compileOptions {\n//      sourceCompatibility = JavaVersion.VERSION_11\n//      targetCompatibility = JavaVersion.VERSION_11\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n//      jvmTarget = \"11\"\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n    buildFeatures {\n        // ...\n}\n// ...</pre> <p>This helps ensure consistency and reduce maintenance burden over time.</p> <p>At this point, nothing will visibly change in the application, but it should still build and run.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n//  compileSdk = 35\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n//      minSdk = 24\n//      targetSdk = 35\n        minSdk = libs.versions.minSdk.get().toInt()\n        targetSdk = libs.versions.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n//      sourceCompatibility = JavaVersion.VERSION_11\n//      targetCompatibility = JavaVersion.VERSION_11\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n//      jvmTarget = \"11\"\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n</pre> CHANGED: data/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.ksp)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.data\"\n//  compileSdk = 34\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n//      minSdk = 24\n        minSdk = libs.versions.minSdk.get().toInt()\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n//      sourceCompatibility = JavaVersion.VERSION_11\n//      targetCompatibility = JavaVersion.VERSION_11\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n//      jvmTarget = \"11\"\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n\n    implementation(libs.room.runtime)\n    implementation(libs.room.ktx)\n    ksp(libs.room.compiler)\n\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\n\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\n\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n\n</pre> CHANGED: repository/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.repository\"\n//  compileSdk = 34\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n//      minSdk = 24\n        minSdk = libs.versions.minSdk.get().toInt()\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n//      sourceCompatibility = JavaVersion.VERSION_11\n//      targetCompatibility = JavaVersion.VERSION_11\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n//      jvmTarget = \"11\"\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre>"},{"location":"modules/movie-db/STEP_040_REPO.html","title":"Module Dependencies","text":"<p>Now we need to tell the modules how they depend on each other.</p> <pre><code>flowchart LR\n    subgraph User Interface Layer\n    ui[Module: app\\n]\n    end\n    ui --&gt; repo\n    subgraph Data Layer\n    repo[Module: repository]\n    ds[Module: data]\n    repo --&gt; ds\n    end</code></pre> <p>We set up these dependencies by using <code>implementation project(\":xyz\")</code> in our dependencies.</p> <ul> <li>Add the <code>data</code> module as a dependency in the <code>repository</code> module</li> <li>Add the <code>repository</code> module as a dependency in the <code>app</code> module</li> </ul> show in full file  repository/build.gradle.kts <pre>// ...\n\ndependencies {\n    implementation(project(\":data\"))\n\n    implementation(libs.androidx.core.ktx)\n    // ...\n}</pre> show in full file  app/build.gradle.kts <pre>// ...\n\ndependencies {\n    implementation(project(\":repository\"))\n\n    implementation(libs.androidx.core.ktx)\n    // ...\n}</pre> <p>Dependencies can be specified as implementation dependencies or api dependencies.</p> <p>Implementation dependencies are only available within the module that declares them. API dependencies become part of the API of the current module and are made available to any module that depends on the current module.</p> <p>Normally, you should choose the implementation dependency type so modules can hide their implementation dependencies. This also improves build speed, as changes to implementation dependencies are not inherited, and won't trigger a rebuild of modules that depend on the current module.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n        minSdk = libs.versions.minSdk.get().toInt()\n        targetSdk = libs.versions.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(project(\":repository\"))\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n</pre> CHANGED: repository/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.repository\"\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        minSdk = libs.versions.minSdk.get().toInt()\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n}\n\ndependencies {\n    implementation(project(\":data\"))\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre>"},{"location":"modules/movie-db/STEP_050_REPO.html","title":"Entities, DAO and Database","text":"<p>Let's define the Entities, DAO and Database using Room.</p> <p>Here's our schema</p> <pre><code>erDiagram\n    RATING ||--o{ MOVIE: movies\n    MOVIE ||--o{ ROLE : cast\n    ROLE }o--|| ACTOR : appearance</code></pre> <p>What does this mean?</p> <ul> <li> <p>RATING &lt;-&gt; MOVIE is a one-to-many relationship</p> <ul> <li>A RATING can be associated with zero or more MOVIEs</li> <li>A MOVIE has exactly one RATING</li> </ul> </li> <li> <p>MOVIE &lt;-&gt; ACTOR is a many-to-many relationship</p> <ul> <li>An ACTOR can appear in zero or more MOVIEs</li> <li>A MOVIE can cast zero or more ACTORs</li> <li>To implement this, we introduce an associative entity ROLE with a one-to-many relationship on each side<ul> <li>A MOVIE can cast zero or more ROLEs</li> <li>An ACTOR can appear in zero or more ROLEs</li> <li>A ROLE can appear in exactly one MOVIE</li> <li>A ROLE is played by exactly one ACTOR</li> </ul> </li> </ul> </li> </ul> <p>Let's look at the attributes of each entity. All entities are represented as Kotlin data classes.</p>"},{"location":"modules/movie-db/STEP_050_REPO.html#naming","title":"Naming","text":"<p>There will be a different types of classes used in this application:</p> <ul> <li>Database entities: the objects that represent rows in a database. We'll use the suffix     \"Entity\" for these.</li> <li>Data-layer Plain-Old-Kotlin-Objects (POKOs): helper objects for retrieving data (or partial     data) from entities. For example, a POKO may retrieve a Rating with a list of all Movies taggged     with that Rating. We won't use a suffix for these.  </li> <li>Data transfer objects: representations of the data from the <code>data</code> module exposed by the     <code>repository</code> module. This hides the fact that the data is coming from a database, as the     repository could be returning it from anywhere.  We're creating a abstraction that doesn't      leak the underlying implementation details to the user-interface layer. We'll use the suffix     \"Dto\" for these.</li> </ul>"},{"location":"modules/movie-db/STEP_050_REPO.html#ratingentity","title":"RatingEntity","text":"<p>Represents an MPAA rating (G, PG, PG-13, R, NR)</p> Attribute Type Key id String PK name String description String <p>We define <code>RatingEntity</code> and a POKO to gather a rating and all of its movies at the same time. Note that this POKO represents a ONE-TO-MANY relation. </p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/RatingEntity.kt <pre>// ...\nimport java.util.UUID\n\n@Entity\ndata class RatingEntity(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var description: String,\n)\n// ONE-TO-MANY relationship (Rating -&gt; Movies)\n// NOTE: THIS IS NOT AN ENTITY!\ndata class RatingWithMovies(\n    @Embedded\n    val rating: RatingEntity,\n    @Relation(\n        parentColumn = \"id\",\n        entityColumn = \"ratingId\",\n    )\n    val movies: List&lt;MovieEntity&gt;\n)</pre>"},{"location":"modules/movie-db/STEP_050_REPO.html#actorentity","title":"ActorEntity","text":"<p>An actor that can appear in movies</p> Attribute Type Key Comment id String PK name String <p>We define an <code>ActorEntity</code> and two POKOs to gather an actor and all associated movies at the same time. Note that these POKOs represent a MANY-TO-MANY relation, gathering the association data in the <code>RoleEntity</code> by treating it as a ONE-TO-MANY relation and a MANY-TO-ONE relation. The <code>RoleEntity</code> is the MANY part in the middle.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/ActorEntity.kt <pre>// ...\nimport java.util.UUID\n\n@Entity\ndata class ActorEntity(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n)\n// POKO that groups an Actor with the movies they appear in, and the\n//   role played in each movie. This is a ONE-TO-MANY relation from the\n//   ActorEntity to the RoleEntity, where we resolve the RoleEntity's movieId\n//   to fetch the actual movie (a MANY-TO-ONE relation). The end result is turning\n//   a MANY-TO-MANY relation into two ONE-TO-MANY relationships, where the MANY part\n//   is the RoleEntity.\ndata class ActorWithFilmography(\n    @Embedded\n    val actor: ActorEntity,\n    @Relation(\n        entity = RoleEntity::class,\n        parentColumn = \"id\",\n        entityColumn = \"actorId\",\n    )\n    val rolesWithMovies: List&lt;RoleWithMovie&gt;,\n)\ndata class RoleWithMovie(\n    @Embedded\n    val role: RoleEntity,\n    @Relation(\n        parentColumn = \"movieId\",\n        entityColumn = \"id\"\n    )\n    val movie: MovieEntity,\n)</pre>"},{"location":"modules/movie-db/STEP_050_REPO.html#movieentity","title":"MovieEntity","text":"<p>A movie</p> Attribute Type Key id String PK title String description String ratingId String FK <p>We define <code>MovieEntity</code> and two POKOs to gather a movie and all associated actors at the same time. Note that these POKOs represent a MANY-TO-MANY relation, gathering the association data in the <code>RoleEntity</code> by treating it as a ONE-TO-MANY relation and a MANY-TO-ONE relation. The <code>RoleEntity</code> is the MANY part in the middle.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieEntity.kt <pre>// ...\n//   Rating key, we update that key in all associated movies.\n\n@Entity(\n    indices = [\n        Index(value = [\"ratingId\"])\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = RatingEntity::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"ratingId\"],\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE,\n        )\n    ]\n)\ndata class MovieEntity(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var title: String,\n    var description: String,\n    var ratingId: String,\n)\n// POKO that groups a Movie with the actors that appear in it, and the\n//   role played in the movie. This is a ONE-TO-MANY relation from the\n//   MovieEntity to the RoleEntity, where we resolve the RoleEntity's actorId\n//   to fetch the actual actor (a MANY-TO-ONE relation). The end result is turning\n//   a MANY-TO-MANY relation into two ONE-TO-MANY relationships, where the MANY part\n//   is the RoleEntity.\ndata class MovieWithCast(\n    @Embedded\n    val movie: MovieEntity,\n    @Relation(\n        entity = RoleEntity::class,\n        parentColumn = \"id\",\n        entityColumn = \"movieId\",\n    )\n    val rolesWithActors: List&lt;RoleWithActor&gt;,\n)\ndata class RoleWithActor(\n    @Embedded\n    val role: RoleEntity,\n    @Relation(\n        parentColumn = \"actorId\",\n        entityColumn = \"id\"\n    )\n    val actor: ActorEntity,\n)</pre>"},{"location":"modules/movie-db/STEP_050_REPO.html#roleentity","title":"RoleEntity","text":"<p>Association entity that casts actors into movies</p> Attribute Type Key movieId String FK actorId String FK character String orderInCredits int <p>We define <code>RoleEntity</code> to hold the MANY-TO-MANY relation data between <code>MovieEntity</code> and <code>ActorEntity</code>. It holds additional association data describing how the movies and actors are related. Gathering the many-to-many data would be simpler if we weren't interested in the association data. However, to access the association data we'll have to use it at the center to two MANY-TO-ONE relations. See <code>MovieEntity</code> and <code>ActorEntity</code> above for how this works.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/RoleEntity.kt <pre>// ...\n//    either parent's key is updated, we update this entity.\n\n@Entity(\n    primaryKeys = [\"actorId\", \"movieId\"],\n    indices = [\n        Index(\"movieId\"),\n        Index(\"actorId\")\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = MovieEntity::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"movieId\"],\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE,\n        ),\n        ForeignKey(\n            entity = ActorEntity::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"actorId\"],\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE,\n        )\n    ]\n)\ndata class RoleEntity(\n    var movieId: String,\n    var actorId: String,\n    var character: String,\n    var orderInCredits: Int,\n)</pre>"},{"location":"modules/movie-db/STEP_050_REPO.html#moviedao","title":"MovieDao","text":"<p>We start with a DAO that has basic create and read operations. We'll make it an abstract class so we can define a concrete implementation for <code>resetDatabase()</code>.</p> <p>All basic query functions immediately return a <code>Flow</code> that we'll collect inside a coroutine. When the data is fetched, it will emit the result to the <code>Flow</code>. If the data changes, the queries will re-execute and emit the new data to the previously-returned <code>Flow</code>.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>// ...\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class MovieDao {\n    @Query(\"SELECT * FROM RatingEntity\")\n    abstract fun getRatingsFlow(): Flow&lt;List&lt;RatingEntity&gt;&gt;\n    @Query(\"SELECT * FROM MovieEntity\")\n    abstract fun getMoviesFlow(): Flow&lt;List&lt;MovieEntity&gt;&gt;\n    @Query(\"SELECT * FROM ActorEntity\")\n    abstract fun getActorsFlow(): Flow&lt;List&lt;ActorEntity&gt;&gt;\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract suspend fun getRatingWithMovies(id: String): RatingWithMovies\n    @Transaction\n    @Query(\"SELECT * FROM ActorEntity WHERE id = :id\")\n    abstract suspend fun getActorWithFilmography(id: String): ActorWithFilmography\n    @Transaction\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Insert\n    abstract suspend fun insert(vararg ratings: RatingEntity)\n    @Insert\n    abstract suspend fun insert(vararg movies: MovieEntity)\n    @Insert\n    abstract suspend fun insert(vararg actors: ActorEntity)\n    @Insert\n    abstract suspend fun insert(vararg roles: RoleEntity)\n    @Query(\"DELETE FROM MovieEntity\")\n    abstract suspend fun clearMovies()\n    @Query(\"DELETE FROM ActorEntity\")\n    abstract suspend fun clearActors()\n    @Query(\"DELETE FROM RatingEntity\")\n    abstract suspend fun clearRatings()\n    @Query(\"DELETE FROM RoleEntity\")\n    abstract suspend fun clearRoles()\n    @Transaction\n    open suspend fun resetDatabase() {\n        clearMovies()\n        clearActors()\n        clearRoles()\n        clearRatings()\n        insert(\n            RatingEntity(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            RatingEntity(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            RatingEntity(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            RatingEntity(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            RatingEntity(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n        insert(\n            MovieEntity(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            MovieEntity(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            MovieEntity(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            MovieEntity(\"m4\", \"Jumanji - Welcome to the Jungle\", \"The Rock smolders\", \"r3\"),\n        )\n        insert(\n            ActorEntity(\"a1\", \"Jason Statham\"),\n            ActorEntity(\"a2\", \"The Rock\"),\n            ActorEntity(\"a3\", \"Shu Qi\"),\n            ActorEntity(\"a4\", \"Amber Valletta\"),\n            ActorEntity(\"a5\", \"Kevin Hart\"),\n        )\n        insert(\n            RoleEntity(\"m1\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m1\", \"a3\", \"Lai\", 2),\n            RoleEntity(\"m2\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            RoleEntity(\"m3\", \"a2\", \"Hobbs\", 1),\n            RoleEntity(\"m3\", \"a1\", \"Shaw\", 2),\n            RoleEntity(\"m4\", \"a2\", \"Spencer\", 1),\n            RoleEntity(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n    }\n}\n</pre> <p>Note that functions <code>getRatingWithMovies()</code>, <code>getActorWithFilmography()</code>, and<code>getMovieWithCast()</code> are declared as one-shot functions. For now, this is fine, but it will become an issue later when we allow data updates from the UI.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>// ...\n\n@Dao\nabstract class MovieDao {\n    // ...\n    abstract fun getActorsFlow(): Flow&lt;List&lt;ActorEntity&gt;&gt;\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract suspend fun getRatingWithMovies(id: String): RatingWithMovies\n    @Transaction\n    @Query(\"SELECT * FROM ActorEntity WHERE id = :id\")\n    abstract suspend fun getActorWithFilmography(id: String): ActorWithFilmography\n    @Transaction\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Insert\n    // ...\n}\n// ...</pre> <p>The problem is that because we're not fetching these data using a <code>Flow</code>, there's no way for the database to send us updated data when the data behind the scenes changes. This will lead to stale data on the screen. For example, if we display a movie with its cast, and delete a cast entry, the entry will be removed from the database, but still be visible on the screen unless we do something manual (ewwwww) to update it. Later we'll switch to using <code>Flow</code>s for these queries, but for now, I want to demonstrate how you can use a controlled-side effect inside a composable function to fetch data (and demonstrate why this can lead to stale data).</p> <p>Functions like these that return POKOs that use <code>@Relation</code> will run multiple queries and must be annotated with <code>@Transaction</code>.</p> <p>Later we'll add update and delete functionality. For now, the only updating we'll do is insert initial data.</p>"},{"location":"modules/movie-db/STEP_050_REPO.html#moviedatabase","title":"MovieDatabase","text":"<p>A very typical Room database declaration.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDatabase.kt <pre>// ...\nimport androidx.room.RoomDatabase\n\n@Database(\n    version = 1,\n    entities = [\n        MovieEntity::class,\n        ActorEntity::class,\n        RoleEntity::class,\n        RatingEntity::class,\n    ],\n    exportSchema = false\n)\nabstract class MovieDatabase: RoomDatabase() {\n    abstract val dao: MovieDao\n}</pre> <p>The database will contain Movie, Actor, Role and Rating entities and expose a MovieDao.</p>"},{"location":"modules/movie-db/STEP_050_REPO.html#databasebuilderkt","title":"DatabaseBuilder.ktAll code changes","text":"<p>This Kotlin file hosts a single function that we'll use to create an instance of the database.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/DatabaseBuilder.kt <pre>// ...\nimport androidx.room.Room\n\nfun createDao(context: Context) =\n    Room.databaseBuilder(\n        context,\n        MovieDatabase::class.java,\n        \"MOVIES\"\n    )\n// uncomment the following to see the SQL queries that are run\n//        .setQueryCallback(\n//            { sqlQuery, bindArgs -&gt;\n//                Log.d(\"!!!SQL\", \"SQL Query: $sqlQuery SQL Args: $bindArgs\")\n//            }, Executors.newSingleThreadExecutor()\n//        )\n        .build()\n        .dao</pre> <p>Defining this function here, in the <code>data</code> module, avoids the need to make the <code>repository</code> module depend on Room just to create the database instance.</p> <p>Note that if you want to see the SQL queries that are being run, you can uncomment the <code>setQueryCallback</code> call and look at the Logcat view at the bottom of Android Studio.</p> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/ActorEntity.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Embedded\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.Relation\nimport java.util.UUID\n\n@Entity\ndata class ActorEntity(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n)\n// POKO that groups an Actor with the movies they appear in, and the\n//   role played in each movie. This is a ONE-TO-MANY relation from the\n//   ActorEntity to the RoleEntity, where we resolve the RoleEntity's movieId\n//   to fetch the actual movie (a MANY-TO-ONE relation). The end result is turning\n//   a MANY-TO-MANY relation into two ONE-TO-MANY relationships, where the MANY part\n//   is the RoleEntity.\ndata class ActorWithFilmography(\n    @Embedded\n    val actor: ActorEntity,\n    @Relation(\n        entity = RoleEntity::class,\n        parentColumn = \"id\",\n        entityColumn = \"actorId\",\n    )\n    val rolesWithMovies: List&lt;RoleWithMovie&gt;,\n)\ndata class RoleWithMovie(\n    @Embedded\n    val role: RoleEntity,\n    @Relation(\n        parentColumn = \"movieId\",\n        entityColumn = \"id\"\n    )\n    val movie: MovieEntity,\n)\n</pre> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/DatabaseBuilder.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport android.content.Context\nimport androidx.room.Room\n\nfun createDao(context: Context) =\n    Room.databaseBuilder(\n        context,\n        MovieDatabase::class.java,\n        \"MOVIES\"\n    )\n// uncomment the following to see the SQL queries that are run\n//        .setQueryCallback(\n//            { sqlQuery, bindArgs -&gt;\n//                Log.d(\"!!!SQL\", \"SQL Query: $sqlQuery SQL Args: $bindArgs\")\n//            }, Executors.newSingleThreadExecutor()\n//        )\n        .build()\n        .dao\n</pre> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class MovieDao {\n    @Query(\"SELECT * FROM RatingEntity\")\n    abstract fun getRatingsFlow(): Flow&lt;List&lt;RatingEntity&gt;&gt;\n    @Query(\"SELECT * FROM MovieEntity\")\n    abstract fun getMoviesFlow(): Flow&lt;List&lt;MovieEntity&gt;&gt;\n    @Query(\"SELECT * FROM ActorEntity\")\n    abstract fun getActorsFlow(): Flow&lt;List&lt;ActorEntity&gt;&gt;\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract suspend fun getRatingWithMovies(id: String): RatingWithMovies\n    @Transaction\n    @Query(\"SELECT * FROM ActorEntity WHERE id = :id\")\n    abstract suspend fun getActorWithFilmography(id: String): ActorWithFilmography\n    @Transaction\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Insert\n    abstract suspend fun insert(vararg ratings: RatingEntity)\n    @Insert\n    abstract suspend fun insert(vararg movies: MovieEntity)\n    @Insert\n    abstract suspend fun insert(vararg actors: ActorEntity)\n    @Insert\n    abstract suspend fun insert(vararg roles: RoleEntity)\n    @Query(\"DELETE FROM MovieEntity\")\n    abstract suspend fun clearMovies()\n    @Query(\"DELETE FROM ActorEntity\")\n    abstract suspend fun clearActors()\n    @Query(\"DELETE FROM RatingEntity\")\n    abstract suspend fun clearRatings()\n    @Query(\"DELETE FROM RoleEntity\")\n    abstract suspend fun clearRoles()\n    @Transaction\n    open suspend fun resetDatabase() {\n        clearMovies()\n        clearActors()\n        clearRoles()\n        clearRatings()\n        insert(\n            RatingEntity(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            RatingEntity(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            RatingEntity(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            RatingEntity(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            RatingEntity(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n        insert(\n            MovieEntity(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            MovieEntity(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            MovieEntity(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            MovieEntity(\"m4\", \"Jumanji - Welcome to the Jungle\", \"The Rock smolders\", \"r3\"),\n        )\n        insert(\n            ActorEntity(\"a1\", \"Jason Statham\"),\n            ActorEntity(\"a2\", \"The Rock\"),\n            ActorEntity(\"a3\", \"Shu Qi\"),\n            ActorEntity(\"a4\", \"Amber Valletta\"),\n            ActorEntity(\"a5\", \"Kevin Hart\"),\n        )\n        insert(\n            RoleEntity(\"m1\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m1\", \"a3\", \"Lai\", 2),\n            RoleEntity(\"m2\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            RoleEntity(\"m3\", \"a2\", \"Hobbs\", 1),\n            RoleEntity(\"m3\", \"a1\", \"Shaw\", 2),\n            RoleEntity(\"m4\", \"a2\", \"Spencer\", 1),\n            RoleEntity(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n    }\n}\n\n</pre> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/MovieDatabase.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(\n    version = 1,\n    entities = [\n        MovieEntity::class,\n        ActorEntity::class,\n        RoleEntity::class,\n        RatingEntity::class,\n    ],\n    exportSchema = false\n)\nabstract class MovieDatabase: RoomDatabase() {\n    abstract val dao: MovieDao\n}\n</pre> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/MovieEntity.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Embedded\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\nimport androidx.room.PrimaryKey\nimport androidx.room.Relation\nimport java.util.UUID\n\n// Movie Entity - note that we set up a foreign key relationship with RatingEntity,\n//   which is considered the owner of movies with that rating. (Probably not the best\n//   way to represent this relationship, but I wanted to demonstrate a one-to-many\n//   relationship with cascading deletion.\n//   If we delete a Rating, we delete all associated movies. If we update the\n//   Rating key, we update that key in all associated movies.\n\n@Entity(\n    indices = [\n        Index(value = [\"ratingId\"])\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = RatingEntity::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"ratingId\"],\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE,\n        )\n    ]\n)\ndata class MovieEntity(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var title: String,\n    var description: String,\n    var ratingId: String,\n)\n// POKO that groups a Movie with the actors that appear in it, and the\n//   role played in the movie. This is a ONE-TO-MANY relation from the\n//   MovieEntity to the RoleEntity, where we resolve the RoleEntity's actorId\n//   to fetch the actual actor (a MANY-TO-ONE relation). The end result is turning\n//   a MANY-TO-MANY relation into two ONE-TO-MANY relationships, where the MANY part\n//   is the RoleEntity.\ndata class MovieWithCast(\n    @Embedded\n    val movie: MovieEntity,\n    @Relation(\n        entity = RoleEntity::class,\n        parentColumn = \"id\",\n        entityColumn = \"movieId\",\n    )\n    val rolesWithActors: List&lt;RoleWithActor&gt;,\n)\ndata class RoleWithActor(\n    @Embedded\n    val role: RoleEntity,\n    @Relation(\n        parentColumn = \"actorId\",\n        entityColumn = \"id\"\n    )\n    val actor: ActorEntity,\n)\n</pre> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/RatingEntity.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Embedded\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\nimport androidx.room.Relation\nimport java.util.UUID\n\n@Entity\ndata class RatingEntity(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var description: String,\n)\n// ONE-TO-MANY relationship (Rating -&gt; Movies)\n// NOTE: THIS IS NOT AN ENTITY!\ndata class RatingWithMovies(\n    @Embedded\n    val rating: RatingEntity,\n    @Relation(\n        parentColumn = \"id\",\n        entityColumn = \"ratingId\",\n    )\n    val movies: List&lt;MovieEntity&gt;\n)\n</pre> ADDED: data/src/main/java/com/androidbyexample/compose/movies/data/RoleEntity.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Entity\nimport androidx.room.ForeignKey\nimport androidx.room.Index\n\n// RoleEntity - note that it's considered a child of both MovieEntity and\n//    ActorEntity. When either parent is deleted, we delete this entity. If\n//    either parent's key is updated, we update this entity.\n\n@Entity(\n    primaryKeys = [\"actorId\", \"movieId\"],\n    indices = [\n        Index(\"movieId\"),\n        Index(\"actorId\")\n    ],\n    foreignKeys = [\n        ForeignKey(\n            entity = MovieEntity::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"movieId\"],\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE,\n        ),\n        ForeignKey(\n            entity = ActorEntity::class,\n            parentColumns = [\"id\"],\n            childColumns = [\"actorId\"],\n            onUpdate = ForeignKey.CASCADE,\n            onDelete = ForeignKey.CASCADE,\n        )\n    ]\n)\ndata class RoleEntity(\n    var movieId: String,\n    var actorId: String,\n    var character: String,\n    var orderInCredits: Int,\n)\n</pre>"},{"location":"modules/movie-db/STEP_060_REPO.html","title":"Repository Types","text":"<p>Now the basics of the <code>repository</code> module.</p>"},{"location":"modules/movie-db/STEP_060_REPO.html#dtos","title":"DTOs","text":"<p>We create Data Transfer Objects, <code>ActorDto</code>, <code>MovieDto</code>, and <code>RatingDto</code> to abstract and restrict how the data is used. These DTOs are immutable, which will help Jetpack Compose optimize UI updates.</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>// ...\nimport com.androidbyexample.compose.movies.data.RoleWithMovie\n\ndata class ActorDto(\n    val id: String,\n    val name: String,\n)\n\ninternal fun ActorEntity.toDto() =\n    // ...</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDto.kt <pre>// ...\nimport com.androidbyexample.compose.movies.data.RoleWithActor\n\ndata class MovieDto(\n    val id: String,\n    val title: String,\n    val description: String,\n    val ratingId: String,\n)\n\ninternal fun MovieEntity.toDto() =\n    // ...</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/RatingDto.kt <pre>// ...\nimport com.androidbyexample.compose.movies.data.RatingWithMovies\n\ndata class RatingDto(\n    val id: String,\n    val name: String,\n    val description: String,\n)\n\ninternal fun RatingEntity.toDto() =\n    // ...</pre> <p>We also define extension functions, such as these</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>// ...\n)\n\ninternal fun ActorEntity.toDto() =\n    ActorDto(id = id, name = name)\ninternal fun ActorDto.toEntity() =\n    ActorEntity(id = id, name = name)\n\ndata class ActorWithFilmographyDto(\n    // ...</pre> <p>to convert between the entities defined in the <code>data</code> module and the DTOs we expose from this <code>repository</code> module.</p> <p>Note that the extension functions are marked <code>internal</code>. This makes them accessible anywhere inside the <code>repository</code> module, but not outside the module.</p>"},{"location":"modules/movie-db/STEP_060_REPO.html#movierepository","title":"MovieRepository","text":"<p>The <code>MovieRepository</code> interface defines how we communicate with a repository. This allows different repository implementations (later we'll add a web-service implementation). Note that I'm not using <code>vararg</code> in the <code>MovieRepository</code>. This is because it simplifies our web services implementation when we do it later.</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\nimport kotlinx.coroutines.flow.Flow\n\ninterface MovieRepository {\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt;\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    suspend fun getMovieWithCast(id: String): MovieWithCastDto\n    suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto\n    suspend fun insert(movie: MovieDto)\n    suspend fun insert(actor: ActorDto)\n    suspend fun insert(rating: RatingDto)\n    suspend fun resetDatabase()\n}</pre>"},{"location":"modules/movie-db/STEP_060_REPO.html#moviedatabaserepository","title":"MovieDatabaseRepositoryAll code changes","text":"<p>This is the concrete implementation of <code>MovieRepository</code> that we use to work with the Room database. Much of it is direct passthrough to the DAO.</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n    override suspend fun resetDatabase() = dao.resetDatabase()\n}</pre> <p>The query functions that expose a <code>Flow</code> transform the returned entities into DTOs. The <code>map</code> function on <code>Flow</code> creates a new flow that calls the nested <code>map</code> on the list of entities to convert them into DTOs.</p> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.ActorEntity\nimport com.androidbyexample.compose.movies.data.ActorWithFilmography\nimport com.androidbyexample.compose.movies.data.RoleWithMovie\n\ndata class ActorDto(\n    val id: String,\n    val name: String,\n)\n\ninternal fun ActorEntity.toDto() =\n    ActorDto(id = id, name = name)\ninternal fun ActorDto.toEntity() =\n    ActorEntity(id = id, name = name)\n\ndata class ActorWithFilmographyDto(\n    val actor: ActorDto,\n    val filmography: List&lt;RoleWithMovieDto&gt;,\n)\ndata class RoleWithMovieDto(\n    val movie: MovieDto,\n    val character: String,\n    val orderInCredits: Int,\n)\ninternal fun RoleWithMovie.toDto() =\n    RoleWithMovieDto(\n        movie = movie.toDto(),\n        character = role.character,\n        orderInCredits = role.orderInCredits,\n    )\ninternal fun ActorWithFilmography.toDto() =\n    ActorWithFilmographyDto(\n        actor = actor.toDto(),\n        filmography =\n        rolesWithMovies.map {\n            it.toDto()\n        }\n    )\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport android.content.Context\nimport com.androidbyexample.compose.movies.data.MovieDao\nimport com.androidbyexample.compose.movies.data.createDao\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n    override suspend fun resetDatabase() = dao.resetDatabase()\n}\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.MovieEntity\nimport com.androidbyexample.compose.movies.data.MovieWithCast\nimport com.androidbyexample.compose.movies.data.RoleWithActor\n\ndata class MovieDto(\n    val id: String,\n    val title: String,\n    val description: String,\n    val ratingId: String,\n)\n\ninternal fun MovieEntity.toDto() =\n    MovieDto(id = id, title = title, description = description, ratingId = ratingId)\ninternal fun MovieDto.toEntity() =\n    MovieEntity(id = id, title = title, description = description, ratingId = ratingId)\ndata class MovieWithCastDto(\n    val movie: MovieDto,\n    val cast: List&lt;RoleWithActorDto&gt;,\n)\ndata class RoleWithActorDto(\n    val actor: ActorDto,\n    val character: String,\n    val orderInCredits: Int,\n)\ninternal fun RoleWithActor.toDto() =\n    RoleWithActorDto(\n        actor = actor.toDto(),\n        character = role.character,\n        orderInCredits = role.orderInCredits,\n    )\ninternal fun MovieWithCast.toDto() =\n    MovieWithCastDto(\n        movie = movie.toDto(),\n        cast =\n        rolesWithActors.map {\n            it.toDto()\n        }\n    )\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport kotlinx.coroutines.flow.Flow\n\ninterface MovieRepository {\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt;\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    suspend fun getMovieWithCast(id: String): MovieWithCastDto\n    suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto\n    suspend fun insert(movie: MovieDto)\n    suspend fun insert(actor: ActorDto)\n    suspend fun insert(rating: RatingDto)\n    suspend fun resetDatabase()\n}\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/RatingDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.RatingEntity\nimport com.androidbyexample.compose.movies.data.RatingWithMovies\n\ndata class RatingDto(\n    val id: String,\n    val name: String,\n    val description: String,\n)\n\ninternal fun RatingEntity.toDto() =\n    RatingDto(id = id, name = name, description = description)\ninternal fun RatingDto.toEntity() =\n    RatingEntity(id = id, name = name, description = description)\ndata class RatingWithMoviesDto(\n    val rating: RatingDto,\n    val movies: List&lt;MovieDto&gt;,\n)\n// only need the toDto(); we don't use this to do database updates\ninternal fun RatingWithMovies.toDto() =\n    RatingWithMoviesDto(\n        rating = rating.toDto(),\n        movies = movies.map { it.toDto() },\n    )\n</pre>"},{"location":"modules/movie-db/STEP_070_REPO.html","title":"Modifying the view model to use real data","text":"<p>First, we need to provide a <code>MovieRepository</code> for the view model to use.</p> <p>We do this via constructor injection, passing it as a parameter to the constructor. When we create an instance of the view model, we'll need to pass one in. Now that the view model knows about a repository, we can get data from that repository by delegation.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n//class MovieViewModel: ViewModel() {\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            // ...\n}</pre> <p>Using <code>MovieViewModel: MovieRepository by repository</code> like this generates implementation functions and properties for those defined in <code>MovieRepository</code> that call the functions in the passed-in repository. This is similar to explicitly writing code like</p> <pre><code>class MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel() {\n    val moviesFlow = repository.moviesFlow\n\n    suspend fun getMovieWithCast(id: String) =\n        repository.getMovieWithCast(id)\n\n    suspend fun insert(actor: ActorDto) {\n        repository.insert(actor)\n    }\n    ...\n}\n</code></pre> <p>If any of the functions need modification, you can override them.</p> <p>Note</p> <p>At this point the code will no longer compile, as we've broken the way movies are exposed to the UI.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\n\n//class MovieViewModel: ViewModel() {\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            currentScreen = value.lastOrNull()\n        }\n\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    val movies: List&lt;Movie&gt; = listOf(\n        Movie(\"The Transporter\", \"Jason Statham kicks a guy in the face\"),\n        Movie(\"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\"),\n        Movie(\"Hobbs and Shaw\", \"Cars, Explosions and Stuff\"),\n        Movie(\"Jumanji - Welcome to the Jungle\", \"The Rock smolders\"),\n    )\n}\n</pre>"},{"location":"modules/movie-db/STEP_080_REPO.html","title":"Fix movie list","text":"<p>Now we'll fix things so we can display the real movie list and add a \"reset database\" button to the UI.</p> <p>Right now, the <code>MainActivity</code> contains</p> <pre><code>private val viewModel by viewModels&lt;MovieViewModel&gt;()\n</code></pre> <p>to create or access an existing view model instance. This doesn't pass in the repository instance that we now need. To do this, we need to create a factory that <code>viewModels()</code> can use to create the instance. (Alternatively we could use a dependency-injection framework to create things for us, but that's out of scope right now.)</p> <p>That factory needs to obtain an instance of the <code>MovieDatabaseRepository</code>. So we'll start there by defining a factory there.</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nclass MovieDatabaseRepository(\n    // ...\n): MovieRepository {\n    // ...\n    override suspend fun resetDatabase() = dao.resetDatabase()\n\n    companion object {\n        fun create(context: Context) =\n            MovieDatabaseRepository(createDao(context))\n    }\n}</pre> <p>A <code>companion object</code> is a singleton object that can be used by all <code>MovieDatabaseRepository</code> instances, or its parts being called via class-qualified functions such as <code>MovieDatabaseRepository.create()</code>. This create function uses the database builder that we exposed from the data layer to create a return a <code>MovieDatabaseRepository</code> instance.</p> <p>Back in the view model, we create another <code>companion object</code>, but this one defines a <code>ViewModelProvider.Factory</code> that can be used by the <code>viewModels()</code> in <code>MainActivity</code> when it needs to create an instance of the <code>MovieViewModel</code>.</p> <p>A little bit of cleanup... We will be using <code>MovieDto</code> instead of the <code>Movie</code> defined in <code>app</code>. So we delete the <code>Movie</code> class from <code>app</code> and modify the use of it in <code>MovieListUi</code>, <code>MovieDisplayUi</code>, and <code>MovieDisplay</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n//  movies: List&lt;Movie&gt;,\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n//  onMovieClicked: (Movie) -&gt; Unit,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    // ...\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n//  movie: Movie,\n    movie: MovieDto,\n    modifier: Modifier = Modifier,\n) {\n    // ...\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>// ...\nsealed interface Screen\ndata object MovieList: Screen\n//data class MovieDisplay(val movie: Movie): Screen\ndata class MovieDisplay(val movie: MovieDto): Screen</pre> <p>To get the list of movies, we'll now need to collect a <code>Flow</code> in our UI. Collection is how to observe and get new values from a <code>Flow</code>. </p> <p>Compose defines the <code>collectAsState()</code> to start a coroutine to collect from a <code>Flow</code> and convert it into Compose <code>State</code> so it can be observed as part of a <code>Snapshot</code>. The collection stops if the part of the UI tree that contains it is removed. For example, if we collect in function <code>a()</code> and the current composition no longer calls <code>a()</code>, the collection stops.</p> <p>This is great for flow collection in general, but Android adds an extra concern - lifecycles. When you switch from an application to the home screen, Android may or may not tell the application to destroy itself. It's possible for coroutines to keep running, and, in the case of collecting for display on a UI, it's possible that a non-displayed UI might be updated, which could crash.</p> <p>To get around this, we have <code>collectAsStateWithLifecycle()</code>, which stops the collection if the UI is not active.</p> <p>For more details on <code>collectAsState</code> vs <code>collectAsStateWithLifecycle()</code>, see Consuming flows safely in Jetpack Compose.</p> <p>To use <code>collectAsStateWithLifecycle()</code>, we need to add a new dependency to our <code>app</code> module.</p> <p>To do this, add lifecycle-compose to the version catalog and as a dependency in <code>app/build.gradle.kts</code>.</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\njavaVersion = \"VERSION_11\"\n\nlifecycle-compose = \"2.8.7\"\n\n[libraries]\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\n// ...\n[plugins]\n// ...</pre> show in full file  app/build.gradle.kts <pre>// ...\ndependencies {\n    implementation(project(\":repository\"))\n\n    implementation(libs.lifecycle.compose)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    // ...\n}</pre> <p>Now we can add the collection code. Note that you'll need to also import <code>androidx.compose.runtime.getValue</code> in addition to <code>collectAsStateWithLifecycle()</code> so Kotlin can delegate the <code>movies</code> property to the collected state.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            MovieListUi(\n//              movies = viewModel.movies,\n                movies = movies,\n                modifier = modifier,\n//          ) { movie -&gt;\n                // ...\n            )\n        }\n    }\n}</pre> <p>To finish things up, let's add a reset button to our <code>MovieList</code> that calls a passed-in reset event.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n//  onMovieClicked: (Movie) -&gt; Unit,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                // ...\n                    Text(text = stringResource(R.string.movies))\n                },\n                actions = {\n                    IconButton (onClick = onResetDatabase) {\n                        Icon(\n                            imageVector = Icons.Default.Refresh,\n                            contentDescription = stringResource(R.string.reset_database)\n                        )\n                    }\n                }\n            )\n        },\n        // ...\n    ) { innerPadding -&gt;\n        // ...\n    }\n}</pre> <p>Our <code>resetDatabase()</code> function in the DAO, repository and view model is defined as a <code>suspend</code> function, meaning it must be executed in a coroutine. To launch a coroutine, we need a coroutine scope, so we'll need to create that coroutine scope in <code>Ui()</code>. We call <code>resetDatabase()</code> via an event function that we pass to <code>Ui()</code>. </p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        MovieList -&gt; {\n            // ...\n            MovieListUi(\n                // ...\n                movies = movies,\n                modifier = modifier,\n//          ) { movie -&gt;\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie))\n                }\n            )\n        }\n    }\n}</pre> <p>Note</p> <p>I restructured the call to <code>MovieListUI</code>'s constructor because it now has multiple event lambdas. If one lambda feels more important that the others (or the others have reasonable defaults), you can keep it at the end for caller to use the lambda-outside-parens style. If there's no obvious primary action, or you must specify multiple lambdas on every call, I recommend you keep all of the lambdas inside the parens with parameter names, and do not use a lambda outside the params.</p> <p>(Note that any Composable that has a <code>content</code> parameter at the end should be called using trailing-lambda syntax)</p> <p>Finally, remove the hardcoded data from the <code>MovieViewModel</code>.</p> <p>When we first run the application, we'll see and empty movie list. There's no data in the database.</p> <p></p> <p>Pressing the reset button on the tool bar adds data to the database. Because we're using a <code>Flow</code> to get data, Room adds a trigger to watch for database changes, and emits a new list of movies. Because the UI is collecting from that <code>Flow</code>, the list on screen automatically updates:</p> <p></p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n        minSdk = libs.versions.minSdk.get().toInt()\n        targetSdk = libs.versions.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(project(\":repository\"))\n\n    implementation(libs.lifecycle.compose)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nclass MainActivity : ComponentActivity() {\n//  private val viewModel by viewModels&lt;MovieViewModel&gt;()\n    private val viewModel by viewModels&lt;MovieViewModel&gt; { MovieViewModel.Factory }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Ui(\n                        viewModel = viewModel,\n                    ) {\n                        finish()\n                }\n        }\n    }\n    }\n}\n</pre> DELETED: app/src/main/java/com/androidbyexample/compose/movies/Movie.kt <pre>//package com.androidbyexample.compose.movies\n//\n//data class Movie(\n//  val title: String,\n//  val description: String,\n//)\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\n\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            currentScreen = value.lastOrNull()\n        }\n\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n//  val movies: List&lt;Movie&gt; = listOf(\n//      Movie(\"The Transporter\", \"Jason Statham kicks a guy in the face\"),\n//      Movie(\"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\"),\n//      Movie(\"Hobbs and Shaw\", \"Cars, Explosions and Stuff\"),\n//      Movie(\"Jumanji - Welcome to the Jungle\", \"The Rock smolders\"),\n//  )\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\n//import com.androidbyexample.compose.movies.Movie\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n//  movie: Movie,\n    movie: MovieDto,\n    modifier: Modifier = Modifier,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = movie.title)\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        Column (\n            modifier = Modifier\n                .padding(innerPadding)\n                .verticalScroll(rememberScrollState())\n        ) {\n            Label (textId = R.string.title)\n            Display(text = movie.title)\n            Label(textId = R.string.description)\n            Display(text = movie.description)\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\n//import com.androidbyexample.compose.movies.Movie\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n//  movies: List&lt;Movie&gt;,\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n//  onMovieClicked: (Movie) -&gt; Unit,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = stringResource(R.string.movies))\n                },\n                actions = {\n                    IconButton (onClick = onResetDatabase) {\n                        Icon(\n                            imageVector = Icons.Default.Refresh,\n                            contentDescription = stringResource(R.string.reset_database)\n                        )\n                    }\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        Column (\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n                .verticalScroll(rememberScrollState())\n        ) {\n            movies.forEach { movie -&gt;\n                Card (\n                    elevation = CardDefaults.cardElevation(\n                        defaultElevation = 8.dp,\n                    ),\n                    onClick = {\n                        onMovieClicked(movie)\n                    },\n                    modifier = Modifier.padding(8.dp)\n                ) {\n                    Row (\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(8.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Star,\n                            contentDescription = stringResource(id = R.string.movie)\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import com.androidbyexample.compose.movies.Movie\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\nsealed interface Screen\ndata object MovieList: Screen\n//data class MovieDisplay(val movie: Movie): Screen\ndata class MovieDisplay(val movie: MovieDto): Screen\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                movie = screen.movie,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            MovieListUi(\n//              movies = viewModel.movies,\n                movies = movies,\n                modifier = modifier,\n//          ) { movie -&gt;\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie))\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\n\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\n\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\n\nlifecycle-compose = \"2.8.7\"\n\n[libraries]\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport android.content.Context\nimport com.androidbyexample.compose.movies.data.MovieDao\nimport com.androidbyexample.compose.movies.data.createDao\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n    override suspend fun resetDatabase() = dao.resetDatabase()\n\n    companion object {\n        fun create(context: Context) =\n            MovieDatabaseRepository(createDao(context))\n    }\n}\n</pre>"},{"location":"modules/movie-db/STEP_090_REPO.html","title":"Fetch data for movie display","text":"<p><code>MovieDisplayUi</code> still works the same way it used to. We wrap the selected <code>MovieDto</code> in a <code>MovieDisplay</code> instance and push it on the screen stack. The <code>Ui</code> composable gets the current screen and calls <code>MovieDisplayUi</code> passing in the movie.</p> <p>There are some problems with this approach:</p> <ul> <li> <p>If the user jumps to the home screen and later, back into the application, it's possible that      Android may have disposed the application stack. You may want to persist the data for the     current screen. That data may be stale by the time you return.</p> </li> <li> <p>Once on the screen with that data, something else may change the data in the database, and     we only have a fixed view of the data from the time the list was displayed.</p> </li> </ul> <p>We'll solve the second problem later. For the first problem, we won't persist the data here, but we'll change what's being passed to just the ID of the data, and fetch the data inside the screen. Then, if we decide to persist the data as the user exits, we won't have stale data, as we'll fetch it fresh each time we display it.</p> <p>To do this, we'll use a controlled-side effect called <code>LaunchedEffect</code> in our screen composable. <code>LaunchedEffect</code> launches a coroutine to perform some processing, and that coroutine keeps running until:</p> <ul> <li>it finishes, or</li> <li>its parent composable is no longer part of the UI tree, or</li> <li>its key changes, in which case the current run is canceled and the code in its lambda is      re-executed</li> </ul> <p>We start by passing a movie id instead of a movie itself, and a fetch function to allow the composable to fetch the movie when needed.</p> <p>We add a <code>Launched Effect</code> to fetch the movie. On initial composition, this starts a coroutine to perform the fetch, which will run and return a <code>MovieDto</code>. On recomposition, it will only restart if the id has changed (or the <code>MovieDisplayUi</code> was removed from the UI tree and re-added.) If the user selected a different movie fast enough, the existing fetch run would be canceled and a few fetch started.</p> <p>Because we might not yet have a title, we need to provide a fallback, which we can easily do using our friend the \"elvis operator\" <code>?:</code> (which if you turn your head 90 degrees to the left and squint looks a little like Elvis Presley's eyes and hair, ahthankyouverymuch).</p> <p>Using the <code>let</code> function allows us to easily omit the user interface while the movie is loading. Note that we've also added the cast information to the display, as it's now available!</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n//  movie: MovieDto,\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n    Scaffold(\n        // ...\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        movieWithCast?.let { movieWithCast -&gt;\n            Column (\n                modifier = Modifier\n                    .padding(innerPadding)\n                    .verticalScroll(rememberScrollState())\n            ) {\n                Label (textId = R.string.title)\n//          Display(text = movie.title)\n                Display(text = movieWithCast.movie.title)\n                Label(textId = R.string.description)\n//          Display(text = movie.description)\n                Display(text = movieWithCast.movie.description)\n                Label(textId = R.string.cast)\n                movieWithCast\n                    .cast\n                    .sortedBy { it.orderInCredits }\n                    .forEach { role -&gt;\n                        Display(\n                            text = stringResource(\n                                R.string.cast_entry,\n                                role.character,\n                                role.actor.name,\n                            )\n                        )\n                    }\n            }\n        }\n    }\n}</pre> <p>The drawback to this approach is that the screen will likely blink from a blank screen to one containing the movie data. The main way around this is to perform the data fetch outside the function. We'll come back to this approach later.</p> <p>We modify <code>MovieDisplay</code> to take a <code>String</code> id instead of the movie itself, and pass it in the call to <code>MovieDisplayUi</code>, along with an event function. We also need to tweak the <code>MovieDisplay</code> created when the user clicks on a movie in the list.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>// ...\nsealed interface Screen\ndata object MovieList: Screen\n//data class MovieDisplay(val movie: MovieDto): Screen\ndata class MovieDisplay(val id: String): Screen</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n//              movie = screen.movie,\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n//                  viewModel.pushScreen(MovieDisplay(movie))\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                }\n            )\n        }\n    }\n}</pre> <p>We're using a Kotlin function reference here. If the signature of a function matches the required functional type, we can just pass in an <code>object::function</code> specification for it. In this case,</p> <pre><code>fetchMovie = viewModel::getMovieWithCast\n</code></pre> <p>is effectively the same as</p> <pre><code>fetchMovie = { viewModel.getMovieWithCast() }\n</code></pre> <p>(I say \"effectively\" because the second example creates an additional function layer to call, which may be optimized away by the compiler)</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.MovieWithCastDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n//  movie: MovieDto,\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n//                  Text(text = movie.title)\n                    Text(text = movieWithCast?.movie?.title ?: stringResource(R.string.loading))\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        movieWithCast?.let { movieWithCast -&gt;\n            Column (\n                modifier = Modifier\n                    .padding(innerPadding)\n                    .verticalScroll(rememberScrollState())\n            ) {\n                Label (textId = R.string.title)\n//          Display(text = movie.title)\n                Display(text = movieWithCast.movie.title)\n                Label(textId = R.string.description)\n//          Display(text = movie.description)\n                Display(text = movieWithCast.movie.description)\n                Label(textId = R.string.cast)\n                movieWithCast\n                    .cast\n                    .sortedBy { it.orderInCredits }\n                    .forEach { role -&gt;\n                        Display(\n                            text = stringResource(\n                                R.string.cast_entry,\n                                role.character,\n                                role.actor.name,\n                            )\n                        )\n                    }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import com.androidbyexample.compose.movies.repository.MovieDto\n//\nsealed interface Screen\ndata object MovieList: Screen\n//data class MovieDisplay(val movie: MovieDto): Screen\ndata class MovieDisplay(val id: String): Screen\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n//              movie = screen.movie,\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n//                  viewModel.pushScreen(MovieDisplay(movie))\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n    &lt;string name=\"loading\"&gt;\u2026Loading\u2026&lt;/string&gt;\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n    &lt;string name=\"cast_entry\"&gt;%1$s: %2$s&lt;/string&gt;\n&lt;/resources&gt;\n</pre>"},{"location":"modules/movie-db/STEP_100_FULL.html","title":"Viewing the Database","text":"<p>You can use the App Inspector in Android Studio to view the database on the emulator or physical device.</p> <ol> <li>Run your application</li> <li>Open App Inspection</li> <li>via the \"...\" on the left edge of Android Studio, or<ul> <li>via View -&gt; Tool Windows -&gt; App Inspection from the hamburger menu at the top-left of    Android Studio</li> </ul> </li> <li>You may need to wait a moment for the running devices dropdown to appear</li> <li>Click on the running devices dropdown</li> <li>Choose the emulator or physical device that's running your application</li> <li>Choose the application that matches the app id in your app/build.gradle.kts</li> <li>Click on the Database Inspector tab</li> <li>You can then double-click table names to see data or run SQL queries</li> </ol> <p>We'll stop here for now and flesh this example out more over time. We'll fill in all of the details for displaying <code>Movies</code>, <code>Actors</code> and <code>Ratings</code> in a later module, after we've discussed lists.</p>"},{"location":"modules/movie-db/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/movie-db. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>movie-db</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/movie-db\n</code></pre>"},{"location":"modules/movie-rest/index.html","title":"Overview","text":"<p>Android applications often communicate with servers to manage common data. In this module, we'll look at RESTful Web Services and see how your application can communicate with them to manage remote data.</p>"},{"location":"modules/movie-rest/STEP_020_REPO.html","title":"Rest server module","text":"<p>To start, we'll create a simple REST server module in our movies project. Normally this would not go in your Android project, but for convenience we'll add it here.</p> <p>Use File &gt; New Module &gt; Java or Kotlin Library to create a module called <code>restserver</code>. Use <code>RunServer</code> as the class name.</p> <p>We'll use the Apache Jersey server for our simple REST server, so we'll add its libraries to the version catalog. To make things a bit more convenient, we'll use the version catalog <code>[bundles]</code> support, allowing us to define a single name to represent a set of libraries we're using together.</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nglance=\"1.1.1\"\njetbrainsKotlinJvm = \"2.0.21\"\njersey=\"3.1.9\"\nactivation=\"2.1.3\"\n\n[libraries]\njersey-grizzly2 = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-grizzly2-http\", version.ref = \"jersey\" }\njersey-jetty = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-jetty-http\", version.ref = \"jersey\" }\njersey-servlet = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-servlet-core\", version.ref = \"jersey\" }\njersey-jackson = { group = \"org.glassfish.jersey.media\", name = \"jersey-media-json-jackson\", version.ref = \"jersey\" }\njersey-server = { group = \"org.glassfish.jersey.core\", name = \"jersey-server\", version.ref = \"jersey\" }\njersey-hk2 = { group = \"org.glassfish.jersey.inject\", name = \"jersey-hk2\", version.ref = \"jersey\" }\nactivation = { group = \"jakarta.activation\", name = \"jakarta.activation-api\", version.ref = \"activation\" }\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material3 = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\n// ...\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[bundles]\nserver = [\n    \"jersey-grizzly2\",\n    \"jersey-jetty\",\n    \"jersey-servlet\",\n    \"jersey-jackson\",\n    \"jersey-server\",\n    \"jersey-hk2\",\n    \"activation\"\n]\n\n[plugins]\n// ...</pre> <p>We add these to the new module's <code>build.gradle.kts</code> using the version catalog bundle.</p> <p>To run the server, we need to add the <code>application</code> plugin. We don't need to add this plugin to the version catalog as it's a standard part of the Gradle distribution. We specify the application to run using <code>mainClass</code></p> show in full file  restserver/build.gradle.kts <pre>plugins {\n    id(\"java-library\")\n    alias(libs.plugins.jetbrains.kotlin.jvm)\n    application\n}\n\n// ...\n}\n\ndependencies {\n    implementation(libs.bundles.server)\n}\n\nkotlin {\n    // ...\n}\n\napplication {\n    mainClass = \"com.androidbyexample.compose.movies.restserver.RunServer\"\n}</pre> <p>To test that everything is set up ok to run, we'll add a simple <code>main</code> to our <code>RunServer</code> class</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RunServer.kt <pre>// ...\n\nclass RunServer {\n    companion object {\n        @JvmStatic\n        fun main(args: Array&lt;String&gt;) {\n            println(\"It runs!\")\n        }\n    }\n}</pre> <p>and then we can run it via</p> <pre><code>./gradlew run\n</code></pre> <p>Note</p> <p>Because we're running this on a Java Virtual Machine (JVM), the main class is expected to have a <code>public static void main(String[] args)</code> method. TO accomplish this, we:</p> <ul> <li>Add a <code>companion object</code> to <code>RunServer</code>. Any function defined inside it belongs to the   <code>RunServer</code> class, and you won't need an instance of <code>RunServer</code> to execute it.</li> <li>Add a <code>fun main(args: Array&lt;String&gt;)</code> function inside the <code>companion object</code></li> <li>Mark the <code>main</code> function with the <code>@JvmStatic</code> annotation to define the function as a   static method when run on the JVM.</li> </ul> All code changes CHANGED: build.gradle.kts <pre>// Top-level build file where you can add configuration options common to all sub-projects/modules.\nplugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.android) apply false\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.android.library) apply false\n    alias(libs.plugins.ksp) apply false\n    alias(libs.plugins.jetbrains.kotlin.jvm) apply false\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\nlifecycle-compose = \"2.8.7\"\nicons-extended = \"1.7.6\"\nglance=\"1.1.1\"\njetbrainsKotlinJvm = \"2.0.21\"\njersey=\"3.1.9\"\nactivation=\"2.1.3\"\n\n[libraries]\njersey-grizzly2 = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-grizzly2-http\", version.ref = \"jersey\" }\njersey-jetty = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-jetty-http\", version.ref = \"jersey\" }\njersey-servlet = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-servlet-core\", version.ref = \"jersey\" }\njersey-jackson = { group = \"org.glassfish.jersey.media\", name = \"jersey-media-json-jackson\", version.ref = \"jersey\" }\njersey-server = { group = \"org.glassfish.jersey.core\", name = \"jersey-server\", version.ref = \"jersey\" }\njersey-hk2 = { group = \"org.glassfish.jersey.inject\", name = \"jersey-hk2\", version.ref = \"jersey\" }\nactivation = { group = \"jakarta.activation\", name = \"jakarta.activation-api\", version.ref = \"activation\" }\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material3 = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended-android\", version.ref = \"icons-extended\"}\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[bundles]\nserver = [\n    \"jersey-grizzly2\",\n    \"jersey-jetty\",\n    \"jersey-servlet\",\n    \"jersey-jackson\",\n    \"jersey-server\",\n    \"jersey-hk2\",\n    \"activation\"\n]\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\njetbrains-kotlin-jvm = { id = \"org.jetbrains.kotlin.jvm\", version.ref = \"jetbrainsKotlinJvm\" }\n</pre> ADDED: restserver/.gitignore <pre>/build\n</pre> ADDED: restserver/build.gradle.kts <pre>plugins {\n    id(\"java-library\")\n    alias(libs.plugins.jetbrains.kotlin.jvm)\n    application\n}\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_11\n    targetCompatibility = JavaVersion.VERSION_11\n}\n\ndependencies {\n    implementation(libs.bundles.server)\n}\n\nkotlin {\n    compilerOptions {\n        jvmTarget = org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_11\n    }\n}\n\napplication {\n    mainClass = \"com.androidbyexample.compose.movies.restserver.RunServer\"\n}\n</pre> ADDED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RunServer.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nclass RunServer {\n    companion object {\n        @JvmStatic\n        fun main(args: Array&lt;String&gt;) {\n            println(\"It runs!\")\n        }\n    }\n}\n</pre> CHANGED: settings.gradle.kts <pre>pluginManagement {\n    repositories {\n        google {\n            content {\n                includeGroupByRegex(\"com\\\\.android.*\")\n                includeGroupByRegex(\"com\\\\.google.*\")\n                includeGroupByRegex(\"androidx.*\")\n            }\n        }\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\nrootProject.name = \"Movies\"\ninclude(\":app\")\ninclude(\":data\")\ninclude(\":repository\")\ninclude(\":restserver\")\n</pre>"},{"location":"modules/movie-rest/STEP_030_REPO.html","title":"Server code","text":"<p>Note</p> <p>You won't need a server for any of your projects, so we'll go through this pretty quickly just to make the example work.</p> <p>First, we need some data for the server. Because the server isn't running Android, we can't use our Android data library, so we'll redefine the objects using Jackson for JSON serialization. As Kotlin MultiPlatform (KMP) grows, we may start seeing Room used on non-Android platforms, which would simplify this setup.</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Actor.kt <pre>// ...\nimport java.util.UUID\n\n@XmlRootElement\ndata class Actor(\n    @JsonProperty(\"id\") var id: String = UUID.randomUUID().toString(),\n    @JsonProperty(\"name\") var name: String\n)\n\n@XmlRootElement\ndata class ActorWithFilmography(\n    @JsonProperty(\"actor\") val actor: Actor,\n    @JsonProperty(\"filmography\") val filmography: List&lt;RoleWithMovie&gt;,\n)\n\n@XmlRootElement\ndata class RoleWithMovie(\n    @JsonProperty(\"movie\") val movie: Movie,\n    @JsonProperty(\"character\") val character: String,\n    @JsonProperty(\"orderInCredits\") val orderInCredits: Int,\n)</pre> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Movie.kt <pre>// ...\nimport java.util.UUID\n\n@XmlRootElement\ndata class Movie(\n    @JsonProperty(\"id\") val id: String = UUID.randomUUID().toString(),\n    @JsonProperty(\"title\") val title: String,\n    @JsonProperty(\"description\") val description: String,\n    @JsonProperty(\"ratingId\") val ratingId: String,\n)\n\n@XmlRootElement\ndata class MovieWithCast(\n    @JsonProperty(\"movie\") val movie: Movie,\n    @JsonProperty(\"cast\") val cast: List&lt;RoleWithActor&gt;,\n)\n\n@XmlRootElement\n// ...</pre> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Rating.kt <pre>// ...\nimport java.util.UUID\n\n@XmlRootElement\ndata class Rating(\n    @JsonProperty(\"id\") val id: String = UUID.randomUUID().toString(),\n    @JsonProperty(\"name\") val name: String,\n    @JsonProperty(\"description\") val description: String\n)\n\n@XmlRootElement\ndata class RatingWithMovies(\n    @JsonProperty(\"rating\") var rating: Rating,\n    @JsonProperty(\"movies\") var movies: List&lt;Movie&gt;,\n)</pre> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Role.kt <pre>// ...\nimport jakarta.xml.bind.annotation.XmlRootElement\n\n@XmlRootElement\nclass Role(\n    @JsonProperty(\"movieId\") var movieId: String,\n    @JsonProperty(\"actorId\") var actorId: String,\n    @JsonProperty(\"character\") var character: String,\n    @JsonProperty(\"orderInCredits\") var orderInCredits: Int\n)\n\n@XmlRootElement\nclass ExpandedRole(\n    @JsonProperty(\"movie\") var movie: Movie,\n    @JsonProperty(\"actor\") var actor: Actor,\n    @JsonProperty(\"character\") var character: String,\n    @JsonProperty(\"orderInCredits\") var orderInCredits: Int\n)</pre> <p>Next, we set up a REST controller class that Jersey will load and use to handle incoming HTTP requests. Note that the data is entirely in memory; we're just taking a quick look at how the data is transferred from the server using JSON to the client. Jersey and Jackson manage the requests and data marshalling for us.</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RestController.kt <pre>// ...\n\n\n// NOTE: If Room were cross platform I would have directly used\n//       our data module to store things in a database in this\n//       server. Unfortunately, it's Android-only, so I'm\n//       implementing an in-memory set of maps to track the\n//       data. Kinda gross, but developing a real server isn't\n//       important for the class. The important thing is how we\n//       can communicate with the server\nprivate fun &lt;T&gt; response(status: Response.Status, entity: T) =\n    Response.status(status).entity(entity).build()\n\nprivate fun &lt;T&gt; ok(entity: T) =\n    response(Response.Status.OK, entity)\n\nprivate fun &lt;T&gt; notFound(entity: T) =\n    response(Response.Status.NOT_FOUND, entity)\n\nprivate fun &lt;T&gt; created(entity: T) =\n    response(Response.Status.CREATED, entity)\n\n\nprivate val moviesByIdIndex = mutableMapOf&lt;String, Movie&gt;()\nprivate val actorsByIdIndex = mutableMapOf&lt;String, Actor&gt;()\nprivate val ratingsByIdIndex = mutableMapOf&lt;String, Rating&gt;()\nprivate val rolesByMovieIdIndex = mutableMapOf&lt;String, MutableList&lt;Role&gt;&gt;()\nprivate val rolesByActorIdIndex = mutableMapOf&lt;String, MutableList&lt;Role&gt;&gt;()\nprivate val moviesByRatingIdIndex = mutableMapOf&lt;String, MutableList&lt;Movie&gt;&gt;()\n\nprivate val notFoundRating = Rating(\"-\", \"NOT FOUND\", \"NOT FOUND\")\nprivate val notFoundMovie = Movie(\"-\", \"NOT FOUND\", \"NOT FOUND\", \"--\")\nprivate val notFoundMovieWithRoles = MovieWithCast(notFoundMovie, emptyList())\nprivate val notFoundActor = Actor(\"-\", \"NOT FOUND\")\nprivate val notFoundActorWithRoles = ActorWithFilmography(notFoundActor, emptyList())\nprivate val notFoundRatingWithMovies = RatingWithMovies(notFoundRating, emptyList())\n\n@Path(\"/\")\nclass RestController {\n    @GET\n    @Path(\"rating\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getRatings(): Response = ok(ratingsByIdIndex.values.sortedBy { it.id })\n\n    @GET\n    @Path(\"movie\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getMovies(): Response = ok(moviesByIdIndex.values.sortedBy { it.title })\n\n    @GET\n    @Path(\"movie/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getMovie(@PathParam(\"id\") id: String): Response =\n        ok(moviesByIdIndex[id])\n\n    @GET\n    @Path(\"actor\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getActors(): Response = ok(actorsByIdIndex.values.sortedBy { it.name })\n\n    @GET\n    @Path(\"rating/{id}/movies\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getRatingWithMovies(@PathParam(\"id\") id: String): RatingWithMovies =\n        ratingsByIdIndex[id]?.let { rating -&gt;\n            val movies = moviesByRatingIdIndex[id] ?: emptyList()\n            RatingWithMovies(rating, movies)\n        } ?: notFoundRatingWithMovies\n\n    @GET\n    @Path(\"movie/{id}/cast\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getMovieWithRoles(@PathParam(\"id\") id: String): MovieWithCast =\n        moviesByIdIndex[id]?.let { movie -&gt;\n            val roles =\n                rolesByMovieIdIndex[id]\n                    ?.map { role -&gt;\n                        RoleWithActor(\n                            actor = actorsByIdIndex[role.actorId] ?: throw IllegalStateException(),\n                            character = role.character,\n                            orderInCredits = role.orderInCredits,\n                        )\n                    }\n                    ?: emptyList()\n\n            MovieWithCast(movie, roles)\n        } ?: notFoundMovieWithRoles\n\n    @GET\n    @Path(\"actor/{id}/filmography\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getActorWithRoles(@PathParam(\"id\") id: String): ActorWithFilmography =\n        actorsByIdIndex[id]?.let { actor -&gt;\n            val roles =\n                rolesByActorIdIndex[id]\n                    ?.map { role -&gt;\n                        RoleWithMovie(\n                            movie = moviesByIdIndex[role.movieId] ?: throw IllegalStateException(),\n                            character = role.character,\n                            orderInCredits = role.orderInCredits,\n                        )\n                    }\n                    ?: emptyList()\n            ActorWithFilmography(actor, roles)\n        } ?: notFoundActorWithRoles\n\n    @PUT\n    @Path(\"movie/{id}\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun updateMovie(@PathParam(\"id\") id: String, movie: Movie): Response {\n        moviesByIdIndex[id] = movie\n        moviesByRatingIdIndex.getOrPut(movie.ratingId) { mutableListOf() }.add(movie)\n        return ok(1)\n    }\n\n    @PUT\n    @Path(\"actor/{id}\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun updateActor(@PathParam(\"id\") id: String, actor: Actor): Response {\n        actorsByIdIndex[id] = actor\n        return ok(1)\n    }\n\n    @PUT\n    @Path(\"rating/{id}\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun updateRating(@PathParam(\"id\") id: String, rating: Rating): Response {\n        ratingsByIdIndex[id] = rating\n        return ok(1)\n    }\n\n    private operator fun MutableMap&lt;String, MutableMap&lt;String, Role&gt;&gt;.set(id1: String, id2: String, role: Role) {\n        val roles = this[id1] ?: mutableMapOf&lt;String, Role&gt;().apply { this@set[id1] = this }\n        roles[id2] = role\n    }\n\n    private operator fun MutableMap&lt;String, MutableMap&lt;String, Role&gt;&gt;.get(id1: String, id2: String) =\n        this[id1]?.get(id2)\n\n    @POST\n    @Path(\"rating/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun createRating(@Context uriInfo: UriInfo, rating: Rating): Response {\n        ratingsByIdIndex[rating.id] = rating\n        return created(rating)\n    }\n\n    @POST\n    @Path(\"movie/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun createMovie(@Context uriInfo: UriInfo, movie: Movie): Response {\n        moviesByIdIndex[movie.id] = movie\n        return created(movie)\n    }\n\n    @POST\n    @Path(\"actor/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun createActor(@Context uriInfo: UriInfo, actor: Actor): Response {\n        actorsByIdIndex[actor.id] = actor\n        return created(actor)\n    }\n\n    @DELETE\n    @Path(\"movie/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun deleteMovie(@PathParam(\"id\") id: String): Response =\n        if (moviesByIdIndex[id] == null) {\n            notFound(0)\n        } else {\n            moviesByIdIndex.remove(id)\n            moviesByRatingIdIndex.values.forEach { movies -&gt;\n                movies.removeIf { it.id == id}\n            }\n            rolesByMovieIdIndex.remove(id) // remove all roles\n            rolesByActorIdIndex.values.forEach { roles -&gt;\n                roles.removeIf { it.movieId == id }\n            }\n            ok(1)\n        }\n\n    @DELETE\n    @Path(\"actor/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun deleteActor(@PathParam(\"id\") id: String): Response =\n        if (actorsByIdIndex[id] == null) {\n            notFound(0)\n        } else {\n            actorsByIdIndex.remove(id)\n            rolesByActorIdIndex.remove(id) // remove all roles\n            rolesByMovieIdIndex.values.forEach { roles -&gt; // remove filmography for those movies\n                roles.removeIf { it.actorId == id }\n            }\n            ok(1)\n        }\n\n    @DELETE\n    @Path(\"rating/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun deleteRating(@PathParam(\"id\") id: String): Response =\n        if (ratingsByIdIndex[id] == null) {\n            notFound(0)\n        } else {\n            ratingsByIdIndex.remove(id)\n            // delete associated movies\n            moviesByRatingIdIndex[id]?.forEach {\n                moviesByIdIndex.remove(it.id)\n            }\n            moviesByRatingIdIndex.remove(id)\n            ok(1)\n        }\n\n    private fun insertMovies(vararg newMovies: Movie) {\n        newMovies.forEach { movie -&gt;\n            moviesByIdIndex[movie.id] = movie\n            moviesByRatingIdIndex.getOrCreate(movie.ratingId).add(movie)\n        }\n    }\n\n    private fun insertActors(vararg newActors: Actor) {\n        newActors.forEach { actor -&gt;\n            actorsByIdIndex[actor.id] = actor\n        }\n    }\n    private fun insertRatings(vararg newRatings: Rating) {\n        newRatings.forEach { rating -&gt;\n            ratingsByIdIndex[rating.id] = rating\n        }\n    }\n\n    private fun insertRoles(vararg newRoles: Role) {\n        newRoles.forEach { role -&gt;\n            rolesByActorIdIndex.getOrCreate(role.actorId).add(role)\n            rolesByMovieIdIndex.getOrCreate(role.movieId).add(role)\n        }\n    }\n    private fun &lt;K, V&gt; MutableMap&lt;K, MutableList&lt;V&gt;&gt;.getOrCreate(key: K) =\n        this[key] ?: mutableListOf&lt;V&gt;().apply {\n            this@getOrCreate[key] = this\n        }\n\n    @GET\n    @Path(\"reset\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun resetDatabase(): Response {\n        ratingsByIdIndex.clear()\n        moviesByIdIndex.clear()\n        actorsByIdIndex.clear()\n        rolesByActorIdIndex.clear()\n        rolesByMovieIdIndex.clear()\n        moviesByRatingIdIndex.clear()\n\n        insertRatings(\n            Rating(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            Rating(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            Rating(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            Rating(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            Rating(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n\n        insertMovies(\n            Movie(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            Movie(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            Movie(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            Movie(\"m4\", \"Jumanji\", \"The Rock smolders\", \"r3\"),\n        )\n\n        insertActors(\n            Actor(\"a1\", \"Jason Statham\"),\n            Actor(\"a2\", \"The Rock\"),\n            Actor(\"a3\", \"Shu Qi\"),\n            Actor(\"a4\", \"Amber Valletta\"),\n            Actor(\"a5\", \"Kevin Hart\"),\n        )\n        insertRoles(\n            Role(\"m1\", \"a1\", \"Frank Martin\", 1),\n            Role(\"m1\", \"a3\", \"Lai\", 2),\n            Role(\"m2\", \"a1\", \"Frank Martin\", 1),\n            Role(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            Role(\"m3\", \"a2\", \"Hobbs\", 1),\n            Role(\"m3\", \"a1\", \"Shaw\", 2),\n            Role(\"m4\", \"a2\", \"Spencer\", 1),\n            Role(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n        return ok(1)\n    }\n}</pre> <p>In the controller, we define the base path to use</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RestController.kt <pre>// ...\nprivate val notFoundRatingWithMovies = RatingWithMovies(notFoundRating, emptyList())\n\n@Path(\"/\")\nclass RestController {\n    @GET\n    @Path(\"rating\")\n    // ...\n}</pre> <p>and for each function we want to expose, we define the HTTP method type and extended path</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RestController.kt <pre>// ...\n\n@Path(\"/\")\nclass RestController {\n    @GET\n    @Path(\"rating\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getRatings(): Response = ok(ratingsByIdIndex.values.sortedBy { it.id })\n\n    @GET\n    // ...\n}</pre> <p>Functions can also have parameters, which Jersey will parse based on the path, then pass to the function</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RestController.kt <pre>// ...\n\n@Path(\"/\")\nclass RestController {\n    // ...\n    fun getActors(): Response = ok(actorsByIdIndex.values.sortedBy { it.name })\n\n    @GET\n    @Path(\"rating/{id}/movies\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getRatingWithMovies(@PathParam(\"id\") id: String): RatingWithMovies =\n        ratingsByIdIndex[id]?.let { rating -&gt;\n            val movies = moviesByRatingIdIndex[id] ?: emptyList()\n            RatingWithMovies(rating, movies)\n        } ?: notFoundRatingWithMovies\n\n    @GET\n    // ...\n}</pre> <p>I've created some helper functions to simplify setting up the response to send back to the client.</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RestController.kt <pre>// ...\n//       important for the class. The important thing is how we\n//       can communicate with the server\nprivate fun &lt;T&gt; response(status: Response.Status, entity: T) =\n    Response.status(status).entity(entity).build()\n\nprivate fun &lt;T&gt; ok(entity: T) =\n    response(Response.Status.OK, entity)\n\nprivate fun &lt;T&gt; notFound(entity: T) =\n    response(Response.Status.NOT_FOUND, entity)\n\nprivate fun &lt;T&gt; created(entity: T) =\n    response(Response.Status.CREATED, entity)\n\n\n// ...</pre> <p>Finally, we set up the actual server runner code</p> show in full file  restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RunServer.kt <pre>// ...\nimport jakarta.ws.rs.ext.Provider\n\n// from https://mkyong.com/webservices/jax-rs/json-example-with-jersey-jackson/\n// MIT License\n//\n//  Copyright (c) 2020 Mkyong.com\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \u201cSoftware\u201d), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nclass RunServer {\n    companion object {\n        @JvmStatic\n        fun main(args: Array&lt;String&gt;) {\n//          println(\"It runs!\")\n            GrizzlyHttpServerFactory\n                .createHttpServer(\n                    URI.create(\"http://localhost:8080\"),\n                    ResourceConfig().apply {\n                        register(RestController::class.java)\n                        register(CustomJacksonMapperProvider::class.java)\n                    }\n                ).start()\n        }\n    }\n}\n\n@Provider\nclass CustomJacksonMapperProvider : ContextResolver&lt;ObjectMapper&gt; {\n    private val mapper = ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT)\n    override fun getContext(type: Class&lt;*&gt;?) = mapper\n}\n</pre> <p>When we run the server using</p> <pre><code>./gradlew run\n</code></pre> <p>we'll see</p> <pre><code>Dec 01, 2024 4:28:42 PM org.glassfish.jersey.server.wadl.WadlFeature configure\nWARNING: JAXBContext implementation could not be found. WADL feature is disabled.\nDec 01, 2024 4:28:43 PM org.glassfish.grizzly.http.server.NetworkListener start\nINFO: Started listener bound to [localhost:8080]\nDec 01, 2024 4:28:43 PM org.glassfish.grizzly.http.server.HttpServer start\nINFO: [HttpServer] Started.\n&lt;==========---&gt; 83% EXECUTING [18s]\n&gt; :restserver:run\n</code></pre> <p>which indicates where you'll point your browser, http://localhost:8080, for the root of the server.</p> <p>If we browse to http://localhost:8080/movie, we'll see</p> <pre><code>[ ]\n</code></pre> <p>The movie list is currently empty, so we need to reset the \"database\" by browsing to http://localhost:8080/reset, which displays <code>1</code> for success.</p> <p>Now if we go to http://localhost:8080/movie, we see</p> <pre><code>[\n  {\n    \"id\": \"m3\",\n    \"title\": \"Hobbs and Shaw\",\n    \"description\": \"Cars, Explosions and Stuff\",\n    \"ratingId\": \"r3\"\n  },\n  {\n    \"id\": \"m4\",\n    \"title\": \"Jumanji\",\n    \"description\": \"The Rock smolders\",\n    \"ratingId\": \"r3\"\n  },\n  {\n    \"id\": \"m1\",\n    \"title\": \"The Transporter\",\n    \"description\": \"Jason Statham kicks a guy in the face\",\n    \"ratingId\": \"r3\"\n  },\n  {\n    \"id\": \"m2\",\n    \"title\": \"Transporter 2\",\n    \"description\": \"Jason Statham kicks a bunch of guys in the face\",\n    \"ratingId\": \"r4\"\n  }\n]\n</code></pre> <p>returned from the server.</p> <p>We've also included a function to fetch a specific movie (but we skipped actor and rating as we did when not implementing their edit screens). If we go to http://localhost:8080/movie/m3, we see</p> <pre><code>{\n  \"id\" : \"m3\",\n  \"title\" : \"Hobbs and Shaw\",\n  \"description\" : \"Cars, Explosions and Stuff\",\n  \"ratingId\" : \"r3\"\n}\n</code></pre> <p>Now that we have a server, we can implement a repository that makes REST requests to it.</p> <p>Note</p> <p>Because this is an in-memory server with no disk backup, you'll need to reset the data whenever the server is restarted.</p> All code changes ADDED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Actor.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nimport com.fasterxml.jackson.annotation.JsonProperty\nimport jakarta.xml.bind.annotation.XmlRootElement\nimport java.util.UUID\n\n@XmlRootElement\ndata class Actor(\n    @JsonProperty(\"id\") var id: String = UUID.randomUUID().toString(),\n    @JsonProperty(\"name\") var name: String\n)\n\n@XmlRootElement\ndata class ActorWithFilmography(\n    @JsonProperty(\"actor\") val actor: Actor,\n    @JsonProperty(\"filmography\") val filmography: List&lt;RoleWithMovie&gt;,\n)\n\n@XmlRootElement\ndata class RoleWithMovie(\n    @JsonProperty(\"movie\") val movie: Movie,\n    @JsonProperty(\"character\") val character: String,\n    @JsonProperty(\"orderInCredits\") val orderInCredits: Int,\n)\n</pre> ADDED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Movie.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nimport com.fasterxml.jackson.annotation.JsonProperty\nimport jakarta.xml.bind.annotation.XmlRootElement\nimport java.util.UUID\n\n@XmlRootElement\ndata class Movie(\n    @JsonProperty(\"id\") val id: String = UUID.randomUUID().toString(),\n    @JsonProperty(\"title\") val title: String,\n    @JsonProperty(\"description\") val description: String,\n    @JsonProperty(\"ratingId\") val ratingId: String,\n)\n\n@XmlRootElement\ndata class MovieWithCast(\n    @JsonProperty(\"movie\") val movie: Movie,\n    @JsonProperty(\"cast\") val cast: List&lt;RoleWithActor&gt;,\n)\n\n@XmlRootElement\ndata class RoleWithActor(\n    @JsonProperty(\"actor\") val actor: Actor,\n    @JsonProperty(\"character\") val character: String,\n    @JsonProperty(\"orderInCredits\") val orderInCredits: Int,\n)\n</pre> ADDED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Rating.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nimport com.fasterxml.jackson.annotation.JsonProperty\nimport jakarta.xml.bind.annotation.XmlRootElement\nimport java.util.UUID\n\n@XmlRootElement\ndata class Rating(\n    @JsonProperty(\"id\") val id: String = UUID.randomUUID().toString(),\n    @JsonProperty(\"name\") val name: String,\n    @JsonProperty(\"description\") val description: String\n)\n\n@XmlRootElement\ndata class RatingWithMovies(\n    @JsonProperty(\"rating\") var rating: Rating,\n    @JsonProperty(\"movies\") var movies: List&lt;Movie&gt;,\n)\n</pre> ADDED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RestController.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nimport jakarta.ws.rs.Consumes\nimport jakarta.ws.rs.DELETE\nimport jakarta.ws.rs.GET\nimport jakarta.ws.rs.POST\nimport jakarta.ws.rs.PUT\nimport jakarta.ws.rs.Path\nimport jakarta.ws.rs.PathParam\nimport jakarta.ws.rs.Produces\nimport jakarta.ws.rs.core.Context\nimport jakarta.ws.rs.core.MediaType\nimport jakarta.ws.rs.core.Response\nimport jakarta.ws.rs.core.UriInfo\n\n\n// NOTE: If Room were cross platform I would have directly used\n//       our data module to store things in a database in this\n//       server. Unfortunately, it's Android-only, so I'm\n//       implementing an in-memory set of maps to track the\n//       data. Kinda gross, but developing a real server isn't\n//       important for the class. The important thing is how we\n//       can communicate with the server\nprivate fun &lt;T&gt; response(status: Response.Status, entity: T) =\n    Response.status(status).entity(entity).build()\n\nprivate fun &lt;T&gt; ok(entity: T) =\n    response(Response.Status.OK, entity)\n\nprivate fun &lt;T&gt; notFound(entity: T) =\n    response(Response.Status.NOT_FOUND, entity)\n\nprivate fun &lt;T&gt; created(entity: T) =\n    response(Response.Status.CREATED, entity)\n\n\nprivate val moviesByIdIndex = mutableMapOf&lt;String, Movie&gt;()\nprivate val actorsByIdIndex = mutableMapOf&lt;String, Actor&gt;()\nprivate val ratingsByIdIndex = mutableMapOf&lt;String, Rating&gt;()\nprivate val rolesByMovieIdIndex = mutableMapOf&lt;String, MutableList&lt;Role&gt;&gt;()\nprivate val rolesByActorIdIndex = mutableMapOf&lt;String, MutableList&lt;Role&gt;&gt;()\nprivate val moviesByRatingIdIndex = mutableMapOf&lt;String, MutableList&lt;Movie&gt;&gt;()\n\nprivate val notFoundRating = Rating(\"-\", \"NOT FOUND\", \"NOT FOUND\")\nprivate val notFoundMovie = Movie(\"-\", \"NOT FOUND\", \"NOT FOUND\", \"--\")\nprivate val notFoundMovieWithRoles = MovieWithCast(notFoundMovie, emptyList())\nprivate val notFoundActor = Actor(\"-\", \"NOT FOUND\")\nprivate val notFoundActorWithRoles = ActorWithFilmography(notFoundActor, emptyList())\nprivate val notFoundRatingWithMovies = RatingWithMovies(notFoundRating, emptyList())\n\n@Path(\"/\")\nclass RestController {\n    @GET\n    @Path(\"rating\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getRatings(): Response = ok(ratingsByIdIndex.values.sortedBy { it.id })\n\n    @GET\n    @Path(\"movie\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getMovies(): Response = ok(moviesByIdIndex.values.sortedBy { it.title })\n\n    @GET\n    @Path(\"movie/{id}\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getMovie(@PathParam(\"id\") id: String): Response =\n        ok(moviesByIdIndex[id])\n\n    @GET\n    @Path(\"actor\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getActors(): Response = ok(actorsByIdIndex.values.sortedBy { it.name })\n\n    @GET\n    @Path(\"rating/{id}/movies\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getRatingWithMovies(@PathParam(\"id\") id: String): RatingWithMovies =\n        ratingsByIdIndex[id]?.let { rating -&gt;\n            val movies = moviesByRatingIdIndex[id] ?: emptyList()\n            RatingWithMovies(rating, movies)\n        } ?: notFoundRatingWithMovies\n\n    @GET\n    @Path(\"movie/{id}/cast\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getMovieWithRoles(@PathParam(\"id\") id: String): MovieWithCast =\n        moviesByIdIndex[id]?.let { movie -&gt;\n            val roles =\n                rolesByMovieIdIndex[id]\n                    ?.map { role -&gt;\n                        RoleWithActor(\n                            actor = actorsByIdIndex[role.actorId] ?: throw IllegalStateException(),\n                            character = role.character,\n                            orderInCredits = role.orderInCredits,\n                        )\n                    }\n                    ?: emptyList()\n\n            MovieWithCast(movie, roles)\n        } ?: notFoundMovieWithRoles\n\n    @GET\n    @Path(\"actor/{id}/filmography\")\n    @Produces(MediaType.APPLICATION_JSON)\n    fun getActorWithRoles(@PathParam(\"id\") id: String): ActorWithFilmography =\n        actorsByIdIndex[id]?.let { actor -&gt;\n            val roles =\n                rolesByActorIdIndex[id]\n                    ?.map { role -&gt;\n                        RoleWithMovie(\n                            movie = moviesByIdIndex[role.movieId] ?: throw IllegalStateException(),\n                            character = role.character,\n                            orderInCredits = role.orderInCredits,\n                        )\n                    }\n                    ?: emptyList()\n            ActorWithFilmography(actor, roles)\n        } ?: notFoundActorWithRoles\n\n    @PUT\n    @Path(\"movie/{id}\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun updateMovie(@PathParam(\"id\") id: String, movie: Movie): Response {\n        moviesByIdIndex[id] = movie\n        moviesByRatingIdIndex.getOrPut(movie.ratingId) { mutableListOf() }.add(movie)\n        return ok(1)\n    }\n\n    @PUT\n    @Path(\"actor/{id}\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun updateActor(@PathParam(\"id\") id: String, actor: Actor): Response {\n        actorsByIdIndex[id] = actor\n        return ok(1)\n    }\n\n    @PUT\n    @Path(\"rating/{id}\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun updateRating(@PathParam(\"id\") id: String, rating: Rating): Response {\n        ratingsByIdIndex[id] = rating\n        return ok(1)\n    }\n\n    private operator fun MutableMap&lt;String, MutableMap&lt;String, Role&gt;&gt;.set(id1: String, id2: String, role: Role) {\n        val roles = this[id1] ?: mutableMapOf&lt;String, Role&gt;().apply { this@set[id1] = this }\n        roles[id2] = role\n    }\n\n    private operator fun MutableMap&lt;String, MutableMap&lt;String, Role&gt;&gt;.get(id1: String, id2: String) =\n        this[id1]?.get(id2)\n\n    @POST\n    @Path(\"rating/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun createRating(@Context uriInfo: UriInfo, rating: Rating): Response {\n        ratingsByIdIndex[rating.id] = rating\n        return created(rating)\n    }\n\n    @POST\n    @Path(\"movie/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun createMovie(@Context uriInfo: UriInfo, movie: Movie): Response {\n        moviesByIdIndex[movie.id] = movie\n        return created(movie)\n    }\n\n    @POST\n    @Path(\"actor/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun createActor(@Context uriInfo: UriInfo, actor: Actor): Response {\n        actorsByIdIndex[actor.id] = actor\n        return created(actor)\n    }\n\n    @DELETE\n    @Path(\"movie/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun deleteMovie(@PathParam(\"id\") id: String): Response =\n        if (moviesByIdIndex[id] == null) {\n            notFound(0)\n        } else {\n            moviesByIdIndex.remove(id)\n            moviesByRatingIdIndex.values.forEach { movies -&gt;\n                movies.removeIf { it.id == id}\n            }\n            rolesByMovieIdIndex.remove(id) // remove all roles\n            rolesByActorIdIndex.values.forEach { roles -&gt;\n                roles.removeIf { it.movieId == id }\n            }\n            ok(1)\n        }\n\n    @DELETE\n    @Path(\"actor/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun deleteActor(@PathParam(\"id\") id: String): Response =\n        if (actorsByIdIndex[id] == null) {\n            notFound(0)\n        } else {\n            actorsByIdIndex.remove(id)\n            rolesByActorIdIndex.remove(id) // remove all roles\n            rolesByMovieIdIndex.values.forEach { roles -&gt; // remove filmography for those movies\n                roles.removeIf { it.actorId == id }\n            }\n            ok(1)\n        }\n\n    @DELETE\n    @Path(\"rating/{id}\")\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Produces(MediaType.TEXT_PLAIN)\n    fun deleteRating(@PathParam(\"id\") id: String): Response =\n        if (ratingsByIdIndex[id] == null) {\n            notFound(0)\n        } else {\n            ratingsByIdIndex.remove(id)\n            // delete associated movies\n            moviesByRatingIdIndex[id]?.forEach {\n                moviesByIdIndex.remove(it.id)\n            }\n            moviesByRatingIdIndex.remove(id)\n            ok(1)\n        }\n\n    private fun insertMovies(vararg newMovies: Movie) {\n        newMovies.forEach { movie -&gt;\n            moviesByIdIndex[movie.id] = movie\n            moviesByRatingIdIndex.getOrCreate(movie.ratingId).add(movie)\n        }\n    }\n\n    private fun insertActors(vararg newActors: Actor) {\n        newActors.forEach { actor -&gt;\n            actorsByIdIndex[actor.id] = actor\n        }\n    }\n    private fun insertRatings(vararg newRatings: Rating) {\n        newRatings.forEach { rating -&gt;\n            ratingsByIdIndex[rating.id] = rating\n        }\n    }\n\n    private fun insertRoles(vararg newRoles: Role) {\n        newRoles.forEach { role -&gt;\n            rolesByActorIdIndex.getOrCreate(role.actorId).add(role)\n            rolesByMovieIdIndex.getOrCreate(role.movieId).add(role)\n        }\n    }\n    private fun &lt;K, V&gt; MutableMap&lt;K, MutableList&lt;V&gt;&gt;.getOrCreate(key: K) =\n        this[key] ?: mutableListOf&lt;V&gt;().apply {\n            this@getOrCreate[key] = this\n        }\n\n    @GET\n    @Path(\"reset\")\n    @Produces(MediaType.TEXT_PLAIN)\n    fun resetDatabase(): Response {\n        ratingsByIdIndex.clear()\n        moviesByIdIndex.clear()\n        actorsByIdIndex.clear()\n        rolesByActorIdIndex.clear()\n        rolesByMovieIdIndex.clear()\n        moviesByRatingIdIndex.clear()\n\n        insertRatings(\n            Rating(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            Rating(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            Rating(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            Rating(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            Rating(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n\n        insertMovies(\n            Movie(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            Movie(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            Movie(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            Movie(\"m4\", \"Jumanji\", \"The Rock smolders\", \"r3\"),\n        )\n\n        insertActors(\n            Actor(\"a1\", \"Jason Statham\"),\n            Actor(\"a2\", \"The Rock\"),\n            Actor(\"a3\", \"Shu Qi\"),\n            Actor(\"a4\", \"Amber Valletta\"),\n            Actor(\"a5\", \"Kevin Hart\"),\n        )\n        insertRoles(\n            Role(\"m1\", \"a1\", \"Frank Martin\", 1),\n            Role(\"m1\", \"a3\", \"Lai\", 2),\n            Role(\"m2\", \"a1\", \"Frank Martin\", 1),\n            Role(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            Role(\"m3\", \"a2\", \"Hobbs\", 1),\n            Role(\"m3\", \"a1\", \"Shaw\", 2),\n            Role(\"m4\", \"a2\", \"Spencer\", 1),\n            Role(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n        return ok(1)\n    }\n}\n</pre> ADDED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/Role.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nimport com.fasterxml.jackson.annotation.JsonProperty\nimport jakarta.xml.bind.annotation.XmlRootElement\n\n@XmlRootElement\nclass Role(\n    @JsonProperty(\"movieId\") var movieId: String,\n    @JsonProperty(\"actorId\") var actorId: String,\n    @JsonProperty(\"character\") var character: String,\n    @JsonProperty(\"orderInCredits\") var orderInCredits: Int\n)\n\n@XmlRootElement\nclass ExpandedRole(\n    @JsonProperty(\"movie\") var movie: Movie,\n    @JsonProperty(\"actor\") var actor: Actor,\n    @JsonProperty(\"character\") var character: String,\n    @JsonProperty(\"orderInCredits\") var orderInCredits: Int\n)\n</pre> CHANGED: restserver/src/main/java/com/androidbyexample/compose/movies/restserver/RunServer.kt <pre>package com.androidbyexample.compose.movies.restserver\n\nimport org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory\n\nimport org.glassfish.jersey.server.ResourceConfig\nimport java.net.URI\nimport com.fasterxml.jackson.databind.ObjectMapper\n\nimport com.fasterxml.jackson.databind.SerializationFeature\n\nimport jakarta.ws.rs.ext.ContextResolver\nimport jakarta.ws.rs.ext.Provider\n\n// from https://mkyong.com/webservices/jax-rs/json-example-with-jersey-jackson/\n// MIT License\n//\n//  Copyright (c) 2020 Mkyong.com\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \u201cSoftware\u201d), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nclass RunServer {\n    companion object {\n        @JvmStatic\n        fun main(args: Array&lt;String&gt;) {\n//          println(\"It runs!\")\n            GrizzlyHttpServerFactory\n                .createHttpServer(\n                    URI.create(\"http://localhost:8080\"),\n                    ResourceConfig().apply {\n                        register(RestController::class.java)\n                        register(CustomJacksonMapperProvider::class.java)\n                    }\n                ).start()\n        }\n    }\n}\n\n@Provider\nclass CustomJacksonMapperProvider : ContextResolver&lt;ObjectMapper&gt; {\n    private val mapper = ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT)\n    override fun getContext(type: Class&lt;*&gt;?) = mapper\n}\n\n</pre>"},{"location":"modules/movie-rest/STEP_040_REPO.html","title":"Server address","text":"<p>The first thing we need to think about is how the client will communicate with the server.</p> <p>If the server is running on a separate machine, the client can communicate with it using that machine's server name or IP address. But if we're running the server on the same machine as an emulator, what IP address do we use?</p> <p>You might think we'd use <code>127.0.0.1</code>. The problem is that if we use that on an Android device, it refers to the Android device itself. We want to connect to the computer that's hosting that Android device.</p> <p>Android defines <code>10.0.2.2</code> as the computer hosting the emulator. So our REST requests using this server and an emulator will look like <code>http://10.0.2.2:8080/movie</code>.</p> <p>If instead, you're running your application on a separate device or another computer, you would use the IP address of that computer. For example, if the computer was at 192.168.1.157 and the android device was on the same network, you could use <code>http://129.168.1.157:8080/movie</code></p> <p>Depending on how your application works, the server address might be hardcoded or set as a user option. For debugging, you may want to have the server name be different. To do this, we can set up <code>debug</code> and <code>release</code> source sets that define different versions of the same types or functions.</p> <p>These source sets are automatically defined; you just need to create the directories.</p> <p>We set up our project as follows:</p> <pre><code>movie-rest/\n    app/\n        src/\n            androidTest/...\n            debug/java/com/androidbyexample/compose/movies/\n                ServerInfo.kt\n            main/...\n            release/java/com/androidbyexample/compose/movies/\n                ServerInfo.kt\n            test/...\n</code></pre> <p>This allows us to define the contents of <code>ServerInfo.kt</code> differently if used for a debug build vs a release build. When building for debug, the code under the <code>app/src/main/debug</code> directory will be used. When building for release, the code under the <code>app/src/main/release</code> will be used.</p> <p>We'll use this for a simple <code>getServerAddress()</code> function:</p> show in full file  app/src/debug/java/com/androidbyexample/compose/movies/ServerInfo.kt <pre>package com.androidbyexample.compose.movies\n\nfun getServerAddress() = \"http://10.0.2.2:8080\"</pre> show in full file  app/src/release/java/com/androidbyexample/compose/movies/ServerInfo.kt <pre>package com.androidbyexample.compose.movies\n\nfun getServerAddress() = \"http://real.server.address:8080\"</pre> All code changes ADDED: app/src/debug/java/com/androidbyexample/compose/movies/ServerInfo.kt <pre>package com.androidbyexample.compose.movies\n\nfun getServerAddress() = \"http://10.0.2.2:8080\"\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.content.Intent\nimport android.os.Build\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.screens.MovieDisplay\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nconst val MOVIE_ID_EXTRA = \"movieId\"\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt; { MovieViewModel.Factory }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        intent.handleMovieId()\n\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Ui(\n                    viewModel = viewModel,\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    finish()\n                }\n            }\n        }\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        intent.handleMovieId()\n    }\n\n    private fun Intent.handleMovieId() {\n        val movieId = extras?.getString(MOVIE_ID_EXTRA)\n        if (movieId != null) {\n            viewModel.setScreens(MovieList, MovieDisplay(movieId))\n        }\n    }\n}\n</pre> ADDED: app/src/release/java/com/androidbyexample/compose/movies/ServerInfo.kt <pre>package com.androidbyexample.compose.movies\n\nfun getServerAddress() = \"http://real.server.address:8080\"\n</pre>"},{"location":"modules/movie-rest/STEP_050_REPO.html","title":"REST client repository","text":"<p>Now we'll add a new repository implementation (using the existing interface) to communicate with the server.</p> <p>Note</p> <p>This code is part of the Android application, not the rest server! Remember that we usually wouldn't place the rest server code in this project.</p> <p>Our Android client will use Retrofit 2 to communicate with the server, so we add the version, dependencies, and another bundle to our version catalog. Sync the application.</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\njersey=\"3.1.9\"\nactivation=\"2.1.3\"\nretrofit = \"2.9.0\"\n\n[libraries]\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\nretrofit-json = { group = \"com.squareup.retrofit2\", name = \"converter-gson\", version.ref = \"retrofit\" }\njersey-grizzly2 = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-grizzly2-http\", version.ref = \"jersey\" }\njersey-jetty = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-jetty-http\", version.ref = \"jersey\" }\n// ...\n\n[bundles]\nretrofit = [\n    \"retrofit\",\n    \"retrofit-json\"\n]\n\nserver = [\n    // ...\n[plugins]\n// ...</pre> <p>We add a bundle reference to the repository module's build script (and sync the app again)</p> show in full file  repository/build.gradle.kts <pre>// ...\ndependencies {\n    implementation(project(\":data\"))\n//\n    implementation(libs.bundles.retrofit)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    // ...\n}</pre> <p>Retrofit allows you to define REST calls using an annotated interface. The function definitions define parameters and return values, annotated with the server path used to access that data.</p> <p>Our functions return a <code>Response</code> instance that includes the status as well as data (if the call was successful).</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieApiService.kt <pre>// ...\nimport retrofit2.http.Path\n\ninterface MovieApiService {\n    @GET(\"movie\")\n    suspend fun getMovies(): Response&lt;List&lt;MovieDto&gt;&gt;\n\n    @GET(\"actor\")\n    suspend fun getActors(): Response&lt;List&lt;ActorDto&gt;&gt;\n\n    @GET(\"rating\")\n    suspend fun getRatings(): Response&lt;List&lt;RatingDto&gt;&gt;\n\n    @GET(\"rating/{id}/movies\")\n    suspend fun getRatingWithMovies(@Path(\"id\") id: String): Response&lt;RatingWithMoviesDto?&gt;\n    @GET(\"movie/{id}/cast\")\n    suspend fun getMovieWithCast(@Path(\"id\") id: String): Response&lt;MovieWithCastDto?&gt;\n    @GET(\"actor/{id}/filmography\")\n    suspend fun getActorWithFilmography(@Path(\"id\") id: String): Response&lt;ActorWithFilmographyDto?&gt;\n    @GET(\"movie/{id}\")\n    suspend fun getMovie(@Path(\"id\") id: String): Response&lt;MovieDto?&gt;\n\n    @POST(\"movie\")\n    suspend fun createMovie(@Body movie: MovieDto): Response&lt;MovieDto&gt;\n\n    @POST(\"actor\")\n    suspend fun createActor(@Body actor: ActorDto): Response&lt;ActorDto&gt;\n\n    @POST(\"rating\")\n    suspend fun createRating(@Body rating: RatingDto): Response&lt;RatingDto&gt;\n\n    @PUT(\"movie/{id}\")\n    suspend fun updateMovie(\n        @Path(\"id\") id: String,\n        @Body movie: MovieDto\n    ): Response&lt;Int&gt; // number updated\n\n    @PUT(\"actor/{id}\")\n    suspend fun updateActor(\n        @Path(\"id\") id: String,\n        @Body actor: ActorDto\n    ): Response&lt;Int&gt; // number updated\n\n    @PUT(\"rating/{id}\")\n    suspend fun updateRating(\n        @Path(\"id\") id: String,\n        @Body rating: RatingDto\n    ): Response&lt;Int&gt; // number updated\n\n    @DELETE(\"rating/{id}\")\n    suspend fun deleteRating(\n        @Path(\"id\") id: String,\n    ): Response&lt;Int&gt; // number deleted\n    @DELETE(\"movie/{id}\")\n    suspend fun deleteMovie(\n        @Path(\"id\") id: String,\n    ): Response&lt;Int&gt; // number deleted\n    @DELETE(\"actor/{id}\")\n    suspend fun deleteActor(\n        @Path(\"id\") id: String,\n    ): Response&lt;Int&gt; // number deleted\n\n    @GET(\"reset\")\n    suspend fun reset(): Response&lt;Int&gt;\n\n    companion object {\n        fun create(serverBaseUrl: String): MovieApiService =\n            Retrofit.Builder()\n                .addConverterFactory(GsonConverterFactory.create())\n                .baseUrl(serverBaseUrl)\n                .build()\n                .create(MovieApiService::class.java)\n    }\n}</pre> <p>We're passing in the server base URL to <code>create()</code>. This allows the main application to control the URL, which could be obtained from the function we defined for <code>debug</code> and <code>release</code> configurations, or a user setting defined in the UI.</p> <p>Retrofit will automatically marshall the <code>@Body</code> parameter objects to JSON, and unmarshall the returned JSON back into objects.</p> <p>Now we define the new concrete repository implementation</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRestRepository.kt <pre>// ...\nimport retrofit2.Response\n\nclass MovieRestRepository(\n    private val serverBaseUrl: String,\n): MovieRepository {\n    private lateinit var coroutineScope: CoroutineScope\n    private val allFlowManagers = mutableListOf&lt;FlowManager&lt;*&gt;&gt;()\n\n    inner class FlowManager&lt;T&gt;(\n        private val defaultValue: T,\n        private val fetcher: suspend () -&gt; Response&lt;T&gt;\n    ) {\n        private val _flow = MutableStateFlow(defaultValue)\n        init {\n            allFlowManagers.add(this)\n        }\n        val flow: Flow&lt;T&gt;\n            get() = _flow\n\n        fun fetch() =\n            coroutineScope.launch(Dispatchers.IO) {\n                _flow.value = fetcher().takeIf { it.isSuccessful }?.body() ?: defaultValue\n            }\n    }\n\n    override fun initialize(coroutineScope: CoroutineScope) {\n        this.coroutineScope = coroutineScope\n        allFlowManagers.forEach { it.fetch() }\n    }\n\n    private val movieApiService = MovieApiService.create(serverBaseUrl)\n\n    private val moviesFlowManager = FlowManager(emptyList()) { movieApiService.getMovies() }\n    private val actorsFlowManager = FlowManager(emptyList()) { movieApiService.getActors() }\n    private val ratingsFlowManager = FlowManager(emptyList()) { movieApiService.getRatings() }\n\n    override val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt; = ratingsFlowManager.flow\n    override val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt; = moviesFlowManager.flow\n    override val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt; = actorsFlowManager.flow\n\n    // NOTE: The following assume that only one of each is active at a time\n    //       For our app, that should be the case (the edit screens don't allow\n    //       any deeper navigation), but if you wanted to be more general, you\n    //       could set up a WeakHashMap where the key is the flow and the value\n    //       is the manager (which also has a weak reference to the Flow).\n    //       Weak references allow the object they point to to be garbage collected\n    //       when there are no remaining strong references to it, and they'll be removed\n    //       from the map when no longer referenced. You would then walk through all the\n    //       values in the map and call their fetch() functions.\n\n    private var ratingWithMoviesFlowManager: FlowManager&lt;RatingWithMoviesDto?&gt;? = null\n    // not implementing the ActorWithFilmographyDto and MovieWithCastDto versions\n    //   but they would be similar\n    override fun getRatingWithMoviesFlow(id: String) =\n        FlowManager(null) {\n            movieApiService.getRatingWithMovies(id)\n        }\n            .apply { fetch() } // start fetching\n            .let {\n                ratingWithMoviesFlowManager = it\n                it.flow // return the flow\n            }\n\n\n    private suspend fun &lt;T&gt; getOrError(\n        id: String,\n        fetch: suspend MovieApiService.(String) -&gt; Response&lt;T?&gt;\n    ): T = withContext(Dispatchers.IO) {\n        movieApiService.fetch(id).takeIf {\n            val code = it.code() // example of how to get the HTTP status\n            it.isSuccessful\n        }?.body()\n            ?: throw RuntimeException(\"$id not found\")\n    }\n\n    override suspend fun getRatingWithMovies(id: String) =\n        getOrError(id) { getRatingWithMovies(it) }\n\n    override suspend fun getMovieWithCast(id: String) =\n        getOrError(id) { getMovieWithCast(it) }\n\n    override suspend fun getActorWithFilmography(id: String) =\n        getOrError(id) { getActorWithFilmography(it) }\n\n    override suspend fun getMovie(id: String) =\n        getOrError(id) { getMovie(it) }\n\n    override suspend fun insert(movie: MovieDto) {\n        movieApiService.createMovie(movie)\n        moviesFlowManager.fetch()\n        ratingWithMoviesFlowManager?.fetch()\n    }\n\n    override suspend fun insert(actor: ActorDto) {\n        movieApiService.createActor(actor)\n        actorsFlowManager.fetch()\n    }\n\n    override suspend fun insert(rating: RatingDto) {\n        movieApiService.createRating(rating)\n        ratingsFlowManager.fetch()\n    }\n\n    override suspend fun upsert(movie: MovieDto) {\n        movieApiService.updateMovie(movie.id, movie)\n        moviesFlowManager.fetch()\n        ratingWithMoviesFlowManager?.fetch()\n    }\n\n    override suspend fun upsert(actor: ActorDto) {\n        movieApiService.updateActor(actor.id, actor)\n        actorsFlowManager.fetch()\n    }\n\n    override suspend fun upsert(rating: RatingDto) {\n        movieApiService.updateRating(rating.id, rating)\n        ratingsFlowManager.fetch()\n    }\n\n    private suspend fun deleteById(\n        ids: Set&lt;String&gt;,\n        delete: suspend MovieApiService.(String) -&gt; Unit,\n        vararg flowManagersToFetch: FlowManager&lt;*&gt;?,\n    ) {\n        ids.forEach { id -&gt;\n            movieApiService.delete(id)\n        }\n        flowManagersToFetch.forEach { it?.fetch() }\n    }\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) {\n        deleteById(ids, { deleteMovie(it) }, moviesFlowManager, ratingWithMoviesFlowManager)\n    }\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) {\n        deleteById(ids, { deleteActor(it) }, actorsFlowManager)\n    }\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) {\n        deleteById(ids, { deleteRating(it) }, ratingsFlowManager, moviesFlowManager)\n    }\n\n\n    override suspend fun resetDatabase() {\n        movieApiService.reset()\n        actorsFlowManager.fetch()\n        moviesFlowManager.fetch()\n        ratingsFlowManager.fetch()\n    }\n\n    companion object {\n        fun create(serverBaseUrl: String) =\n            MovieRestRepository(serverBaseUrl)\n    }\n}</pre> <p>I've defined a helper, <code>FlowManager</code> to simplify this repository. The <code>FlowManager</code> exposes a <code>Flow</code> that can be collected by a caller. (We see the similar <code>private</code>/<code>public</code> property pair so we can define a <code>MutableStateFlow</code> that can only be internally updated).</p> <p>The <code>FlowManager</code> also defines a constructor parameter, <code>fetcher</code>, which is a function passed in to specify how we request data from the server. This is called from the <code>fetch()</code> function, which launches a coroutine to perform the server request and drops the resulting data inside the <code>Flow</code>. For this example, we don't perform any error processing; if something goes wrong, we just emit the default value.</p> <p>We use the <code>FlowManager</code> to define the <code>Flows</code> required of <code>MovieRepository</code>. Any functions that request data modification on the server will call <code>fetch</code> on the affected <code>FlowManagers</code> to grab the data and trigger UI updates.</p> <p>Note that we must make a slight tweak in our existing <code>MovieRepository</code>. Because we're using a <code>MutableStateFlow</code> to emit the results of the REST call, we need an initial value; we'll use <code>null</code>. This means that the returned <code>Flow</code> from <code>getRatingWithMoviesFlow()</code> will be nullable.</p> <p>(There are other ways to do this is we wanted to keep the original interface contract, but <code>MutableStateFlow</code> is much simpler to use overall)</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\ninterface MovieRepository {\n    // ...\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n\n//  fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt;\n    fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto?&gt;\n\n    suspend fun getMovie(id: String): MovieDto\n    // ...\n}</pre> <p>The <code>MovieRestRepository</code> requires a <code>CoroutineScope</code> to perform its work. We want to use the <code>viewModelScope</code>, but we have a chicken-and-egg problem. We're passing the repository as a parameter to the view model, which means we don't have a view model when we create the repository, therefore we don't have the <code>viewModelScope</code>.</p> <p>To get around this, we'll add a new <code>initialize()</code> function</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\n\ninterface MovieRepository {\n    fun initialize(coroutineScope: CoroutineScope)\n\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    // ...\n}</pre> <p>that the view model can call to set the coroutine scope</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    // ...\n): AndroidViewModel(application), MovieRepository by repository {\n    // ...\n    private val ratingUpdateFlow = MutableStateFlow&lt;RatingDto?&gt;(null)\n    init {\n        if (repository is MovieRestRepository) {\n            repository.initialize(viewModelScope)\n        }\n\n        viewModelScope.launch {\n            // ...\n    }\n    // ...\n}</pre> <p>This means that we also have to tweak the existing <code>MovieDatabaseRepository</code></p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override fun initialize(coroutineScope: CoroutineScope) {\n        // nothing to do\n    }\n\n    override val ratingsFlow =\n        // ...\n}</pre> <p>Now, we can run the application. First, start the server:</p> <pre><code>./gradlew run\n</code></pre> <p>Once it reports</p> <pre><code>INFO: [HttpServer] Started\n</code></pre> <p>When we try to run the application, it will crash. Looking at the Logcat view in Studio, we'll see</p> <pre><code>java.net.UnknownServiceException: CLEARTEXT communication to 10.0.2.2 not permitted by network security policy\n</code></pre> <p>This is telling us that Android wants us to use HTTPS instead of HTTP to encrypt communication.</p> <p>I don't want to go into details on setting up Secure-Socket Layer (SSL) communication in this application. You can find that online if interested. For this sample, we'll just allow the unsecure comms.</p> <p>Warning</p> <p>Do not do this in real applications!!!</p> <p>We set this up in the manifest by adding <code>android:usesCleartextTraffic=\"true\"</code> to our <code>&lt;application&gt;</code> tag. </p> show in full file  app/src/main/AndroidManifest.xml <pre>// ...\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n    // ...\n    &lt;application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Movies\"\n        android:usesCleartextTraffic=\"true\"\n        tools:targetApi=\"31\"&gt;\n        &lt;activity\n            // ...\n    &lt;/application&gt;\n// ...\n&lt;/manifest&gt;</pre> <p>If we run the application now, it still doesn't work!. We'll get the cryptic</p> <pre><code>java.net.SocketException: socket failed: EPERM (Operation not permitted)\n</code></pre> <p>message. This is because we haven't told Android that we want to allow network communication.</p> <p>We do this by requesting <code>INTERNET</code> permission in the manifest</p> show in full file  app/src/main/AndroidManifest.xml <pre>// ...\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n\n    &lt;application\n        // ...\n&lt;/manifest&gt;</pre> <p>The <code>INTERNET</code> permission is not a \"dangerous\" permission, so we don't need to request access at runtime, just request it in the manifest.</p> <p>Now you can run the application as normal, and the data will come from the server instead of a local database.</p> All code changes CHANGED: app/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n\n    &lt;application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Movies\"\n        android:usesCleartextTraffic=\"true\"\n        tools:targetApi=\"31\"&gt;\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:launchMode=\"singleInstance\"\n            android:theme=\"@style/Theme.Movies\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;receiver android:name=\".glance.MovieAppWidgetReceiver\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /&gt;\n            &lt;/intent-filter&gt;\n            &lt;meta-data\n                android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/movies_app_widget_info\" /&gt;\n        &lt;/receiver&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.app.Application\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.glance.appwidget.updateAll\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.glance.MovieAppWidget\nimport com.androidbyexample.compose.movies.repository.ActorDto\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.repository.MovieRestRepository\nimport com.androidbyexample.compose.movies.repository.RatingDto\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\nimport kotlinx.coroutines.FlowPreview\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.flow.debounce\nimport kotlinx.coroutines.launch\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    application: Application,\n    private val repository: MovieRepository,\n): AndroidViewModel(application), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    fun setScreen(screen: Screen) {\n        screenStack = listOf(screen)\n    }\n\n    fun setScreens(vararg screens: Screen) {\n        screenStack = screens.toList()\n    }\n\n    fun update(movie: MovieDto) {\n        movieUpdateFlow.value = movie\n    }\n    fun update(actor: ActorDto) {\n        actorUpdateFlow.value = actor\n    }\n    fun update(rating: RatingDto) {\n        ratingUpdateFlow.value = rating\n    }\n    // using a debounced flow as a person-update queue\n    private val movieUpdateFlow = MutableStateFlow&lt;MovieDto?&gt;(null)\n    private val actorUpdateFlow = MutableStateFlow&lt;ActorDto?&gt;(null)\n    private val ratingUpdateFlow = MutableStateFlow&lt;RatingDto?&gt;(null)\n    init {\n        if (repository is MovieRestRepository) {\n            repository.initialize(viewModelScope)\n        }\n\n        viewModelScope.launch {\n            repository.moviesFlow.collectLatest {\n                MovieAppWidget().updateAll(getApplication())\n            }\n        }\n\n        viewModelScope.launch {\n            movieUpdateFlow.debounce(500).collect { movie -&gt;\n                movie?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            actorUpdateFlow.debounce(500).collect { actor -&gt;\n                actor?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            ratingUpdateFlow.debounce(500).collect { rating -&gt;\n                rating?.let { repository.upsert(it) }\n            }\n        }\n    }\n\n    fun deleteSelectedMovies() {\n        viewModelScope.launch {\n            deleteMoviesById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedActors() {\n        viewModelScope.launch {\n            deleteActorsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedRatings() {\n        viewModelScope.launch {\n            deleteRatingsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n//              val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                val application = checkNotNull(\n                    extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY]\n                )\n                return MovieViewModel(\n                    application,\n//                  MovieDatabaseRepository.create(application)\n                    MovieRestRepository.create(getServerAddress())\n                ) as T\n            }\n        }\n    }\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\nlifecycle-compose = \"2.8.7\"\nicons-extended = \"1.7.6\"\nglance=\"1.1.1\"\njetbrainsKotlinJvm = \"2.0.21\"\njersey=\"3.1.9\"\nactivation=\"2.1.3\"\nretrofit = \"2.9.0\"\n\n[libraries]\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\nretrofit-json = { group = \"com.squareup.retrofit2\", name = \"converter-gson\", version.ref = \"retrofit\" }\njersey-grizzly2 = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-grizzly2-http\", version.ref = \"jersey\" }\njersey-jetty = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-jetty-http\", version.ref = \"jersey\" }\njersey-servlet = { group = \"org.glassfish.jersey.containers\", name = \"jersey-container-servlet-core\", version.ref = \"jersey\" }\njersey-jackson = { group = \"org.glassfish.jersey.media\", name = \"jersey-media-json-jackson\", version.ref = \"jersey\" }\njersey-server = { group = \"org.glassfish.jersey.core\", name = \"jersey-server\", version.ref = \"jersey\" }\njersey-hk2 = { group = \"org.glassfish.jersey.inject\", name = \"jersey-hk2\", version.ref = \"jersey\" }\nactivation = { group = \"jakarta.activation\", name = \"jakarta.activation-api\", version.ref = \"activation\" }\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material3 = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended-android\", version.ref = \"icons-extended\"}\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[bundles]\nretrofit = [\n    \"retrofit\",\n    \"retrofit-json\"\n]\n\nserver = [\n    \"jersey-grizzly2\",\n    \"jersey-jetty\",\n    \"jersey-servlet\",\n    \"jersey-jackson\",\n    \"jersey-server\",\n    \"jersey-hk2\",\n    \"activation\"\n]\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\njetbrains-kotlin-jvm = { id = \"org.jetbrains.kotlin.jvm\", version.ref = \"jetbrainsKotlinJvm\" }\n</pre> CHANGED: repository/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.library)\n    alias(libs.plugins.kotlin.android)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies.repository\"\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        minSdk = libs.versions.minSdk.get().toInt()\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n        consumerProguardFiles(\"consumer-rules.pro\")\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n}\n\ndependencies {\n    implementation(project(\":data\"))\n//\n    implementation(libs.bundles.retrofit)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n}\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieApiService.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport retrofit2.Response\nimport retrofit2.Retrofit\nimport retrofit2.converter.gson.GsonConverterFactory\nimport retrofit2.http.Body\nimport retrofit2.http.DELETE\nimport retrofit2.http.GET\nimport retrofit2.http.POST\nimport retrofit2.http.PUT\nimport retrofit2.http.Path\n\ninterface MovieApiService {\n    @GET(\"movie\")\n    suspend fun getMovies(): Response&lt;List&lt;MovieDto&gt;&gt;\n\n    @GET(\"actor\")\n    suspend fun getActors(): Response&lt;List&lt;ActorDto&gt;&gt;\n\n    @GET(\"rating\")\n    suspend fun getRatings(): Response&lt;List&lt;RatingDto&gt;&gt;\n\n    @GET(\"rating/{id}/movies\")\n    suspend fun getRatingWithMovies(@Path(\"id\") id: String): Response&lt;RatingWithMoviesDto?&gt;\n    @GET(\"movie/{id}/cast\")\n    suspend fun getMovieWithCast(@Path(\"id\") id: String): Response&lt;MovieWithCastDto?&gt;\n    @GET(\"actor/{id}/filmography\")\n    suspend fun getActorWithFilmography(@Path(\"id\") id: String): Response&lt;ActorWithFilmographyDto?&gt;\n    @GET(\"movie/{id}\")\n    suspend fun getMovie(@Path(\"id\") id: String): Response&lt;MovieDto?&gt;\n\n    @POST(\"movie\")\n    suspend fun createMovie(@Body movie: MovieDto): Response&lt;MovieDto&gt;\n\n    @POST(\"actor\")\n    suspend fun createActor(@Body actor: ActorDto): Response&lt;ActorDto&gt;\n\n    @POST(\"rating\")\n    suspend fun createRating(@Body rating: RatingDto): Response&lt;RatingDto&gt;\n\n    @PUT(\"movie/{id}\")\n    suspend fun updateMovie(\n        @Path(\"id\") id: String,\n        @Body movie: MovieDto\n    ): Response&lt;Int&gt; // number updated\n\n    @PUT(\"actor/{id}\")\n    suspend fun updateActor(\n        @Path(\"id\") id: String,\n        @Body actor: ActorDto\n    ): Response&lt;Int&gt; // number updated\n\n    @PUT(\"rating/{id}\")\n    suspend fun updateRating(\n        @Path(\"id\") id: String,\n        @Body rating: RatingDto\n    ): Response&lt;Int&gt; // number updated\n\n    @DELETE(\"rating/{id}\")\n    suspend fun deleteRating(\n        @Path(\"id\") id: String,\n    ): Response&lt;Int&gt; // number deleted\n    @DELETE(\"movie/{id}\")\n    suspend fun deleteMovie(\n        @Path(\"id\") id: String,\n    ): Response&lt;Int&gt; // number deleted\n    @DELETE(\"actor/{id}\")\n    suspend fun deleteActor(\n        @Path(\"id\") id: String,\n    ): Response&lt;Int&gt; // number deleted\n\n    @GET(\"reset\")\n    suspend fun reset(): Response&lt;Int&gt;\n\n    companion object {\n        fun create(serverBaseUrl: String): MovieApiService =\n            Retrofit.Builder()\n                .addConverterFactory(GsonConverterFactory.create())\n                .baseUrl(serverBaseUrl)\n                .build()\n                .create(MovieApiService::class.java)\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport android.content.Context\nimport com.androidbyexample.compose.movies.data.MovieDao\nimport com.androidbyexample.compose.movies.data.createDao\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override fun initialize(coroutineScope: CoroutineScope) {\n        // nothing to do\n    }\n\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n\n    override fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt; =\n        dao.getRatingWithMoviesFlow(id)\n            .map { it.toDto() }\n\n    override suspend fun getMovie(id: String): MovieDto =\n        dao.getMovie(id).toDto()\n\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n\n    override suspend fun upsert(movie: MovieDto) = dao.upsert(movie.toEntity())\n    override suspend fun upsert(actor: ActorDto) = dao.upsert(actor.toEntity())\n    override suspend fun upsert(rating: RatingDto) = dao.upsert(rating.toEntity())\n\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) = dao.deleteMoviesById(ids)\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) = dao.deleteActorsById(ids)\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) = dao.deleteRatingsById(ids)\n\n    override suspend fun resetDatabase() = dao.resetDatabase()\n\n    companion object {\n        fun create(context: Context) =\n            MovieDatabaseRepository(createDao(context))\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.flow.Flow\n\ninterface MovieRepository {\n    fun initialize(coroutineScope: CoroutineScope)\n\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt;\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n\n//  fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt;\n    fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto?&gt;\n\n    suspend fun getMovie(id: String): MovieDto\n\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    suspend fun getMovieWithCast(id: String): MovieWithCastDto\n    suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto\n    suspend fun insert(movie: MovieDto)\n    suspend fun insert(actor: ActorDto)\n    suspend fun insert(rating: RatingDto)\n\n    suspend fun upsert(movie: MovieDto)\n    suspend fun upsert(actor: ActorDto)\n    suspend fun upsert(rating: RatingDto)\n\n    suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    suspend fun resetDatabase()\n}\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRestRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport retrofit2.Response\n\nclass MovieRestRepository(\n    private val serverBaseUrl: String,\n): MovieRepository {\n    private lateinit var coroutineScope: CoroutineScope\n    private val allFlowManagers = mutableListOf&lt;FlowManager&lt;*&gt;&gt;()\n\n    inner class FlowManager&lt;T&gt;(\n        private val defaultValue: T,\n        private val fetcher: suspend () -&gt; Response&lt;T&gt;\n    ) {\n        private val _flow = MutableStateFlow(defaultValue)\n        init {\n            allFlowManagers.add(this)\n        }\n        val flow: Flow&lt;T&gt;\n            get() = _flow\n\n        fun fetch() =\n            coroutineScope.launch(Dispatchers.IO) {\n                _flow.value = fetcher().takeIf { it.isSuccessful }?.body() ?: defaultValue\n            }\n    }\n\n    override fun initialize(coroutineScope: CoroutineScope) {\n        this.coroutineScope = coroutineScope\n        allFlowManagers.forEach { it.fetch() }\n    }\n\n    private val movieApiService = MovieApiService.create(serverBaseUrl)\n\n    private val moviesFlowManager = FlowManager(emptyList()) { movieApiService.getMovies() }\n    private val actorsFlowManager = FlowManager(emptyList()) { movieApiService.getActors() }\n    private val ratingsFlowManager = FlowManager(emptyList()) { movieApiService.getRatings() }\n\n    override val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt; = ratingsFlowManager.flow\n    override val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt; = moviesFlowManager.flow\n    override val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt; = actorsFlowManager.flow\n\n    // NOTE: The following assume that only one of each is active at a time\n    //       For our app, that should be the case (the edit screens don't allow\n    //       any deeper navigation), but if you wanted to be more general, you\n    //       could set up a WeakHashMap where the key is the flow and the value\n    //       is the manager (which also has a weak reference to the Flow).\n    //       Weak references allow the object they point to to be garbage collected\n    //       when there are no remaining strong references to it, and they'll be removed\n    //       from the map when no longer referenced. You would then walk through all the\n    //       values in the map and call their fetch() functions.\n\n    private var ratingWithMoviesFlowManager: FlowManager&lt;RatingWithMoviesDto?&gt;? = null\n    // not implementing the ActorWithFilmographyDto and MovieWithCastDto versions\n    //   but they would be similar\n    override fun getRatingWithMoviesFlow(id: String) =\n        FlowManager(null) {\n            movieApiService.getRatingWithMovies(id)\n        }\n            .apply { fetch() } // start fetching\n            .let {\n                ratingWithMoviesFlowManager = it\n                it.flow // return the flow\n            }\n\n\n    private suspend fun &lt;T&gt; getOrError(\n        id: String,\n        fetch: suspend MovieApiService.(String) -&gt; Response&lt;T?&gt;\n    ): T = withContext(Dispatchers.IO) {\n        movieApiService.fetch(id).takeIf {\n            val code = it.code() // example of how to get the HTTP status\n            it.isSuccessful\n        }?.body()\n            ?: throw RuntimeException(\"$id not found\")\n    }\n\n    override suspend fun getRatingWithMovies(id: String) =\n        getOrError(id) { getRatingWithMovies(it) }\n\n    override suspend fun getMovieWithCast(id: String) =\n        getOrError(id) { getMovieWithCast(it) }\n\n    override suspend fun getActorWithFilmography(id: String) =\n        getOrError(id) { getActorWithFilmography(it) }\n\n    override suspend fun getMovie(id: String) =\n        getOrError(id) { getMovie(it) }\n\n    override suspend fun insert(movie: MovieDto) {\n        movieApiService.createMovie(movie)\n        moviesFlowManager.fetch()\n        ratingWithMoviesFlowManager?.fetch()\n    }\n\n    override suspend fun insert(actor: ActorDto) {\n        movieApiService.createActor(actor)\n        actorsFlowManager.fetch()\n    }\n\n    override suspend fun insert(rating: RatingDto) {\n        movieApiService.createRating(rating)\n        ratingsFlowManager.fetch()\n    }\n\n    override suspend fun upsert(movie: MovieDto) {\n        movieApiService.updateMovie(movie.id, movie)\n        moviesFlowManager.fetch()\n        ratingWithMoviesFlowManager?.fetch()\n    }\n\n    override suspend fun upsert(actor: ActorDto) {\n        movieApiService.updateActor(actor.id, actor)\n        actorsFlowManager.fetch()\n    }\n\n    override suspend fun upsert(rating: RatingDto) {\n        movieApiService.updateRating(rating.id, rating)\n        ratingsFlowManager.fetch()\n    }\n\n    private suspend fun deleteById(\n        ids: Set&lt;String&gt;,\n        delete: suspend MovieApiService.(String) -&gt; Unit,\n        vararg flowManagersToFetch: FlowManager&lt;*&gt;?,\n    ) {\n        ids.forEach { id -&gt;\n            movieApiService.delete(id)\n        }\n        flowManagersToFetch.forEach { it?.fetch() }\n    }\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) {\n        deleteById(ids, { deleteMovie(it) }, moviesFlowManager, ratingWithMoviesFlowManager)\n    }\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) {\n        deleteById(ids, { deleteActor(it) }, actorsFlowManager)\n    }\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) {\n        deleteById(ids, { deleteRating(it) }, ratingsFlowManager, moviesFlowManager)\n    }\n\n\n    override suspend fun resetDatabase() {\n        movieApiService.reset()\n        actorsFlowManager.fetch()\n        moviesFlowManager.fetch()\n        ratingsFlowManager.fetch()\n    }\n\n    companion object {\n        fun create(serverBaseUrl: String) =\n            MovieRestRepository(serverBaseUrl)\n    }\n}\n</pre>"},{"location":"modules/movie-rest/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/movie-rest. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>movie-rest</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/movie-rest\n</code></pre>"},{"location":"modules/movie-ui-1/index.html","title":"Initial Movie UI","text":"<p>We'll start our Movie application with a very simple user interface.</p> <p> </p> <p>All data is hardcoded for this module; we're just creating a very basic user interface.</p> <p>We'll improve on the user interface in later modules.</p>"},{"location":"modules/movie-ui-1/STEP_020_REPO.html","title":"Update versions","text":"<p>Starting with a clean project, we need to update our versions to match those in Course hardware and software.</p> <p>Note</p> <p>If you do not have <code>gradle/libs.versions.toml</code> in your project, you didn't choose the Gradle Version Catalog option when creating your project. I recommend deleting the project and starting again, making sure you choose the version catalog option under Build configuration language.</p> <p>When I created this project using Android Studio Ladybug, I had to update the Compose BOM version in <code>gradle/libs.versions.toml</code>:</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n//agp = \"8.7.2\"\n//kotlin = \"2.0.0\"\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\n//composeBom = \"2024.04.01\"\ncomposeBom = \"2024.12.01\"\n\n[libraries]\n// ...\n[plugins]\n// ...</pre> <p>and the Android SDK version (<code>compileSdk</code> and <code>targetSdk</code>) in <code>app/build.versions.kts</code>:</p> show in full file  app/build.gradle.kts <pre>// ...\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n//  compileSdk = 34\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n        minSdk = 24\n//      targetSdk = 34\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n        // ...\n    }\n    // ...\n}\n// ...</pre> <p>Note</p> <p>See Android SDK settings for details on <code>compileSdk</code> and <code>targetSdk</code>.</p> <p>After updating the files, you'll need to re-synchronize them with Android Studio. Android Studio reads the build scripts to determine which modules and which dependencies are used so it can provide code-assist and lint checks in the IDE.</p> <p>Note</p> <p>Make sure you update to the versions specified in Course hardware and software! The versions you see here are the last ones I've edited, and may be a few terms old.</p> <p>When you change a build script, Android Studio will normally display a banner at the top of the file indicating that it needs to be re-synchronized, and you can click \"Sync Now\" to do so. Otherwise you can click the elephant icon on the toolbar to perform this synchronization.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n//  compileSdk = 34\n    compileSdk = 35\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n        minSdk = 24\n//      targetSdk = 34\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\n//agp = \"8.7.2\"\n//kotlin = \"2.0.0\"\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\n//composeBom = \"2024.04.01\"\ncomposeBom = \"2024.12.01\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n\n</pre>"},{"location":"modules/movie-ui-1/STEP_030_REPO.html","title":"Create data","text":"<p>Now we create some fake data to display Movies in the app. After we talk about databases, we'll convert the data into something real (and add Actors and Ratings).</p> <p>Create a <code>Movie</code> class. For now we just hold a title and description, but we'll add more when we create our database.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/Movie.kt <pre>package com.androidbyexample.compose.movieui1\n\ndata class Movie(\n    val title: String,\n    val description: String,\n)</pre> <p>Next, we create a <code>MovieViewModel</code> to hold a list of movies. View models prepare and provide data for our user interface to consume. Here we hardcode the data, but we'll change that in the database module.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nimport androidx.lifecycle.ViewModel\n\nclass MovieViewModel: ViewModel() {\n    val movies: List&lt;Movie&gt; = listOf(\n        Movie(\"The Transporter\", \"Jason Statham kicks a guy in the face\"),\n        Movie(\"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\"),\n        Movie(\"Hobbs and Shaw\", \"Cars, Explosions and Stuff\"),\n        Movie(\"Jumanji - Welcome to the Jungle\", \"The Rock smolders\"),\n    )\n}</pre> <p>Finally, we connect the view model to the <code>MainActivity</code>. Using the <code>viewModels</code> function creates a property delegate that will create an instance of the specified view model (if it doesn't exist), or fetch an existing one for the activity. This allows us to keep data across configuration changes, when the activity is destroyed and recreated.</p> <p>When adding the <code>viewModels</code> function, it'll show in red. Place your cursor on the word <code>viewModels</code> and press Alt+Enter to see your options. It'll show you an option to import the <code>viewModels</code> extension function. Selecting it will add an <code>import</code> at the top of the file and the error will go away.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>// ...\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt;()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n}\n// ...</pre> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\nimport com.androidbyexample.compose.movieui1.MovieViewModel\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt;()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n                    Greeting(\n                        name = \"Android\",\n                        modifier = Modifier.padding(innerPadding)\n                    )\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun Greeting(name: String, modifier: Modifier = Modifier) {\n    Text(\n        text = \"Hello $name!\",\n        modifier = modifier\n    )\n}\n\n@Preview(showBackground = true)\n@Composable\nfun GreetingPreview() {\n    MoviesTheme {\n        Greeting(\"Android\")\n    }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/Movie.kt <pre>package com.androidbyexample.compose.movieui1\n\ndata class Movie(\n    val title: String,\n    val description: String,\n)\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movieui1\n\nimport androidx.lifecycle.ViewModel\n\nclass MovieViewModel: ViewModel() {\n    val movies: List&lt;Movie&gt; = listOf(\n        Movie(\"The Transporter\", \"Jason Statham kicks a guy in the face\"),\n        Movie(\"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\"),\n        Movie(\"Hobbs and Shaw\", \"Cars, Explosions and Stuff\"),\n        Movie(\"Jumanji - Welcome to the Jungle\", \"The Rock smolders\"),\n    )\n}\n</pre>"},{"location":"modules/movie-ui-1/STEP_040_REPO.html","title":"Create initial screens","text":"<p>Let's create a starter user interface!</p> <p>In this step, we'll create placeholder screens and simple navigation.</p> <p>Note</p> <p>We'll be using a trivial custom navigation scheme for this class. It's not robust, though; you should look at available navigation frameworks (such as  Navigating with Compose or others. These can be complex, and everyone has their own preferences on which are the best. I didn't want to spend a lot of time on navigation in this class,  so I'm keeping it to a simple stack-based approach.</p> <p>To implement our simple navigation, we need to</p> <ul> <li>Define state representing our screens</li> <li>Create a private screen stack in the view model</li> <li>Expose the current top-of-stack screen for the UI to consume</li> <li>Choose the screen to display based on the screen state</li> </ul> <p>First, we create screen state using a Kotlin <code>sealed interface</code>. Sealed interfaces limit possible implementing classes or objects to only those defined in the current module. This is useful in applications or libraries because they know exhaustively which possible subclasses exist, and, in the case of a library, no external users can create new subclasses or implementations.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>// ...\nimport com.androidbyexample.compose.movies.Movie\n\nsealed interface Screen\ndata object MovieList: Screen\ndata class MovieDisplay(val movie: Movie): Screen</pre> <p>Note</p> <p>We're creating a file to hold all of these definitions together. In Kotlin, you can define multiple public types inside a single file (vs Java, where you can only have a single public type per file.)</p> <p>We're using a <code>data class</code> to represent a movie-display screen. Data classes automatically generate <code>equals()</code>, <code>hashCode()</code>, <code>toString()</code>, and some other interesting functions for all properties defined in their primary constructor. We'll use this to hold onto the movie that was selected.</p> <p>Holding onto the movie is not a good idea. If it changes in the data store, we won't be able to automatically load the changes in the UI. We'll fix this when we set up our database. For now, we pass the movie itself for convenience, as we're focusing on the user interface in this module.</p> <p>We use a Kotlin <code>data object</code> for the movie list state. Because the movie list will just display all movies, we don't need to keep any state (such as a specific movie id) in the screen instance for it.</p> <p>Kotlin <code>object</code>s are singletons; you never create instances of them and can access them globally. We could use a class here (without data) and create instances, but that doesn't do anything helpful, as all instances would be effectively equal. The <code>data</code> keyword adds the same generated functions for the <code>object</code> as it did the <code>class</code> above. </p> <p>In the view model, we add a screen stack to track screens that the user has visited. We keep this stack private; the IU doesn't need to know about it. This stack defines a <code>set()</code> function that updates the backing field, and sets the <code>currentScreen</code> property.</p> <p>The current screen property is delegated to a Compose <code>MutableState</code> so it can be accessed and observed for changes from the UI.</p> <p>Note the <code>private set</code> on <code>currentScreen</code> - this allows us to modify it from inside the view model, but it cannot be modified from outside.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n\nclass MovieViewModel: ViewModel() {\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            currentScreen = value.lastOrNull()\n        }\n\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        // ...\n}</pre> <p>Note</p> <p>When adding <code>mutableStateOf</code>, you'll end up with two errors. First, you'll need to import the function <code>mutableStateOf</code> by pressing ++alt+Enter++ on it. But it will stay red! Kotlin property delegation requires <code>getValue()</code> and <code>setValue()</code> functions be defined for the delegate, and <code>MutableState</code> doesn't have these functions. Instead, Compose defines <code>getValue()</code> and <code>setValue()</code> extension functions, but you need to explicitly import them. Press ++alt+Enter++ a second time on <code>mutableStateOf</code> to import these extension functions. You'll see them added to the <code>import</code>s at the top of the file.</p> <p>The last thing we need to do in the view model, is add external stack support so the UI can navigate to a new screen or go back to an existing screen. When these functions modify the stack, its <code>set()</code> updates <code>currentScreen</code> automatically.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nclass MovieViewModel: ViewModel() {\n    // ...\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    val movies: List&lt;Movie&gt; = listOf(\n        // ...\n}</pre> <p>Now let's define the placeholder user interfaces (UIs). We define simple movie display and movie list UIs as Composable functions.</p> <p>Note</p> <p>When you define Composable functions, you should always pass and respect a <code>Modifier</code>. This allows callers to tweak the appearance and behavior of the Composable you're defining. For example, in this application, we start with a top-level <code>Scaffold</code> that places other Composables on the screen. The <code>Scaffold</code> passes a parameter that defines the padding you must use in your main component, which you can pass along using <code>Modifier.padding()</code>.</p> <p>Modifiers should always be the first optional parameter to a Composable function, and usually default to <code>Modifier</code>.</p> <p>Warning</p> <p>Be sure to import <code>androidx.compose.ui.Modifier</code> and not <code>java.lang.reflect.Modifier</code>!</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\nimport com.androidbyexample.compose.movies.Movie\n\n@Composable\nfun MovieDisplayUi(\n    movie: Movie,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n        text = \"Movie Display: ${movie.title}\",\n        modifier = modifier,\n    )\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\nimport com.androidbyexample.compose.movies.Movie\n\n@Composable\nfun MovieListUi(\n    movies: List&lt;Movie&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (Movie) -&gt; Unit,\n) {\n    Text(\n        text = \"Movie List\",\n        modifier = modifier.clickable {\n            onMovieClicked(movies[0])\n        }\n    )\n}</pre> <p>Our <code>MovieDisplayUi()</code> composable function takes a <code>Movie</code> as a parameter and emits a single <code>Text()</code> to temporarily represent the screen. <code>MovieListUi()</code> takes a list of movies and a <code>onMovieClicked()</code> callback to indicate to the caller that a movie was selected by the user.</p> <p>For now, we just display \"Movie list\", and tell the caller that the first movie was clicked. (We'll flesh this out in a moment)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Text(\n        text = \"Movie List\",\n        modifier = modifier.clickable {\n            onMovieClicked(movies[0])\n        }\n    )\n}</pre> <p>Finally, we define a starter UI\") }}. I like to define a top-level composable function as a starting point. All it does is collect data from the view model and pass whatever is needed to the current screen.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\nimport com.androidbyexample.compose.movies.MovieViewModel\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                movie = screen.movie,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            MovieListUi(\n                movies = viewModel.movies,\n                modifier = modifier,\n            ) { movie -&gt;\n                viewModel.pushScreen(MovieDisplay(movie))\n            }\n        }\n    }\n}</pre> <p>If the current screen is <code>null</code>, that means we've popped all screens off the stack and should exit the application. This is done by passing an event function that calls <code>finish()</code> in the <code>MainActivity</code>. This pops the activity off the system's Activity stack. Because we only have a single activity on the system stack for this application, the system exits the application.</p> <p>Note that because we're inside a <code>Scaffold</code>, we take the inner padding it defines and pass it as a <code>Modifier.padding()</code> to our <code>Ui()</code> function. This is a great example why it's important to define a <code>Modifier</code> parameter in your Composable functions, as it allows us to adjust the <code>Ui</code>'s appearance.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        setContent {\n            MoviesTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  Greeting(\n//                      name = \"Android\",\n//                      modifier = Modifier.padding(innerPadding)\n//                  )\n                    Ui (\n                        viewModel = viewModel,\n                        modifier = Modifier.padding(innerPadding),\n                    ) {\n                        finish()\n                }\n            }\n        }\n    }\n    }\n}\n// ...</pre> <p>Note</p> <p>Following this approach, the top-level UI function should be the only composable function to be passed the view model. This ensures that lower-level composable functions are more easily testable, as you can pass them just the data they need, and not a view model that needs to be set up.</p> <p>This application can now be run, showing the placeholder movie list screen. When clicked, the placeholder movie display screen is pushed on the stack and becomes visible. When back is pressed, we return to the movie list screen. Pressing back again exits the application.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\n//import androidx.compose.material3.Text\n//import androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\n//import androidx.compose.ui.tooling.preview.Preview\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n//import com.androidbyexample.compose.movieui1.MovieViewModel\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt;()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  Greeting(\n//                      name = \"Android\",\n//                      modifier = Modifier.padding(innerPadding)\n//                  )\n                    Ui (\n                        viewModel = viewModel,\n                        modifier = Modifier.padding(innerPadding),\n                    ) {\n                        finish()\n                }\n            }\n        }\n    }\n    }\n}\n//\n//@Composable\n//fun Greeting(name: String, modifier: Modifier = Modifier) {\n//  Text(\n//      text = \"Hello $name!\",\n//      modifier = modifier\n//  )\n//}\n//\n//@Preview(showBackground = true)\n//@Composable\n//fun GreetingPreview() {\n//  MoviesTheme {\n//      Greeting(\"Android\")\n//  }\n//}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/Movie.kt <pre>//package com.androidbyexample.compose.movieui1\npackage com.androidbyexample.compose.movies\n\ndata class Movie(\n    val title: String,\n    val description: String,\n)\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>//package com.androidbyexample.compose.movieui1\npackage com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\n\nclass MovieViewModel: ViewModel() {\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            currentScreen = value.lastOrNull()\n        }\n\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    val movies: List&lt;Movie&gt; = listOf(\n        Movie(\"The Transporter\", \"Jason Statham kicks a guy in the face\"),\n        Movie(\"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\"),\n        Movie(\"Hobbs and Shaw\", \"Cars, Explosions and Stuff\"),\n        Movie(\"Jumanji - Welcome to the Jungle\", \"The Rock smolders\"),\n    )\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.Movie\n\n@Composable\nfun MovieDisplayUi(\n    movie: Movie,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n        text = \"Movie Display: ${movie.title}\",\n        modifier = modifier,\n    )\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.Movie\n\n@Composable\nfun MovieListUi(\n    movies: List&lt;Movie&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (Movie) -&gt; Unit,\n) {\n    Text(\n        text = \"Movie List\",\n        modifier = modifier.clickable {\n            onMovieClicked(movies[0])\n        }\n    )\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport com.androidbyexample.compose.movies.Movie\n\nsealed interface Screen\ndata object MovieList: Screen\ndata class MovieDisplay(val movie: Movie): Screen\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.MovieViewModel\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                movie = screen.movie,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            MovieListUi(\n                movies = viewModel.movies,\n                modifier = modifier,\n            ) { movie -&gt;\n                viewModel.pushScreen(MovieDisplay(movie))\n            }\n        }\n    }\n}\n</pre>"},{"location":"modules/movie-ui-1/STEP_050_REPO.html","title":"Refactor Scaffold Use","text":"<p>Before we flesh out the screens, we'll make a couple of helper functions and refactor our use of the <code>Scaffold</code>.</p> <p>First, we create a couple of helper components for consistency. <code>Display()</code> and <code>Label()</code> are just <code>Text()</code>s with some parameters set for styling and padding. Using this approach of creating wrapper functions gives us \"extended\" components.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/components/Display.kt <pre>// ...\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun Display(\n    text: String,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n        text = text,\n        style = MaterialTheme.typography.titleLarge,\n        modifier = modifier\n            .padding(8.dp)\n            .padding(start = 16.dp)\n            .fillMaxWidth(),\n    )\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/components/Label.kt <pre>// ...\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun Label(\n    @StringRes textId: Int,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n        text = stringResource(id = textId),\n        style = MaterialTheme.typography.titleMedium,\n        modifier = modifier\n            .padding(8.dp)\n            .fillMaxWidth(),\n    )\n}</pre> <p>Note</p> <p>Note how <code>Display</code> has two padding modifiers. These are applied in the order they're defined. In this case, we apply an 8dp padding all around, and then an extra 16dp padding only at the start of the text. This causes the text to appear indented.</p> <p>If we did something like</p> <pre><code>Modifier\n    .padding(8.dp)\n    .border(2.dp, Color.Blue, RoundedCornerShape(4.dp))\n    .padding(8.dp)\n</code></pre> <p>we'd see 8dp padding, a blue border inside it, and 8dp more padding inside the border. This is a much simpler system than the margin/padding combinations that existed with the old \"views\" UI approach.</p> <p>We're going to want more control of the <code>Scaffold</code>ing, per-screen, so we'll remove it from <code>MainActivity</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        setContent {\n            MoviesTheme {\n//              Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  Ui (\n                Ui(\n                        viewModel = viewModel,\n//                      modifier = Modifier.padding(innerPadding),\n                    ) {\n                        finish()\n                }\n//          }\n        }\n    }\n    }\n}</pre> <p>and add it in our <code>MovieDisplay()</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    // ...\n    modifier: Modifier = Modifier,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = movie.title)\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n    Text(\n        text = \"Movie Display: ${movie.title}\",\n//      modifier = modifier,\n            modifier = Modifier.padding(innerPadding),\n    )\n    }\n}</pre> <p>and our <code>MovieList()</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n    onMovieClicked: (Movie) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = stringResource(R.string.movies))\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n    Text(\n        text = \"Movie List\",\n//      modifier = modifier.clickable {\n            modifier = Modifier\n                .padding(innerPadding)\n                .clickable {\n            onMovieClicked(movies[0])\n        }\n    )\n    }\n}</pre> <p>Note that this also required moving the <code>Modifier.padding()</code> setup.</p> <p>The <code>Scaffold</code> is a \"Slot API\" composable function. This is an implementation of the Template Method Pattern, an algorithm with replaceable steps. The <code>Scaffold</code> defines an algorithm for managing several \"slots\" on the screen, areas like \"stuff at the top\", \"stuff at the bottom\", \"stuff in between\", etc. <code>Scaffold</code> defines the layout algorithm for measuring and placing elements in the specified position; you define what goes in those positions.</p> <p>In this example, we define <code>topBar</code>, passing a lambda for which elements should appear in that section of the <code>Scaffold</code>. When the scaffold is performing its layout work, it calls that lambda to obtain the components, measures them, and places them. (Note that some slotted apis may conditionally execute lambdas such as these; for example, if you define a navigation drawer, it might not appear unless the user has swiped in from the side.)</p> <p>Our <code>topBar</code> declares that a <code>TopAppBar</code> should appear. This is a common tool bar element, which can contain a title, navigation icon, and action icons. We'll do much more with it in later modules. Here we're just setting a title.</p> <p>Note</p> <p>Pay close attention to how the passed-in <code>Modifier</code> is being used. The caller may pass one in to control how the UI for <code>MovieDisplay()</code> or <code>MovieList()</code> appears. We pass the <code>modifier</code> parameter to the <code>Scaffold</code>, as that's the top-level Composable inside these functions.</p> <p>In the <code>Text()</code>, we start a new <code>Modifier</code> by using upper-case <code>Modifier</code>. This is a nested Composable that we want to fully control.</p> <p>For the <code>MovieList</code>, we need to define a <code>String</code> resource for the word \"Movies\". All <code>String</code> literals that appear for the user should be externalized into the <code>strings.xml</code> file:</p> show in full file  app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n&lt;/resources&gt;</pre> <p>This allows easy overriding for alternative device configurations, in particular, localization to other languages. We add a string entry to <code>strings.xml</code> with an id, and the Android Gradle Plugin generates a helper class for typesafe resource references. In our code, we use this generated <code>R</code> class using</p> <pre><code>stringResource(R.id.movies)\n</code></pre> <p>which will fetch the value from the closest-matching resource file.</p> <p>See [App Resources Overview] for more details on how resource files work. Note that some of the resource types, such as layouts, aren't used when writing Compose code.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\n//import androidx.compose.foundation.layout.fillMaxSize\n//import androidx.compose.foundation.layout.padding\n//import androidx.compose.material3.Scaffold\n//import androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt;()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n//              Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;\n//                  Ui (\n                Ui(\n                        viewModel = viewModel,\n//                      modifier = Modifier.padding(innerPadding),\n                    ) {\n                        finish()\n                }\n//          }\n        }\n    }\n    }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/components/Display.kt <pre>package com.androidbyexample.compose.movies.components\n\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun Display(\n    text: String,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n        text = text,\n        style = MaterialTheme.typography.titleLarge,\n        modifier = modifier\n            .padding(8.dp)\n            .padding(start = 16.dp)\n            .fillMaxWidth(),\n    )\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/components/Label.kt <pre>package com.androidbyexample.compose.movies.components\n\nimport androidx.annotation.StringRes\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun Label(\n    @StringRes textId: Int,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n        text = stringResource(id = textId),\n        style = MaterialTheme.typography.titleMedium,\n        modifier = modifier\n            .padding(8.dp)\n            .fillMaxWidth(),\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.Movie\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    movie: Movie,\n    modifier: Modifier = Modifier,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = movie.title)\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n    Text(\n        text = \"Movie Display: ${movie.title}\",\n//      modifier = modifier,\n            modifier = Modifier.padding(innerPadding),\n    )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.Movie\nimport com.androidbyexample.compose.movies.R\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;Movie&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (Movie) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = stringResource(R.string.movies))\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n    Text(\n        text = \"Movie List\",\n//      modifier = modifier.clickable {\n            modifier = Modifier\n                .padding(innerPadding)\n                .clickable {\n            onMovieClicked(movies[0])\n        }\n    )\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n&lt;/resources&gt;\n</pre>"},{"location":"modules/movie-ui-1/STEP_060_REPO.html","title":"Flesh out the screens","text":"<p>Now we flesh out the screens, making a very simple (but inefficient) list, and a simple display.</p> <p>Our <code>MovieDisplay</code> sets up a <code>Column</code> as the main content of the <code>Scaffold</code>. Note the <code>paddingValues</code> that are passed to the content lambda. These define the padding you must use to avoid overlapping with other slots in the <code>Scaffold</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    // ...\n) {\n    Scaffold(\n        // ...\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//  Text(\n//      text = \"Movie Display: ${movie.title}\",\n//          modifier = Modifier.padding(innerPadding),\n//  )\n        Column (\n            modifier = Modifier\n                .padding(innerPadding)\n                .verticalScroll(rememberScrollState())\n        ) {\n            Label (textId = R.string.title)\n            Display(text = movie.title)\n            Label(textId = R.string.description)\n            Display(text = movie.description)\n        }\n    }\n}</pre> <p>Our <code>Column</code> is scrollable and stacks <code>Label</code>s and <code>Display</code>s to show the details of a movie. (Be sure to use our <code>Label</code> instead of the Material3 <code>Label</code>)</p> <p><code>MovieListUi</code> is a bit more complex. It uses a <code>Scaffold</code> in the same way as <code>MovieDisplay</code>, but the contents of its column are dynamic. We iterate through the list of movies using <code>forEach</code>, and create a nice little <code>Card</code> for each movie, showing an icon and title.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Scaffold(\n        // ...\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//  Text(\n//      text = \"Movie List\",\n        Column (\n            modifier = Modifier\n                .padding(innerPadding)\n//              .clickable {\n//          onMovieClicked(movies[0])\n                .fillMaxSize()\n                .verticalScroll(rememberScrollState())\n        ) {\n            movies.forEach { movie -&gt;\n                Card (\n                    elevation = CardDefaults.cardElevation(\n                        defaultElevation = 8.dp,\n                    ),\n                    onClick = {\n                        onMovieClicked(movie)\n                    },\n                    modifier = Modifier.padding(8.dp)\n                ) {\n                    Row (\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(8.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Star,\n                            contentDescription = stringResource(id = R.string.movie)\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n//  )\n    }\n}</pre> <p>We make the icon and title line up nicely by adding an alignment specification.</p> <p>By defining <code>onClick</code> at the <code>Card</code> level,</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Scaffold(\n        // ...\n    ) { innerPadding -&gt;\n    // ...\n        Column (\n            // ...\n        ) {\n            movies.forEach { movie -&gt;\n                Card (\n                    // ...\n                        defaultElevation = 8.dp,\n                    ),\n                    onClick = {\n                        onMovieClicked(movie)\n                    },\n                    modifier = Modifier.padding(8.dp)\n                ) {\n                    // ...\n                }\n            }\n        }\n    // ...\n    }\n}</pre> <p>the user can click anywhere inside the card to select the movie. That click passes the movie for that card to <code>onMovieClicked()</code>, informing the caller that a movie has been selected.</p> <p>As usual, define any literal strings that the user will see in <code>app/src/main/res/values/strings.xml</code>.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt;()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Ui(\n                        viewModel = viewModel,\n                    ) {\n                        finish()\n                }\n        }\n    }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.Movie\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    movie: Movie,\n    modifier: Modifier = Modifier,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = movie.title)\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//  Text(\n//      text = \"Movie Display: ${movie.title}\",\n//          modifier = Modifier.padding(innerPadding),\n//  )\n        Column (\n            modifier = Modifier\n                .padding(innerPadding)\n                .verticalScroll(rememberScrollState())\n        ) {\n            Label (textId = R.string.title)\n            Display(text = movie.title)\n            Label(textId = R.string.description)\n            Display(text = movie.description)\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.Movie\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;Movie&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (Movie) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = stringResource(R.string.movies))\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//  Text(\n//      text = \"Movie List\",\n        Column (\n            modifier = Modifier\n                .padding(innerPadding)\n//              .clickable {\n//          onMovieClicked(movies[0])\n                .fillMaxSize()\n                .verticalScroll(rememberScrollState())\n        ) {\n            movies.forEach { movie -&gt;\n                Card (\n                    elevation = CardDefaults.cardElevation(\n                        defaultElevation = 8.dp,\n                    ),\n                    onClick = {\n                        onMovieClicked(movie)\n                    },\n                    modifier = Modifier.padding(8.dp)\n                ) {\n                    Row (\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(8.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Star,\n                            contentDescription = stringResource(id = R.string.movie)\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n//  )\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n&lt;/resources&gt;\n</pre>"},{"location":"modules/movie-ui-1/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/movie-ui-1. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>movie-ui-1</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/movie-ui-1\n</code></pre>"},{"location":"modules/movie-ui-2/index.html","title":"Overview","text":"<p>Now we'll use <code>LazyColumn</code> for more dynamic lists, and allow the user to select and delete list items.</p>"},{"location":"modules/movie-ui-2/STEP_020_REPO.html","title":"Convert to LazyColumn","text":"<p>Our first step to creating a dynamic UI is to change our normal <code>Column</code> to a <code>LazyColumn</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Scaffold(\n        // ...\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//      Column (\n        LazyColumn (\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n//              .verticalScroll(rememberScrollState())\n        ) {\n//          movies.forEach { movie -&gt;\n            items(\n                items = movies,\n                key = { it.id }\n            ) { movie -&gt;\n                Card (\n                    // ...\n            }\n        }\n    }\n}</pre> <p>Note</p> <p><code>LazyColumn</code> comes with its own scrolling. To make it work properly, you must remove the <code>verticalScroll</code> modifier when switching from <code>Column</code> to <code>LazyColumn</code>. </p> <p>The content lambda for <code>LazyColumn</code> contains an <code>items</code> call. Here we specify the list of items to use, and how to map an id to each. We know <code>MovieDto</code> has an id, so we can just use it as the <code>id</code> for the displayed row. Using a key allows <code>LazyColumn</code> to better optimize its recomposition of its rows, and later we'll see that it also supports animation of added or deleted rows.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\n//import androidx.compose.foundation.rememberScrollState\n//import androidx.compose.foundation.verticalScroll\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = stringResource(R.string.movies))\n                },\n                actions = {\n                    IconButton (onClick = onResetDatabase) {\n                        Icon(\n                            imageVector = Icons.Default.Refresh,\n                            contentDescription = stringResource(R.string.reset_database)\n                        )\n                    }\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//      Column (\n        LazyColumn (\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n//              .verticalScroll(rememberScrollState())\n        ) {\n//          movies.forEach { movie -&gt;\n            items(\n                items = movies,\n                key = { it.id }\n            ) { movie -&gt;\n                Card (\n                    elevation = CardDefaults.cardElevation(\n                        defaultElevation = 8.dp,\n                    ),\n                    onClick = {\n                        onMovieClicked(movie)\n                    },\n                    modifier = Modifier.padding(8.dp)\n                ) {\n                    Row (\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(8.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Star,\n                            contentDescription = stringResource(id = R.string.movie)\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n    }\n}\n</pre>"},{"location":"modules/movie-ui-2/STEP_030_REPO.html","title":"Selection Tracking","text":"<p>Now let's set up item selection. We'll use the common approach of</p> <ul> <li>Tapping the icon or long-pressing anywhere in the row toggles the selection</li> <li>Tapping in the row anywhere except the icon:<ul> <li>if any items are selected, toggle this item</li> <li>if no items are selected, trigger navigation</li> </ul> </li> </ul> <p>First, we need to track the selections somewhere. Selections are data that are typically not kept between runs of an application, so there's no need to store them in the database.</p> <p>But we usually want selections to persist across configuration changes (such as device rotation), so the View Model is a good choice to hold them.</p> <p>We're going to use a Kotlin <code>Flow</code> to track\" the set of selected ids. <code>MutableStateFlow</code> holds onto a single emitted item (in this case, a <code>Set</code> of selected ids) that can be collected by the UI and its value accessed/set via its <code>value</code> property.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        // ...\n}</pre> <p>We're defining two <code>Flow</code>s here:</p> <ul> <li> <p><code>_selectedIdsFlow</code> - this is private and can only be accessed by the view model. We don't      want the UI to be able to directly modify things in the view model. The UI should call      functions that give us more control over how updates are made.</p> </li> <li> <p><code>selectedIdsFlow</code> - we expose the <code>MutableStateFlow</code> as a non-mutable <code>Flow</code> by calling      <code>asStateFlow()</code> on <code>_selectedIdsFlow</code>. This property is public and can be collected from      the UI.</p> </li> </ul> <p>You may ask \"why not use a <code>MutableState</code>? You could do that here instead of creating a <code>Flow</code>. It would look similar to our <code>currentScreen</code> property, which we added before we started talking about <code>Flow</code>s.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nclass MovieViewModel(\n    // ...\n): ViewModel(), MovieRepository by repository {\n    // ...\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n    // ...\n}</pre> <p><code>currentScreen</code> is exposed to the UI but only read-only. Using <code>private set</code>  makes the setter function private, only accessible to the view model.</p> <p>The <code>currentScreen</code> approach code ends up being simpler as well - there's no need to collect the <code>Flow</code> in the UI; you just reference <code>selectedIds</code>.</p> <p>In fact, I'd recommend converting <code>currentScreen</code> to use a <code>Flow</code> (but will leave it here for comparison).</p> <p>So why use a <code>Flow</code> instead of a <code>MutableState</code>?</p> <p>Part of this is \"purity\" - using <code>State</code> in a view model leaks some of the way we're implementing our UI into the view model.</p> <p>Note</p> <p>Technically, <code>State</code> is part of compose-runtime, which is responsible for creating/managing trees and state. It isn't a \"UI thing\" and could be used for data management at any level.</p> <p>Unfortunately, there are some close ties with compose-ui, as well as the perception that <code>State</code> is a \"UI thing\". Thus, I recommend avoiding its use in view models (or further down, such as the repository or data modules).</p> <p>The other part of this is potential reuse. If you use <code>State</code> inside your view model, your view model will only work where Compose can run. If you use <code>Flow</code>s, the view model will work wherever Kotlin can run.</p> <p>This opens up the ability to use the same view model logic on Android, iOS, desktop app, web app, or even command-line ui. (My hope is that over time, Kotlin logic will be used across many platforms. Kotlin Multiplatform is getting there...)</p> <p>To keep the purity, we'll use <code>Flow</code>s to expose data from the view model from now on. (I also hope to create a Kotlin Multiplatform course soon so we can explore this more!)</p> <p>The last thing we need to do in the view model is add some selection management functions. This will allow the UI to ask us to clear the selections and toggle a single selection.</p> <p>It's also a good idea to clear the selections whenever the user changes screens. We can do this by adding a call to <code>clearSelectedIds()</code> in the setter for our <code>screenStack</code>. Be sure to do this before the actual screen changes.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nclass MovieViewModel(\n    // ...\n): ViewModel(), MovieRepository by repository {\n    // ...\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n    // ...\n}</pre> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\n\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}\n</pre>"},{"location":"modules/movie-ui-2/STEP_040_REPO.html","title":"Selections in the UI","text":"<p>Let's integrate selections into the UI.</p> <p>First, we add parameters to our <code>MovieListUi</code> composable function. These parameters give the function</p> <ul> <li><code>selectedIds</code> - the set of selections so we know what to highlight</li> <li><code>onSelectionToggle</code> - allows the function to request to toggle a selection</li> <li><code>onClearSelections</code> - allows the function to request all selections be cleared</li> </ul> <p>We choose the color of each card based on its selection status. (Note that <code>contentColorFor</code> will only work if the color passed in is defined in the theme. In this case, we're using <code>secondary</code> and <code>surface</code> colors from the theme so it'll work.)</p> <p>We tell the <code>Card</code> which colors to use for its background, <code>containerColor</code> and foreground, <code>contentColor</code>. The contentColor will be used for any nested text or icons.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n//@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        // ...\n    ) { innerPadding -&gt;\n        LazyColumn (\n            // ...\n        ) {\n            items(\n                // ...\n                key = { it.id }\n            ) { movie -&gt;\n                val containerColor =\n                    if (movie.id in selectedIds) {\n                        MaterialTheme.colorScheme.secondary\n                    } else {\n                        MaterialTheme.colorScheme.surface\n                    }\n                val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n\n                Card (\n                    // ...\n                        defaultElevation = 8.dp,\n                    ),\n//                  onClick = {\n//                      onMovieClicked(movie)\n//                  },\n                    colors = CardDefaults.cardColors(\n                        containerColor = containerColor,\n                        contentColor = contentColor,\n                    ),\n                    modifier = Modifier.padding(8.dp)\n                        .combinedClickable(\n                            // ...\n                ) {\n                    // ...\n                }\n            }\n        }\n    }\n}</pre> <p>We need to change the way clicks are handled to match our strategy. We'll do this for the</p> <ul> <li><code>Icon</code> - any clicks toggle the selection</li> <li><code>Card</code><ul> <li>any long-clicks toggle the selection</li> <li>any normal clicks<ul> <li>toggle the selection (if anything was selected), or</li> <li>navigate to the movie (if nothing was selected)</li> </ul> </li> </ul> </li> </ul> <p>We currently have an <code>onClick</code> defined on the <code>Card</code>, but because we want to handle both long and normal clicks, we need to switch to a <code>combinedClickable</code> modifier.</p> <p>We add a <code>clickable</code> modifier to the <code>Icon</code> to finish our click handling.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n//@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        // ...\n    ) { innerPadding -&gt;\n        LazyColumn (\n            // ...\n        ) {\n            items(\n                // ...\n            ) { movie -&gt;\n                // ...\n                Card (\n                    // ...\n                    ),\n                    modifier = Modifier.padding(8.dp)\n                        .combinedClickable(\n                            onClick = {\n                                if (selectedIds.isEmpty()) {\n                                    onMovieClicked(movie)\n                                } else {\n                                    onSelectionToggle(movie.id)\n                                }\n                            },\n                            onLongClick = {\n                                onSelectionToggle(movie.id)\n                            },\n                        )\n                ) {\n                    Row (\n                        // ...\n                    ) {\n                        Icon(\n                            // ...\n//                          contentDescription = stringResource(id = R.string.movie)\n                            contentDescription = stringResource(id = R.string.movie),\n                            modifier = Modifier.clickable {\n                                onSelectionToggle(movie.id)\n                            }\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n    }\n}</pre> <p>Finally, we collect the selection from the view model and wire up the new parameters in the <code>Ui</code> function.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        MovieList -&gt; {\n            // ...\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        // ...\n            )\n        }\n    }\n}</pre> <p>This gives us a movie list that allows us to select movies!</p> <p></p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n//@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = stringResource(R.string.movies))\n                },\n                actions = {\n                    IconButton (onClick = onResetDatabase) {\n                        Icon(\n                            imageVector = Icons.Default.Refresh,\n                            contentDescription = stringResource(R.string.reset_database)\n                        )\n                    }\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        LazyColumn (\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n        ) {\n            items(\n                items = movies,\n                key = { it.id }\n            ) { movie -&gt;\n                val containerColor =\n                    if (movie.id in selectedIds) {\n                        MaterialTheme.colorScheme.secondary\n                    } else {\n                        MaterialTheme.colorScheme.surface\n                    }\n                val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n\n                Card (\n                    elevation = CardDefaults.cardElevation(\n                        defaultElevation = 8.dp,\n                    ),\n//                  onClick = {\n//                      onMovieClicked(movie)\n//                  },\n                    colors = CardDefaults.cardColors(\n                        containerColor = containerColor,\n                        contentColor = contentColor,\n                    ),\n                    modifier = Modifier.padding(8.dp)\n                        .combinedClickable(\n                            onClick = {\n                                if (selectedIds.isEmpty()) {\n                                    onMovieClicked(movie)\n                                } else {\n                                    onSelectionToggle(movie.id)\n                                }\n                            },\n                            onLongClick = {\n                                onSelectionToggle(movie.id)\n                            },\n                        )\n                ) {\n                    Row (\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(8.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Star,\n//                          contentDescription = stringResource(id = R.string.movie)\n                            contentDescription = stringResource(id = R.string.movie),\n                            modifier = Modifier.clickable {\n                                onSelectionToggle(movie.id)\n                            }\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                }\n            )\n        }\n    }\n}\n</pre>"},{"location":"modules/movie-ui-2/STEP_050_REPO.html","title":"Contextual Top Bar","text":"<p>Now that we have selections, we can set up a contextual Top Bar to display the number of selections and an action to delete the selected items.</p> <p>Currently we have static top bar that displays the page title and an action to reset the database. We can make this contextual based on whether or not we have selections.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n//              title = {\n//                  Text(text = stringResource(R.string.movies))\n//              },\n                    title = { Text(text = stringResource(R.string.movies)) },\n                    actions = {\n//                  IconButton (onClick = onResetDatabase) {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = {\n                        Text(\n                            text = selectedIds.size.toString(),\n                            modifier = Modifier.padding(8.dp)\n                        )\n                    },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedMovies) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        // ...\n    }\n}</pre> <p>This requires some additional strings</p> show in full file  app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    // ...\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n    &lt;string name=\"cast_entry\"&gt;%1$s: %2$s&lt;/string&gt;\n    &lt;string name=\"clear_selections\"&gt;Clear Selections&lt;/string&gt;\n    &lt;string name=\"delete_selected_items\"&gt;Delete selected items&lt;/string&gt;\n&lt;/resources&gt;</pre> <p>and a new parameter to delete the selected movies when the trash can is clicked.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    // ...\n}</pre> <p>When there are items selected, the contextual top bar displays the number of selected items, a back arrow to clear the selections (returning to the normal top bar), and a trash can icon to delete selected items.</p> <p></p> <p>We added code to clear selections when the back arrow is pressed, but what if the user performs a back gesture (or presses the back button)? We can handle back using a <code>BackHandler</code> (surprise, surprise), calling <code>onClearSelections</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Scaffold(\n        // ...\n    ) { innerPadding -&gt;\n        LazyColumn (\n            // ...\n        ) {\n            items(\n                // ...\n            ) { movie -&gt;\n                // ...\n                val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n\n                if (selectedIds.isNotEmpty()) {\n                    BackHandler {\n                        onClearSelections()\n                    }\n                }\n\n                Card (\n                    // ...\n            }\n        }\n    }\n}</pre> <p>This back handler is only set up if there are any selected ids, and will override the back handler set up in <code>Ui</code>.</p> <p>Now we need to add \"delete by ids\" support.</p> <p>Add delete by id support to the Dao</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>// ...\n\n@Dao\nabstract class MovieDao {\n    // ...\n    abstract suspend fun insert(vararg roles: RoleEntity)\n\n    @Query(\"DELETE FROM MovieEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM ActorEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM RatingEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    @Query(\"DELETE FROM MovieEntity\")\n    // ...\n}</pre> <p>Expose these in <code>MovieRepository</code></p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\ninterface MovieRepository {\n    // ...\n    suspend fun insert(rating: RatingDto)\n\n    suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    suspend fun resetDatabase()\n}</pre> <p>Pass them through in the <code>MovieDatabaseRepository</code></p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nclass MovieDatabaseRepository(\n    // ...\n): MovieRepository {\n    // ...\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) = dao.deleteMoviesById(ids)\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) = dao.deleteActorsById(ids)\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) = dao.deleteRatingsById(ids)\n\n\n    // ...\n}</pre> <p>They'll automatically be passed through the view model (because we delegated <code>MovieRepository</code>).</p> <p>Add <code>deleteSelectedXXX</code> functions for movies, actors and ratings to the view model.</p> <p>Note</p> <p>The <code>deleteSelectedXXX</code> functions in the view model launch a coroutine using the <code>viewModelScope</code>. This coroutine scope lives as long as the view model lives. If we used <code>rememberCoroutineScope</code> in <code>MovieListUi</code>, any coroutines launched would be canceled when the user leaves the screen.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nclass MovieViewModel(\n    // ...\n): ViewModel(), MovieRepository by repository {\n    // ...\n    }\n\n    fun deleteSelectedMovies() {\n        viewModelScope.launch {\n            deleteMoviesById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedActors() {\n        viewModelScope.launch {\n            deleteActorsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedRatings() {\n        viewModelScope.launch {\n            deleteRatingsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n\n\n    // ...\n}</pre> <p>Pass <code>deleteSelectedMovies()</code> as the function to use for <code>onDeleteSelectedMovies</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        MovieList -&gt; {\n            // ...\n            MovieListUi(\n                // ...\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        // ...\n            )\n        }\n    }\n}</pre> <p>Phew - that's a long chain of deletes coming from the data layer! You shouldn't have to uninstall the app or increase the database version, as we only modified the DAO.</p> <p>When we run the application, we can now select movies and delete them using the trash can button. The list is automatically updated because we used a <code>Flow</code> as the return type for the getting the movie list. When the database has been changed, the <code>getMoviesFlow</code> query is re-executed, and the results emitted to the same <code>Flow</code>. The <code>Ui</code> collects the <code>Flow</code> into Compose state. Compose detects the state change and recomposes the UI. Poof!</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\n\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    fun deleteSelectedMovies() {\n        viewModelScope.launch {\n            deleteMoviesById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedActors() {\n        viewModelScope.launch {\n            deleteActorsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedRatings() {\n        viewModelScope.launch {\n            deleteRatingsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n//              title = {\n//                  Text(text = stringResource(R.string.movies))\n//              },\n                    title = { Text(text = stringResource(R.string.movies)) },\n                    actions = {\n//                  IconButton (onClick = onResetDatabase) {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = {\n                        Text(\n                            text = selectedIds.size.toString(),\n                            modifier = Modifier.padding(8.dp)\n                        )\n                    },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedMovies) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        LazyColumn (\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n        ) {\n            items(\n                items = movies,\n                key = { it.id }\n            ) { movie -&gt;\n                val containerColor =\n                    if (movie.id in selectedIds) {\n                        MaterialTheme.colorScheme.secondary\n                    } else {\n                        MaterialTheme.colorScheme.surface\n                    }\n                val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n\n                if (selectedIds.isNotEmpty()) {\n                    BackHandler {\n                        onClearSelections()\n                    }\n                }\n\n                Card (\n                    elevation = CardDefaults.cardElevation(\n                        defaultElevation = 8.dp,\n                    ),\n                    colors = CardDefaults.cardColors(\n                        containerColor = containerColor,\n                        contentColor = contentColor,\n                    ),\n                    modifier = Modifier.padding(8.dp)\n                        .combinedClickable(\n                            onClick = {\n                                if (selectedIds.isEmpty()) {\n                                    onMovieClicked(movie)\n                                } else {\n                                    onSelectionToggle(movie.id)\n                                }\n                            },\n                            onLongClick = {\n                                onSelectionToggle(movie.id)\n                            },\n                        )\n                ) {\n                    Row (\n                        verticalAlignment = Alignment.CenterVertically,\n                        modifier = Modifier.padding(8.dp)\n                    ) {\n                        Icon(\n                            imageVector = Icons.Default.Star,\n                            contentDescription = stringResource(id = R.string.movie),\n                            modifier = Modifier.clickable {\n                                onSelectionToggle(movie.id)\n                            }\n                        )\n                        Display(text = movie.title)\n                    }\n                }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n    &lt;string name=\"loading\"&gt;\u2026Loading\u2026&lt;/string&gt;\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n    &lt;string name=\"cast_entry\"&gt;%1$s: %2$s&lt;/string&gt;\n    &lt;string name=\"clear_selections\"&gt;Clear Selections&lt;/string&gt;\n    &lt;string name=\"delete_selected_items\"&gt;Delete selected items&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class MovieDao {\n    @Query(\"SELECT * FROM RatingEntity\")\n    abstract fun getRatingsFlow(): Flow&lt;List&lt;RatingEntity&gt;&gt;\n    @Query(\"SELECT * FROM MovieEntity\")\n    abstract fun getMoviesFlow(): Flow&lt;List&lt;MovieEntity&gt;&gt;\n    @Query(\"SELECT * FROM ActorEntity\")\n    abstract fun getActorsFlow(): Flow&lt;List&lt;ActorEntity&gt;&gt;\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract suspend fun getRatingWithMovies(id: String): RatingWithMovies\n    @Transaction\n    @Query(\"SELECT * FROM ActorEntity WHERE id = :id\")\n    abstract suspend fun getActorWithFilmography(id: String): ActorWithFilmography\n    @Transaction\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Insert\n    abstract suspend fun insert(vararg ratings: RatingEntity)\n    @Insert\n    abstract suspend fun insert(vararg movies: MovieEntity)\n    @Insert\n    abstract suspend fun insert(vararg actors: ActorEntity)\n    @Insert\n    abstract suspend fun insert(vararg roles: RoleEntity)\n\n    @Query(\"DELETE FROM MovieEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM ActorEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM RatingEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    @Query(\"DELETE FROM MovieEntity\")\n    abstract suspend fun clearMovies()\n    @Query(\"DELETE FROM ActorEntity\")\n    abstract suspend fun clearActors()\n    @Query(\"DELETE FROM RatingEntity\")\n    abstract suspend fun clearRatings()\n    @Query(\"DELETE FROM RoleEntity\")\n    abstract suspend fun clearRoles()\n    @Transaction\n    open suspend fun resetDatabase() {\n        clearMovies()\n        clearActors()\n        clearRoles()\n        clearRatings()\n        insert(\n            RatingEntity(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            RatingEntity(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            RatingEntity(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            RatingEntity(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            RatingEntity(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n        insert(\n            MovieEntity(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            MovieEntity(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            MovieEntity(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            MovieEntity(\"m4\", \"Jumanji - Welcome to the Jungle\", \"The Rock smolders\", \"r3\"),\n        )\n        insert(\n            ActorEntity(\"a1\", \"Jason Statham\"),\n            ActorEntity(\"a2\", \"The Rock\"),\n            ActorEntity(\"a3\", \"Shu Qi\"),\n            ActorEntity(\"a4\", \"Amber Valletta\"),\n            ActorEntity(\"a5\", \"Kevin Hart\"),\n        )\n        insert(\n            RoleEntity(\"m1\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m1\", \"a3\", \"Lai\", 2),\n            RoleEntity(\"m2\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            RoleEntity(\"m3\", \"a2\", \"Hobbs\", 1),\n            RoleEntity(\"m3\", \"a1\", \"Shaw\", 2),\n            RoleEntity(\"m4\", \"a2\", \"Spencer\", 1),\n            RoleEntity(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport android.content.Context\nimport com.androidbyexample.compose.movies.data.MovieDao\nimport com.androidbyexample.compose.movies.data.createDao\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) = dao.deleteMoviesById(ids)\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) = dao.deleteActorsById(ids)\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) = dao.deleteRatingsById(ids)\n\n\n    override suspend fun resetDatabase() = dao.resetDatabase()\n\n    companion object {\n        fun create(context: Context) =\n            MovieDatabaseRepository(createDao(context))\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport kotlinx.coroutines.flow.Flow\n\ninterface MovieRepository {\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt;\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    suspend fun getMovieWithCast(id: String): MovieWithCastDto\n    suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto\n    suspend fun insert(movie: MovieDto)\n    suspend fun insert(actor: ActorDto)\n    suspend fun insert(rating: RatingDto)\n\n    suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    suspend fun resetDatabase()\n}\n</pre>"},{"location":"modules/movie-ui-2/STEP_060_REPO.html","title":"Refactor time!","text":"<p>Our app bakes the list support in with the Movie UI. We can make it much more reusable!</p> <p>We're going to have two types of lists in the application:</p> <ul> <li>Top-level lists of all movies, actors and ratings</li> <li>Nested lists, such as actors starring in a movie (on the movie's display screen)</li> </ul> <p>To create consistent list support, we need to separate the <code>LazyColumn</code> from the <code>Scaffold</code> and the <code>MovieListUi</code>. We want to keep all of the selection management, but make it more generic.</p> <p>But there's a problem. If we make a generic <code>List</code> composable, something like</p> <pre><code>fun &lt;T&gt; List(\n  items: List&lt;T&gt;,\n  ...\n) {\n  ...\n}\n</code></pre> <p>we have several spots that access the item's <code>id</code>. When the item type was explicitly <code>MovieDto</code>, we knew it had an id, but if the item type is a generic parameter <code>T</code>, we can no longer make that assumption.</p> <p>To fix this, we create a <code>HasId</code> interface\" in the <code>repository</code> module. (You could create it in the <code>data</code> module, but we don't have a need for it that low.)</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/HasId.kt <pre>package com.androidbyexample.compose.movies.repository\n\ninterface HasId {\n    val id: String\n}</pre> <p>We apply it to our <code>MovieDto</code>, <code>ActorDto</code>, and <code>RatingDto</code>.</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDto.kt <pre>// ...\n\ndata class MovieDto(\n//  val id: String,\n    override val id: String,\n    val title: String,\n    val description: String,\n    val ratingId: String,\n//)\n): HasId\n\ninternal fun MovieEntity.toDto() =\n    // ...</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>// ...\n\ndata class ActorDto(\n//  val id: String,\n    override val id: String,\n    val name: String,\n//)\n): HasId\n\ninternal fun ActorEntity.toDto() =\n    // ...</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/RatingDto.kt <pre>// ...\n\ndata class RatingDto(\n//  val id: String,\n    override val id: String,\n    val name: String,\n    val description: String,\n//)\n): HasId\n\ninternal fun RatingEntity.toDto() =\n    // ...</pre> <p>We can now create a generic <code>List</code> composable.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/List.kt <pre>// ...\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun &lt;T: HasId&gt; List(\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    LazyColumn(\n        modifier = modifier\n    ) {\n        items(\n            items = items,\n            key = { it.id },\n        ) { item -&gt;\n            val containerColor =\n                if (item.id in selectedIds) {\n                    MaterialTheme.colorScheme.secondary\n                } else {\n                    MaterialTheme.colorScheme.surface\n                }\n            val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n            if (selectedIds.isNotEmpty()) {\n                BackHandler {\n                    onClearSelections()\n                }\n            }\n            Card(\n                elevation = CardDefaults.cardElevation(\n                    defaultElevation = 8.dp,\n                ),\n                colors = CardDefaults.cardColors(\n                    containerColor = containerColor,\n                    contentColor = contentColor,\n                ),\n                modifier = Modifier\n                    .padding(8.dp)\n                    .combinedClickable(\n                        onClick = {\n                            if (selectedIds.isEmpty()) {\n                                onItemClicked(item)\n                            } else {\n                                onSelectionToggle(item.id)\n                            }\n                        },\n                        onLongClick = {\n                            onSelectionToggle(item.id)\n                        },\n                    )\n            ) {\n                itemContent(item)\n            }\n        }\n    }\n}</pre> <p>We can now replace the common list function in <code>MovieListUi</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    Scaffold(\n        // ...\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//      LazyColumn (\n        List(\n            items = movies,\n            onItemClicked = onMovieClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n//      ) {\n//          items(\n//              items = movies,\n//              key = { it.id }\n        ) { movie -&gt;\n//              val containerColor =\n//                  if (movie.id in selectedIds) {\n//                      MaterialTheme.colorScheme.secondary\n//                  } else {\n//                      MaterialTheme.colorScheme.surface\n//                  }\n//              val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n//\n//              if (selectedIds.isNotEmpty()) {\n//                  BackHandler {\n//                      onClearSelections()\n//                  }\n//              }\n//\n//              Card (\n//                  elevation = CardDefaults.cardElevation(\n//                      defaultElevation = 8.dp,\n//                  ),\n//                  colors = CardDefaults.cardColors(\n//                      containerColor = containerColor,\n//                      contentColor = contentColor,\n//                  ),\n//                  modifier = Modifier.padding(8.dp)\n//                      .combinedClickable(\n//                          onClick = {\n//                              if (selectedIds.isEmpty()) {\n//                                  onMovieClicked(movie)\n//                              } else {\n//                                  onSelectionToggle(movie.id)\n//                              }\n//                          },\n//                          onLongClick = {\n//                              onSelectionToggle(movie.id)\n//                          },\n//                      )\n//              ) {\n            Row (\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Star,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(movie.id)\n                    }\n                )\n                Display(text = movie.title)\n            }\n        }\n//          }\n//      }\n    }\n}</pre> <p>Because this list manages scrolling, we remove the <code>verticalScroll</code> from the surrounding column.</p> <p>We can also use this list for the cast display in <code>MovieDisplayUi</code>, giving us a consistent-looking (and behaving) list...</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    // ...\n) {\n    // ...\n    Scaffold(\n        // ...\n    ) { innerPadding -&gt;\n        movieWithCast?.let { movieWithCast -&gt;\n            Column (\n                modifier = Modifier\n                    .padding(innerPadding)\n//                  .verticalScroll(rememberScrollState())\n            ) {\n                Label (textId = R.string.title)\n                // ...\n//                  .forEach { role -&gt;\n\n                List(\n                    items = movieWithCast.cast.sortedBy { it.orderInCredits },\n                    onItemClicked = onActorClicked,\n                    selectedIds = emptySet(),\n                    onSelectionToggle = {},\n                    onClearSelections = {},\n                    modifier = Modifier.weight(1f)\n                ) { role -&gt;\n                    Display(\n                        text = stringResource(\n                            R.string.cast_entry,\n                            role.character,\n                            role.actor.name,\n                        )\n                    )\n                }\n            }\n        }\n    }\n}</pre> <p>But there are a couple of hitches:</p> <ul> <li><code>RoleWithActorDto</code> doesn't implement <code>HasId</code></li> <li><code>MovieDisplayUi</code> doesn't have a parameter to handle when an actor has been clicked</li> <li>We don't want selections in the cast list, just clicks.</li> </ul> <p>First, the <code>HasId</code>. We can add a derived <code>id</code> to <code>RoleWithActorDto</code>. The id here is a combination of movie id &amp; character. (This might not be unique, but for our example purposes it's good enough).</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDto.kt <pre>// ...\ndata class RoleWithActorDto(\n    val actor: ActorDto,\n    val character: String,\n    val orderInCredits: Int,\n//)\n): HasId {\n    override val id: String\n        get() = \"${actor.id}:$character\"\n}\ninternal fun RoleWithActor.toDto() =\n    RoleWithActorDto(\n        // ...</pre> <p>Next, we add a parameter to handle clicks on roles </p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    onActorClicked: (RoleWithActorDto) -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    // ...\n}</pre> <p>and, just for now, an empty handler in <code>Ui</code>. (We'll add that navigation after we set up the other screens later.)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                onActorClicked = { }, // empty for now. we'll fix later\n                modifier = modifier,\n            )\n        }\n        // ...\n    }\n}</pre> <p></p> All code changes ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/List.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun &lt;T: HasId&gt; List(\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    LazyColumn(\n        modifier = modifier\n    ) {\n        items(\n            items = items,\n            key = { it.id },\n        ) { item -&gt;\n            val containerColor =\n                if (item.id in selectedIds) {\n                    MaterialTheme.colorScheme.secondary\n                } else {\n                    MaterialTheme.colorScheme.surface\n                }\n            val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n            if (selectedIds.isNotEmpty()) {\n                BackHandler {\n                    onClearSelections()\n                }\n            }\n            Card(\n                elevation = CardDefaults.cardElevation(\n                    defaultElevation = 8.dp,\n                ),\n                colors = CardDefaults.cardColors(\n                    containerColor = containerColor,\n                    contentColor = contentColor,\n                ),\n                modifier = Modifier\n                    .padding(8.dp)\n                    .combinedClickable(\n                        onClick = {\n                            if (selectedIds.isEmpty()) {\n                                onItemClicked(item)\n                            } else {\n                                onSelectionToggle(item.id)\n                            }\n                        },\n                        onLongClick = {\n                            onSelectionToggle(item.id)\n                        },\n                    )\n            ) {\n                itemContent(item)\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.MovieWithCastDto\nimport com.androidbyexample.compose.movies.repository.RoleWithActorDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    onActorClicked: (RoleWithActorDto) -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = movieWithCast?.movie?.title ?: stringResource(R.string.loading))\n                }\n            )\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n        movieWithCast?.let { movieWithCast -&gt;\n            Column (\n                modifier = Modifier\n                    .padding(innerPadding)\n//                  .verticalScroll(rememberScrollState())\n            ) {\n                Label (textId = R.string.title)\n                Display(text = movieWithCast.movie.title)\n                Label(textId = R.string.description)\n                Display(text = movieWithCast.movie.description)\n                Label(textId = R.string.cast)\n//              movieWithCast\n//                  .cast\n//                  .sortedBy { it.orderInCredits }\n//                  .forEach { role -&gt;\n\n                List(\n                    items = movieWithCast.cast.sortedBy { it.orderInCredits },\n                    onItemClicked = onActorClicked,\n                    selectedIds = emptySet(),\n                    onSelectionToggle = {},\n                    onClearSelections = {},\n                    modifier = Modifier.weight(1f)\n                ) { role -&gt;\n                    Display(\n                        text = stringResource(\n                            R.string.cast_entry,\n                            role.character,\n                            role.actor.name,\n                        )\n                    )\n                }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(R.string.movies)) },\n                    actions = {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = {\n                        Text(\n                            text = selectedIds.size.toString(),\n                            modifier = Modifier.padding(8.dp)\n                        )\n                    },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedMovies) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        modifier = modifier,\n    ) { innerPadding -&gt;\n//      LazyColumn (\n        List(\n            items = movies,\n            onItemClicked = onMovieClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n//      ) {\n//          items(\n//              items = movies,\n//              key = { it.id }\n        ) { movie -&gt;\n//              val containerColor =\n//                  if (movie.id in selectedIds) {\n//                      MaterialTheme.colorScheme.secondary\n//                  } else {\n//                      MaterialTheme.colorScheme.surface\n//                  }\n//              val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n//\n//              if (selectedIds.isNotEmpty()) {\n//                  BackHandler {\n//                      onClearSelections()\n//                  }\n//              }\n//\n//              Card (\n//                  elevation = CardDefaults.cardElevation(\n//                      defaultElevation = 8.dp,\n//                  ),\n//                  colors = CardDefaults.cardColors(\n//                      containerColor = containerColor,\n//                      contentColor = contentColor,\n//                  ),\n//                  modifier = Modifier.padding(8.dp)\n//                      .combinedClickable(\n//                          onClick = {\n//                              if (selectedIds.isEmpty()) {\n//                                  onMovieClicked(movie)\n//                              } else {\n//                                  onSelectionToggle(movie.id)\n//                              }\n//                          },\n//                          onLongClick = {\n//                              onSelectionToggle(movie.id)\n//                          },\n//                      )\n//              ) {\n            Row (\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Star,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(movie.id)\n                    }\n                )\n                Display(text = movie.title)\n            }\n        }\n//          }\n//      }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                onActorClicked = { }, // empty for now. we'll fix later\n                modifier = modifier,\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.ActorEntity\nimport com.androidbyexample.compose.movies.data.ActorWithFilmography\nimport com.androidbyexample.compose.movies.data.RoleWithMovie\n\ndata class ActorDto(\n//  val id: String,\n    override val id: String,\n    val name: String,\n//)\n): HasId\n\ninternal fun ActorEntity.toDto() =\n    ActorDto(id = id, name = name)\ninternal fun ActorDto.toEntity() =\n    ActorEntity(id = id, name = name)\n\ndata class ActorWithFilmographyDto(\n    val actor: ActorDto,\n    val filmography: List&lt;RoleWithMovieDto&gt;,\n)\ndata class RoleWithMovieDto(\n    val movie: MovieDto,\n    val character: String,\n    val orderInCredits: Int,\n)\ninternal fun RoleWithMovie.toDto() =\n    RoleWithMovieDto(\n        movie = movie.toDto(),\n        character = role.character,\n        orderInCredits = role.orderInCredits,\n    )\ninternal fun ActorWithFilmography.toDto() =\n    ActorWithFilmographyDto(\n        actor = actor.toDto(),\n        filmography =\n        rolesWithMovies.map {\n            it.toDto()\n        }\n    )\n</pre> ADDED: repository/src/main/java/com/androidbyexample/compose/movies/repository/HasId.kt <pre>package com.androidbyexample.compose.movies.repository\n\ninterface HasId {\n    val id: String\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.MovieEntity\nimport com.androidbyexample.compose.movies.data.MovieWithCast\nimport com.androidbyexample.compose.movies.data.RoleWithActor\n\ndata class MovieDto(\n//  val id: String,\n    override val id: String,\n    val title: String,\n    val description: String,\n    val ratingId: String,\n//)\n): HasId\n\ninternal fun MovieEntity.toDto() =\n    MovieDto(id = id, title = title, description = description, ratingId = ratingId)\ninternal fun MovieDto.toEntity() =\n    MovieEntity(id = id, title = title, description = description, ratingId = ratingId)\ndata class MovieWithCastDto(\n    val movie: MovieDto,\n    val cast: List&lt;RoleWithActorDto&gt;,\n)\ndata class RoleWithActorDto(\n    val actor: ActorDto,\n    val character: String,\n    val orderInCredits: Int,\n//)\n): HasId {\n    override val id: String\n        get() = \"${actor.id}:$character\"\n}\ninternal fun RoleWithActor.toDto() =\n    RoleWithActorDto(\n        actor = actor.toDto(),\n        character = role.character,\n        orderInCredits = role.orderInCredits,\n    )\ninternal fun MovieWithCast.toDto() =\n    MovieWithCastDto(\n        movie = movie.toDto(),\n        cast =\n        rolesWithActors.map {\n            it.toDto()\n        }\n    )\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/RatingDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.RatingEntity\nimport com.androidbyexample.compose.movies.data.RatingWithMovies\n\ndata class RatingDto(\n//  val id: String,\n    override val id: String,\n    val name: String,\n    val description: String,\n//)\n): HasId\n\ninternal fun RatingEntity.toDto() =\n    RatingDto(id = id, name = name, description = description)\ninternal fun RatingDto.toEntity() =\n    RatingEntity(id = id, name = name, description = description)\ndata class RatingWithMoviesDto(\n    val rating: RatingDto,\n    val movies: List&lt;MovieDto&gt;,\n)\n// only need the toDto(); we don't use this to do database updates\ninternal fun RatingWithMovies.toDto() =\n    RatingWithMoviesDto(\n        rating = rating.toDto(),\n        movies = movies.map { it.toDto() },\n    )\n</pre>"},{"location":"modules/movie-ui-2/STEP_070_REPO.html","title":"Add Actors and Ratings","text":"<p>To flesh out the app more, let's add in Actors and Ratings.</p> <p>First, we create the screen data to represent these new screens</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>// ...\nsealed interface Screen\ndata object MovieList: Screen\ndata object ActorList: Screen\ndata object RatingList: Screen\ndata class MovieDisplay(val id: String): Screen\ndata class ActorDisplay(val id: String): Screen\ndata class RatingDisplay(val id: String): Screen</pre> <p>We'll create a common <code>ListScaffold</code> that we can reuse on all \"list\" screens. (We'll define it in a bit, but need some prep work first).</p> <p>At the bottom of the list scaffold we'll place three buttons which act like tabs.</p> <p>We define <code>ScreenSelectButton</code> for these tabs.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/components/ScreenSelectButton.kt <pre>// ...\nimport com.androidbyexample.compose.movies.screens.Screen\n\n@Composable\nfun RowScope.ScreenSelectButton(\n    currentScreen: Screen,\n    targetScreen: Screen,\n    imageVector: ImageVector,\n    @StringRes labelId: Int,\n    onSelectListScreen: (Screen) -&gt; Unit,\n) =\n    NavigationBarItem(\n        selected = currentScreen == targetScreen,\n        icon = {\n            Icon(\n                imageVector = imageVector,\n                contentDescription = stringResource(id = labelId)\n            )\n        },\n        label = {\n            Text(text = stringResource(id = labelId))\n        },\n        onClick = {\n            onSelectListScreen(targetScreen)\n        }\n    )</pre> <p>Each tab takes a <code>Screen</code> as its target, and calls <code>onSelectListScreen()</code> passing that target screen when clicked. We use <code>NavigationBarItem</code>, provided by the Material 3 library, for the tab-like styling.</p> <p>This type of navigation requires a new function in the view model to explicitly set the screen stack to the selected list screen.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\nclass MovieViewModel(\n    // ...\n): ViewModel(), MovieRepository by repository {\n    // ...\n    }\n\n    fun setScreen(screen: Screen) {\n        screenStack = listOf(screen)\n    }\n\n    fun deleteSelectedMovies() {\n        // ...\n}</pre> <p>These buttons require some extra parameters to track which is selected (<code>currentScreen</code>) and what to do when they're clicked (<code>onSelectListScreen</code>). We pass these up to all callers up through <code>Ui</code>.</p> <p>We need to pass the <code>currentScreen</code> and <code>onSelectListScreen</code> to Composables that will use our <code>ListScaffold</code>, which uses the <code>ScreenSelectButton</code>s. We add them to <code>MovieListUi</code> so we can pass them to the <code>ListScaffold</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n//@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    // ...\n}</pre> <p>When calling <code>MovieListUi</code> in <code>Ui</code>, we'll need to pass values. </p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        MovieList -&gt; {\n            // ...\n            MovieListUi(\n                // ...\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        // ...\n            )\n        }\n        // ...\n    }\n}</pre> <p>We'll place these buttons in a <code>NavigationBar</code> in the <code>bottomBar</code> slot of the <code>ListScaffold</code>.</p> <p>This creates a nice Ui that allows us to navigate starting from movies, actors or ratings. The screen tabs could be moved into a common base scaffold for all screens to allow instant jumping to a list from any screen (I'll leave that as an \"exercise for the interested reader\").</p> <p>Now we create the <code>ListScaffold</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    @StringRes titleId: Int,\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedItems: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(titleId)) },\n                    actions = {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = { Text(text = selectedIds.size.toString(), modifier = Modifier.padding(8.dp)) },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedItems) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        bottomBar = {\n            NavigationBar {\n                ScreenSelectButton(\n                    targetScreen = RatingList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.ratings,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = MovieList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.movies,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = ActorList,\n                    imageVector = Icons.Default.Person,\n                    labelId = R.string.actors,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n            }\n        },\n        modifier = modifier\n    ) { paddingValues -&gt;\n        List(\n            items = items,\n            onItemClicked = onItemClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            modifier = Modifier\n                .padding(paddingValues)\n                .fillMaxSize(),\n            itemContent = itemContent,\n        )\n    }\n}</pre> <p>and use it in <code>MovieListUi</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n//@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    // ...\n    onResetDatabase: () -&gt; Unit,\n) {\n//  Scaffold(\n//      topBar = {\n//          if (selectedIds.isEmpty()) {\n//              TopAppBar(\n//                  title = { Text(text = stringResource(R.string.movies)) },\n//                  actions = {\n//                      IconButton(onClick = onResetDatabase) {\n//                          Icon(\n//                              imageVector = Icons.Default.Refresh,\n//                              contentDescription = stringResource(R.string.reset_database)\n//                          )\n//                      }\n//                  }\n//              )\n//          } else {\n//              TopAppBar(\n//                  navigationIcon = {\n//                      Icon(\n//                          imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n//                          contentDescription = stringResource(R.string.clear_selections),\n//                          modifier = Modifier.clickable(onClick = onClearSelections),\n//                      )\n//                  },\n//                  title = {\n//                      Text(\n//                          text = selectedIds.size.toString(),\n//                          modifier = Modifier.padding(8.dp)\n//                      )\n//                  },\n//                  actions = {\n//                      IconButton(onClick = onDeleteSelectedMovies) {\n//                          Icon(\n//                              imageVector = Icons.Default.Delete,\n//                              contentDescription = stringResource(R.string.delete_selected_items)\n//                          )\n//                      }\n//                  },\n//              )\n//          }\n//      },\n//      modifier = modifier,\n//  ) { innerPadding -&gt;\n//      List(\n    ListScaffold(\n        titleId = R.string.movies,\n        items = movies,\n        onItemClicked = onMovieClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n//          modifier = Modifier\n//              .padding(innerPadding)\n//              .fillMaxSize()\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n    ) { movie -&gt;\n//          Row (\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Star,\n                contentDescription = stringResource(id = R.string.movie),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(movie.id)\n                }\n            )\n            Display(text = movie.title)\n        }\n    }\n//  }\n}</pre> <p>Be sure to fixup the <code>Modifier</code> calls to pass <code>fillMaxSize</code> from the activity:</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        // ...\n        setContent {\n            MoviesTheme {\n                Ui(\n                    viewModel = viewModel,\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    finish()\n                }\n            }\n        }\n    }\n}</pre> <p>We're going to need to tweak our <code>Label</code> helper. Right now, we pass a string resource id, which it looks up. For our new screens, we'll be using arguments in strings, so we'll need to resolve them outside of the <code>Label</code>. We add an overload that takes a <code>String</code> and modify the original to resolve the string resource id and pass it to the new function. </p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/components/Label.kt <pre>// ...\n\n@Composable\nfun Label(\n    @StringRes textId: Int,\n    modifier: Modifier = Modifier,\n) {\n    Label(\n        text = stringResource(textId),\n        modifier = modifier,\n    )\n}\n\n@Composable\nfun Label(\n    text: String,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n//      text = stringResource(id = textId),\n        text = text,\n        style = MaterialTheme.typography.titleMedium,\n        modifier = modifier\n            .padding(8.dp)\n            .fillMaxWidth(),\n    )\n}</pre> <p>The new actor display screen will use <code>RoleWithMovieDto</code> in a list. We need to make it implement <code>HasId</code> to work with our generic <code>ListUi</code>. We'll derive the <code>id</code> property in the same way we did for <code>RoleWithActorDto</code></p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>// ...\ndata class RoleWithMovieDto(\n    val movie: MovieDto,\n    val character: String,\n    val orderInCredits: Int,\n//)\n): HasId {\n    override val id: String\n        get() = \"${movie.id}:$character\"\n}\ninternal fun RoleWithMovie.toDto() =\n    RoleWithMovieDto(\n        // ...</pre> <p>Now we add the new screens. These new screens are similar to the existing screens, but be careful of where you get the ids from. The <code>MovieDisplayUi</code>, for example, displays a list of <code>RoleWithActorDto</code>s, and when clicked, we need to call <code>it.actor.id</code> to get the proper id. (If you use just <code>it.id</code> here, the fetch will fail when looking up the actor)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ActorList.kt <pre>// ...\nimport com.androidbyexample.compose.movies.repository.ActorDto\n\n@Composable\nfun ActorListUi(\n    actors: List&lt;ActorDto&gt;,\n    onActorClicked: (ActorDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedActors: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    ListScaffold(\n        titleId = R.string.actors,\n        items = actors,\n        onItemClicked = onActorClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedActors,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase\n    ) { actor -&gt;\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Person,\n                contentDescription = stringResource(id = R.string.actor),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(actor.id)\n                }\n            )\n            Display(text = actor.name)\n        }\n    }\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/RatingList.kt <pre>// ...\nimport com.androidbyexample.compose.movies.repository.RatingDto\n\n@Composable\nfun RatingListUi(\n    ratings: List&lt;RatingDto&gt;,\n    onRatingClicked: (RatingDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedRatings: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    ListScaffold(\n        titleId = R.string.ratings,\n        items = ratings,\n        onItemClicked = onRatingClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedRatings,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase\n    ) { rating -&gt;\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Star,\n                contentDescription = stringResource(id = R.string.rating),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(rating.id)\n                }\n            )\n            Display(text = rating.name)\n        }\n    }\n}</pre> <p>Next we create the display screens for actor and rating</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ActorDisplay.kt <pre>// ...\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ActorDisplayUi(\n    id: String,\n    fetchActor: suspend (String) -&gt; ActorWithFilmographyDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n) {\n    var actorWithFilmography by remember { mutableStateOf&lt;ActorWithFilmographyDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            actorWithFilmography = fetchActor(id)\n        }\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = actorWithFilmography?.actor?.name ?: stringResource(R.string.loading))\n                }\n            )\n        }\n    ) { paddingValues -&gt;\n        actorWithFilmography?.let { actorWithFilmography -&gt;\n            Column(\n                modifier = Modifier\n                    .padding(paddingValues)\n            ) {\n                Label(textId = R.string.name)\n                Display(text = actorWithFilmography.actor.name)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_starring,\n                        actorWithFilmography.actor.name\n                    )\n                )\n                List(\n                    items = actorWithFilmography.filmography.sortedBy { it.movie.title },\n                    onItemClicked = { onMovieClicked(it.movie) },\n                    selectedIds = emptySet(),\n                    onSelectionToggle = {},\n                    onClearSelections = {},\n                    modifier = Modifier.weight(1f)\n                ) { role -&gt;\n                    Display(text = role.movie.title)\n                }\n            }\n        }\n    }\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>// ...\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RatingDisplayUi(\n    id: String,\n    fetchRating: suspend (String) -&gt; RatingWithMoviesDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n) {\n    var ratingWithMovies by remember { mutableStateOf&lt;RatingWithMoviesDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            ratingWithMovies = fetchRating(id)\n        }\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = ratingWithMovies?.rating?.name ?: stringResource(R.string.loading))\n                }\n            )\n        }\n    ) { paddingValues -&gt;\n        ratingWithMovies?.let { ratingWithMovies -&gt;\n            Column(\n                modifier = Modifier\n                    .padding(paddingValues)\n            ) {\n                Label(textId = R.string.name)\n                Display(text = ratingWithMovies.rating.name)\n                Label(textId = R.string.description)\n                Display(text = ratingWithMovies.rating.description)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_rated,\n                        ratingWithMovies.rating.name\n                    )\n                )\n                List(\n                    items = ratingWithMovies.movies.sortedBy { it.title },\n                    onItemClicked = onMovieClicked,\n                    selectedIds = emptySet(),\n                    onSelectionToggle = {},\n                    onClearSelections = {},\n                    modifier = Modifier.weight(1f)\n                ) { movie -&gt;\n                    Display(\n                        text = movie.title\n                    )\n                }\n            }\n        }\n    }\n}</pre> <p>Define new user-facing strings</p> show in full file  app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    // ...\n    &lt;string name=\"clear_selections\"&gt;Clear Selections&lt;/string&gt;\n    &lt;string name=\"delete_selected_items\"&gt;Delete selected items&lt;/string&gt;\n    &lt;string name=\"ratings\"&gt;Ratings&lt;/string&gt;\n    &lt;string name=\"rating\"&gt;Rating&lt;/string&gt;\n    &lt;string name=\"actors\"&gt;Actors&lt;/string&gt;\n    &lt;string name=\"actor\"&gt;Actor&lt;/string&gt;\n    &lt;string name=\"name\"&gt;Name&lt;/string&gt;\n    &lt;string name=\"movies_rated\"&gt;Movies rated %1$s&lt;/string&gt;\n    &lt;string name=\"movies_starring\"&gt;Movies starring %1$s&lt;/string&gt;\n&lt;/resources&gt;</pre> <p>Fix the <code>onActorClicked</code> parameter being passed to <code>MovieDisplayUi</code> to push the screen for the clicked <code>RoleWithActorDto</code></p> <p>Finally, we add the calls to the new screens in <code>Ui</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n//              onActorClicked = { }, // empty for now. we'll fix later\n                onActorClicked = { viewModel.pushScreen(ActorDisplay(it.actor.id)) },\n                modifier = modifier,\n            )\n        }\n        is ActorDisplay -&gt; {\n            ActorDisplayUi(\n                id = screen.id,\n                fetchActor = viewModel::getActorWithFilmography,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n            )\n        }\n        is RatingDisplay -&gt; {\n            RatingDisplayUi(\n                id = screen.id,\n                fetchRating = viewModel::getRatingWithMovies,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                // ...\n            )\n        }\n        ActorList -&gt; {\n            val actors by viewModel.actorsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            ActorListUi(\n                actors = actors,\n                onActorClicked = { actor -&gt;\n                    viewModel.pushScreen(ActorDisplay(actor.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedActors = viewModel::deleteSelectedActors,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        RatingList -&gt; {\n            val ratings by viewModel.ratingsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            RatingListUi(\n                ratings = ratings,\n                onRatingClicked = { rating -&gt;\n                    viewModel.pushScreen(RatingDisplay(rating.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedRatings = viewModel::deleteSelectedRatings,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n    }\n}</pre> <p>When we run this version of the application, we can now drill deeper into the data. Pick a movie, then pick an actor, then pick movies starring that actor and so forth. Navigating back pops each screen off the stack, returning to the previous screen.</p> <p>Note</p> <p>We're still using a Star icon for movies. We'll pick a better icon in the final step.</p> <p>You'll notice that we currently have no means of navigating to the actor and rating list screens. To do this, we'll add tabs at the bottom of the list screens to jump to other lists.</p> <p>Navigation-wise, we'll treat each of these jumps as restarting navigation, replacing the stack with the destination. This isn't necessary, but I wanted to demonstrate a navigation alternative.</p> <p>Now let's get a better movie icon...</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt; { MovieViewModel.Factory }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Ui(\n                    viewModel = viewModel,\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    finish()\n                }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.launch\n\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    fun setScreen(screen: Screen) {\n        screenStack = listOf(screen)\n    }\n\n    fun deleteSelectedMovies() {\n        viewModelScope.launch {\n            deleteMoviesById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedActors() {\n        viewModelScope.launch {\n            deleteActorsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedRatings() {\n        viewModelScope.launch {\n            deleteRatingsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/components/Label.kt <pre>package com.androidbyexample.compose.movies.components\n\nimport androidx.annotation.StringRes\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun Label(\n    @StringRes textId: Int,\n    modifier: Modifier = Modifier,\n) {\n    Label(\n        text = stringResource(textId),\n        modifier = modifier,\n    )\n}\n\n@Composable\nfun Label(\n    text: String,\n    modifier: Modifier = Modifier,\n) {\n    Text(\n//      text = stringResource(id = textId),\n        text = text,\n        style = MaterialTheme.typography.titleMedium,\n        modifier = modifier\n            .padding(8.dp)\n            .fillMaxWidth(),\n    )\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/components/ScreenSelectButton.kt <pre>package com.androidbyexample.compose.movies.components\n\nimport androidx.annotation.StringRes\nimport androidx.compose.foundation.layout.RowScope\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.NavigationBarItem\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.graphics.vector.ImageVector\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.screens.Screen\n\n@Composable\nfun RowScope.ScreenSelectButton(\n    currentScreen: Screen,\n    targetScreen: Screen,\n    imageVector: ImageVector,\n    @StringRes labelId: Int,\n    onSelectListScreen: (Screen) -&gt; Unit,\n) =\n    NavigationBarItem(\n        selected = currentScreen == targetScreen,\n        icon = {\n            Icon(\n                imageVector = imageVector,\n                contentDescription = stringResource(id = labelId)\n            )\n        },\n        label = {\n            Text(text = stringResource(id = labelId))\n        },\n        onClick = {\n            onSelectListScreen(targetScreen)\n        }\n    )\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/ActorDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.ActorWithFilmographyDto\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ActorDisplayUi(\n    id: String,\n    fetchActor: suspend (String) -&gt; ActorWithFilmographyDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n) {\n    var actorWithFilmography by remember { mutableStateOf&lt;ActorWithFilmographyDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            actorWithFilmography = fetchActor(id)\n        }\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = actorWithFilmography?.actor?.name ?: stringResource(R.string.loading))\n                }\n            )\n        }\n    ) { paddingValues -&gt;\n        actorWithFilmography?.let { actorWithFilmography -&gt;\n            Column(\n                modifier = Modifier\n                    .padding(paddingValues)\n            ) {\n                Label(textId = R.string.name)\n                Display(text = actorWithFilmography.actor.name)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_starring,\n                        actorWithFilmography.actor.name\n                    )\n                )\n                List(\n                    items = actorWithFilmography.filmography.sortedBy { it.movie.title },\n                    onItemClicked = { onMovieClicked(it.movie) },\n                    selectedIds = emptySet(),\n                    onSelectionToggle = {},\n                    onClearSelections = {},\n                    modifier = Modifier.weight(1f)\n                ) { role -&gt;\n                    Display(text = role.movie.title)\n                }\n            }\n        }\n    }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/ActorList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Person\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.ActorDto\n\n@Composable\nfun ActorListUi(\n    actors: List&lt;ActorDto&gt;,\n    onActorClicked: (ActorDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedActors: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    ListScaffold(\n        titleId = R.string.actors,\n        items = actors,\n        onItemClicked = onActorClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedActors,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase\n    ) { actor -&gt;\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Person,\n                contentDescription = stringResource(id = R.string.actor),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(actor.id)\n                }\n            )\n            Display(text = actor.name)\n        }\n    }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.annotation.StringRes\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Person\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.NavigationBar\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.ScreenSelectButton\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    @StringRes titleId: Int,\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedItems: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(titleId)) },\n                    actions = {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = { Text(text = selectedIds.size.toString(), modifier = Modifier.padding(8.dp)) },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedItems) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        bottomBar = {\n            NavigationBar {\n                ScreenSelectButton(\n                    targetScreen = RatingList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.ratings,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = MovieList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.movies,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = ActorList,\n                    imageVector = Icons.Default.Person,\n                    labelId = R.string.actors,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n            }\n        },\n        modifier = modifier\n    ) { paddingValues -&gt;\n        List(\n            items = items,\n            onItemClicked = onItemClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            modifier = Modifier\n                .padding(paddingValues)\n                .fillMaxSize(),\n            itemContent = itemContent,\n        )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import androidx.activity.compose.BackHandler\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.clickable\n//import androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.layout.Row\n//import androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\n//import androidx.compose.foundation.lazy.LazyColumn\n//import androidx.compose.foundation.lazy.items\nimport androidx.compose.material.icons.Icons\n//import androidx.compose.material.icons.automirrored.filled.ArrowBack\n//import androidx.compose.material.icons.filled.Delete\n//import androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\n//import androidx.compose.material3.Card\n//import androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\n//import androidx.compose.material3.IconButton\n//import androidx.compose.material3.MaterialTheme\n//import androidx.compose.material3.Scaffold\n//import androidx.compose.material3.Text\n//import androidx.compose.material3.TopAppBar\n//import androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n//@OptIn(ExperimentalMaterial3Api::class, ExperimentalFoundationApi::class) // for TopAppBar\n@Composable\nfun MovieListUi(\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n//  Scaffold(\n//      topBar = {\n//          if (selectedIds.isEmpty()) {\n//              TopAppBar(\n//                  title = { Text(text = stringResource(R.string.movies)) },\n//                  actions = {\n//                      IconButton(onClick = onResetDatabase) {\n//                          Icon(\n//                              imageVector = Icons.Default.Refresh,\n//                              contentDescription = stringResource(R.string.reset_database)\n//                          )\n//                      }\n//                  }\n//              )\n//          } else {\n//              TopAppBar(\n//                  navigationIcon = {\n//                      Icon(\n//                          imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n//                          contentDescription = stringResource(R.string.clear_selections),\n//                          modifier = Modifier.clickable(onClick = onClearSelections),\n//                      )\n//                  },\n//                  title = {\n//                      Text(\n//                          text = selectedIds.size.toString(),\n//                          modifier = Modifier.padding(8.dp)\n//                      )\n//                  },\n//                  actions = {\n//                      IconButton(onClick = onDeleteSelectedMovies) {\n//                          Icon(\n//                              imageVector = Icons.Default.Delete,\n//                              contentDescription = stringResource(R.string.delete_selected_items)\n//                          )\n//                      }\n//                  },\n//              )\n//          }\n//      },\n//      modifier = modifier,\n//  ) { innerPadding -&gt;\n//      List(\n    ListScaffold(\n        titleId = R.string.movies,\n        items = movies,\n        onItemClicked = onMovieClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n//          modifier = Modifier\n//              .padding(innerPadding)\n//              .fillMaxSize()\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n    ) { movie -&gt;\n//          Row (\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Star,\n                contentDescription = stringResource(id = R.string.movie),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(movie.id)\n                }\n            )\n            Display(text = movie.title)\n        }\n    }\n//  }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.RatingWithMoviesDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RatingDisplayUi(\n    id: String,\n    fetchRating: suspend (String) -&gt; RatingWithMoviesDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n) {\n    var ratingWithMovies by remember { mutableStateOf&lt;RatingWithMoviesDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            ratingWithMovies = fetchRating(id)\n        }\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = {\n                    Text(text = ratingWithMovies?.rating?.name ?: stringResource(R.string.loading))\n                }\n            )\n        }\n    ) { paddingValues -&gt;\n        ratingWithMovies?.let { ratingWithMovies -&gt;\n            Column(\n                modifier = Modifier\n                    .padding(paddingValues)\n            ) {\n                Label(textId = R.string.name)\n                Display(text = ratingWithMovies.rating.name)\n                Label(textId = R.string.description)\n                Display(text = ratingWithMovies.rating.description)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_rated,\n                        ratingWithMovies.rating.name\n                    )\n                )\n                List(\n                    items = ratingWithMovies.movies.sortedBy { it.title },\n                    onItemClicked = onMovieClicked,\n                    selectedIds = emptySet(),\n                    onSelectionToggle = {},\n                    onClearSelections = {},\n                    modifier = Modifier.weight(1f)\n                ) { movie -&gt;\n                    Display(\n                        text = movie.title\n                    )\n                }\n            }\n        }\n    }\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/RatingList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.RatingDto\n\n@Composable\nfun RatingListUi(\n    ratings: List&lt;RatingDto&gt;,\n    onRatingClicked: (RatingDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedRatings: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    ListScaffold(\n        titleId = R.string.ratings,\n        items = ratings,\n        onItemClicked = onRatingClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedRatings,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase\n    ) { rating -&gt;\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n                imageVector = Icons.Default.Star,\n                contentDescription = stringResource(id = R.string.rating),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(rating.id)\n                }\n            )\n            Display(text = rating.name)\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>package com.androidbyexample.compose.movies.screens\n\nsealed interface Screen\ndata object MovieList: Screen\ndata object ActorList: Screen\ndata object RatingList: Screen\ndata class MovieDisplay(val id: String): Screen\ndata class ActorDisplay(val id: String): Screen\ndata class RatingDisplay(val id: String): Screen\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n//              onActorClicked = { }, // empty for now. we'll fix later\n                onActorClicked = { viewModel.pushScreen(ActorDisplay(it.actor.id)) },\n                modifier = modifier,\n            )\n        }\n        is ActorDisplay -&gt; {\n            ActorDisplayUi(\n                id = screen.id,\n                fetchActor = viewModel::getActorWithFilmography,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n            )\n        }\n        is RatingDisplay -&gt; {\n            RatingDisplayUi(\n                id = screen.id,\n                fetchRating = viewModel::getRatingWithMovies,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                },\n            )\n        }\n        ActorList -&gt; {\n            val actors by viewModel.actorsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            ActorListUi(\n                actors = actors,\n                onActorClicked = { actor -&gt;\n                    viewModel.pushScreen(ActorDisplay(actor.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedActors = viewModel::deleteSelectedActors,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        RatingList -&gt; {\n            val ratings by viewModel.ratingsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            RatingListUi(\n                ratings = ratings,\n                onRatingClicked = { rating -&gt;\n                    viewModel.pushScreen(RatingDisplay(rating.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedRatings = viewModel::deleteSelectedRatings,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n    &lt;string name=\"loading\"&gt;\u2026Loading\u2026&lt;/string&gt;\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n    &lt;string name=\"cast_entry\"&gt;%1$s: %2$s&lt;/string&gt;\n    &lt;string name=\"clear_selections\"&gt;Clear Selections&lt;/string&gt;\n    &lt;string name=\"delete_selected_items\"&gt;Delete selected items&lt;/string&gt;\n    &lt;string name=\"ratings\"&gt;Ratings&lt;/string&gt;\n    &lt;string name=\"rating\"&gt;Rating&lt;/string&gt;\n    &lt;string name=\"actors\"&gt;Actors&lt;/string&gt;\n    &lt;string name=\"actor\"&gt;Actor&lt;/string&gt;\n    &lt;string name=\"name\"&gt;Name&lt;/string&gt;\n    &lt;string name=\"movies_rated\"&gt;Movies rated %1$s&lt;/string&gt;\n    &lt;string name=\"movies_starring\"&gt;Movies starring %1$s&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/ActorDto.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport com.androidbyexample.compose.movies.data.ActorEntity\nimport com.androidbyexample.compose.movies.data.ActorWithFilmography\nimport com.androidbyexample.compose.movies.data.RoleWithMovie\n\ndata class ActorDto(\n    override val id: String,\n    val name: String,\n): HasId\n\ninternal fun ActorEntity.toDto() =\n    ActorDto(id = id, name = name)\ninternal fun ActorDto.toEntity() =\n    ActorEntity(id = id, name = name)\n\ndata class ActorWithFilmographyDto(\n    val actor: ActorDto,\n    val filmography: List&lt;RoleWithMovieDto&gt;,\n)\ndata class RoleWithMovieDto(\n    val movie: MovieDto,\n    val character: String,\n    val orderInCredits: Int,\n//)\n): HasId {\n    override val id: String\n        get() = \"${movie.id}:$character\"\n}\ninternal fun RoleWithMovie.toDto() =\n    RoleWithMovieDto(\n        movie = movie.toDto(),\n        character = role.character,\n        orderInCredits = role.orderInCredits,\n    )\ninternal fun ActorWithFilmography.toDto() =\n    ActorWithFilmographyDto(\n        actor = actor.toDto(),\n        filmography =\n        rolesWithMovies.map {\n            it.toDto()\n        }\n    )\n</pre>"},{"location":"modules/movie-ui-2/STEP_080_REPO.html","title":"Better Movie Icon","text":"<p>Jetpack Compose comes with some useful Icons, but it's a rather short list. You can see available icons at Google Fonts.</p> <p>Some are in the  <code>androidx.compose.material:material-icons-core</code> (pulled in when you include <code>androidx.compose.material3:material3</code> as a dependency), and the rest are available in <code>androidx.compose.material:material-icons-extended</code>, which you need to pull in yourself.</p> <p>Warning</p> <p>The extended icons dependency is rather large, and you'll likely only need a few icons from it. You can shrink your app size (see  Shrink your app) or copy the source for the icons into your application. I recommend copying the source for the icons you need, as it reduces the build time.</p> <p>To include the movie icon, first set up the extended icon dependency in the version catalog and define the library</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nlifecycle-compose = \"2.8.7\"\n\nicons-extended = \"1.7.5\"\n\n[libraries]\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended-android\", version.ref = \"icons-extended\"}\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\n// ...\n[plugins]\n// ...</pre> <p>Include the dependency in your application build script. (Note that it's commented-out in the repository, as the end result of this step has already copied the icon)</p> show in full file  app/build.gradle.kts <pre>// ...\ndependencies {\n    implementation(project(\":repository\"))\n\n//    implementation(libs.icons.extended)\n    implementation(libs.lifecycle.compose)\n    implementation(libs.androidx.core.ktx)\n    // ...\n}</pre> <p>Sync your build scripts (press the elephant icon on the Android Studio tool bar)</p> <p>Change the icon  in <code>MovieListUi</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>// ...\n\n@Composable\nfun MovieListUi(\n    // ...\n) {\n    ListScaffold(\n        // ...\n    ) { movie -&gt;\n        Row(\n            // ...\n        ) {\n            Icon(\n//              imageVector = Icons.Default.Star,\n                imageVector = Icons.Default.Movie,\n                contentDescription = stringResource(id = R.string.movie),\n                modifier = Modifier.clickable {\n                    // ...\n            )\n            // ...\n        }\n    }\n}</pre> <p>Change the icon in the tab in <code>ListScaffold</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    // ...\n) {\n    Scaffold(\n        // ...\n        bottomBar = {\n            NavigationBar {\n                // ...\n                ScreenSelectButton(\n                    targetScreen = MovieList,\n//                  imageVector = Icons.Default.Star,\n                    imageVector = Icons.Default.Movie,\n                    labelId = R.string.movies,\n                    currentScreen = currentScreen,\n                    // ...\n                )\n                // ...\n            }\n        },\n        // ...\n    ) { paddingValues -&gt;\n        // ...\n    }\n}</pre> <p>At this point you can run the application you'll now see movie icons.</p> <p></p> <p>Now we need to either shrink the app to remove all of the extra icons (this slows down the build!) or copy the source for the icons we need. We'll copy the source.</p> <ol> <li>Open <code>MovieListUi</code> in the editor</li> <li>Find <code>Icons.Default.Movie</code></li> <li>Control-click on <code>Movie</code> to go to its source code. (If you don't see the source you'll need       to try a different version of <code>material-icons-extended</code>)</li> <li>Copy the package name from the source</li> <li>Right-click on <code>java</code> under <code>app/src/main</code></li> <li>Choose New &gt; Package</li> <li>Paste the package name</li> <li>Copy the entire source (including the copyright header at the top) for the <code>Movie</code> icon</li> <li>Right-click the package you just created</li> <li>Choose New &gt; Kotlin Class/File</li> <li>Type \"Movie\" as the name and choose File</li> <li>Delete the package statement and paste the source code</li> </ol> <p>We now have a copy of the icon.</p> <p>Next, remove the huge dependency by deleting or commenting out the implementation line from <code>app/build.gradle.kts</code>. Be sure to re-sync the Gradle info by clicking the elephant on the tool bar.</p> show in full file  app/build.gradle.kts <pre>// ...\ndependencies {\n    implementation(project(\":repository\"))\n\n//    implementation(libs.icons.extended)\n    implementation(libs.lifecycle.compose)\n    implementation(libs.androidx.core.ktx)\n    // ...\n}</pre> <p>Note</p> <p>You do not need to delete the dependency information from the version catalog. This will allow you to more easily copy in other icons if you need to at a later date. I recommend leaving it and commenting out the dependency.</p> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n        minSdk = libs.versions.minSdk.get().toInt()\n        targetSdk = libs.versions.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(project(\":repository\"))\n\n//    implementation(libs.icons.extended)\n    implementation(libs.lifecycle.compose)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n</pre> ADDED: app/src/main/java/androidx/compose/material/icons/filled/Movie.kt <pre>/*\n * Copyright 2024 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage androidx.compose.material.icons.filled\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.materialIcon\nimport androidx.compose.material.icons.materialPath\nimport androidx.compose.ui.graphics.vector.ImageVector\n\npublic val Icons.Filled.Movie: ImageVector\n    get() {\n        if (_movie != null) {\n            return _movie!!\n        }\n        _movie = materialIcon(name = \"Filled.Movie\") {\n            materialPath {\n                moveTo(18.0f, 4.0f)\n                lineToRelative(2.0f, 4.0f)\n                horizontalLineToRelative(-3.0f)\n                lineToRelative(-2.0f, -4.0f)\n                horizontalLineToRelative(-2.0f)\n                lineToRelative(2.0f, 4.0f)\n                horizontalLineToRelative(-3.0f)\n                lineToRelative(-2.0f, -4.0f)\n                horizontalLineTo(8.0f)\n                lineToRelative(2.0f, 4.0f)\n                horizontalLineTo(7.0f)\n                lineTo(5.0f, 4.0f)\n                horizontalLineTo(4.0f)\n                curveToRelative(-1.1f, 0.0f, -1.99f, 0.9f, -1.99f, 2.0f)\n                lineTo(2.0f, 18.0f)\n                curveToRelative(0.0f, 1.1f, 0.9f, 2.0f, 2.0f, 2.0f)\n                horizontalLineToRelative(16.0f)\n                curveToRelative(1.1f, 0.0f, 2.0f, -0.9f, 2.0f, -2.0f)\n                verticalLineTo(4.0f)\n                horizontalLineToRelative(-4.0f)\n                close()\n            }\n        }\n        return _movie!!\n    }\n\nprivate var _movie: ImageVector? = null\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.annotation.StringRes\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material.icons.filled.Person\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.NavigationBar\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.ScreenSelectButton\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    @StringRes titleId: Int,\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedItems: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(titleId)) },\n                    actions = {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = { Text(text = selectedIds.size.toString(), modifier = Modifier.padding(8.dp)) },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedItems) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        bottomBar = {\n            NavigationBar {\n                ScreenSelectButton(\n                    targetScreen = RatingList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.ratings,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = MovieList,\n//                  imageVector = Icons.Default.Star,\n                    imageVector = Icons.Default.Movie,\n                    labelId = R.string.movies,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = ActorList,\n                    imageVector = Icons.Default.Person,\n                    labelId = R.string.actors,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n            }\n        },\n        modifier = modifier\n    ) { paddingValues -&gt;\n        List(\n            items = items,\n            onItemClicked = onItemClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            modifier = Modifier\n                .padding(paddingValues)\n                .fillMaxSize(),\n            itemContent = itemContent,\n        )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieList.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.repository.MovieDto\n\n@Composable\nfun MovieListUi(\n    movies: List&lt;MovieDto&gt;,\n    modifier: Modifier = Modifier,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n) {\n    ListScaffold(\n        titleId = R.string.movies,\n        items = movies,\n        onItemClicked = onMovieClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n    ) { movie -&gt;\n        Row(\n            verticalAlignment = Alignment.CenterVertically,\n            modifier = Modifier.padding(8.dp)\n        ) {\n            Icon(\n//              imageVector = Icons.Default.Star,\n                imageVector = Icons.Default.Movie,\n                contentDescription = stringResource(id = R.string.movie),\n                modifier = Modifier.clickable {\n                    onSelectionToggle(movie.id)\n                }\n            )\n            Display(text = movie.title)\n        }\n    }\n}\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\n\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\n\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\n\nlifecycle-compose = \"2.8.7\"\n\nicons-extended = \"1.7.5\"\n\n[libraries]\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended-android\", version.ref = \"icons-extended\"}\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n</pre>"},{"location":"modules/movie-ui-2/STEP_090_FULL.html","title":"Wrapup","text":"<p>Now we have some nice list support in our application.</p> <p>Note that some of our functions are gathering quite a few parameters. There are a few ways to simplify this that we won't be digging into in this class.</p>"},{"location":"modules/movie-ui-2/STEP_090_FULL.html#create-a-state-holder","title":"Create a State holder","text":"<p>You can group multiple parameters using the \"Parameter Object\" pattern, into a \"State holder\". This is a class that is <code>@Stable</code> or <code>@Immutable</code> and contains multiple state and event functions to simplify parameter passing.</p> <p>The \"Parameter Object\" pattern also helps reduce changes needed when parameters are added or removed.</p> <p>As a quick example, suppose we had a chain of composables that use a custom scaffold we've created. The custom Scaffold takes a list of <code>Action</code> objects that describe top-bar actions.</p> <pre><code>class Action(\n    icon: ImageVector,\n    description: String,\n    onClick: () -&gt; Unit\n)\n\n@Composable\nfun PersonListScreen(\n    title: String,\n    actions: List&lt;Action&gt;,\n    personList: List&lt;Person&gt;,\n    ...\n) {\n    ListScaffold(title, actions, personList, ...)\n}\n\n@Composable\nfun &lt;T&gt; ListScaffold(\n    title: String,\n    actions: List&lt;Action&gt;,\n    items: List&lt;T&gt;,\n    ...\n) {\n    CustomScaffold(title, actions) {\n        // display items in a LazyColumn\n    }\n}\n\n@Composable\nfun CustomScaffold(\n    title: String,\n    actions: List&lt;Action&gt;,\n    content: @Composable (PaddingValues) -&gt; Unit\n) {\n    Scaffold(\n        topBar = { /* set up title and actions */ }\n        ...\n        content = content,\n    )\n}\n</code></pre> <p>Note how we need to pass multiple parameters down just to get them to the <code>CustomScaffold</code>.</p> <p>Think about what happens when we need to add or remove another parameter for <code>CustomScaffold</code>; we'd need to pass it down or remove it as well.</p> <p>By grouping parameters into a Parameter object, we can alleviate this:</p> <pre><code>class Action(\n    icon: ImageVector,\n    description: String,\n    onClick: () -&gt; Unit\n)\n\nclass CustomScaffoldState(\n    title: String,\n    actions: List&lt;Action&gt;,\n)\n\n@Composable\nfun PersonListScreen(\n    scaffoldState: CustomScaffoldState,\n    personList: List&lt;Person&gt;,\n    ...\n) {\n    ListScaffold(scaffoldState, personList, ...)\n}\n\n@Composable\nfun &lt;T&gt; ListScaffold(\n    scaffoldState: CustomScaffoldState,\n    items: List&lt;T&gt;,\n    ...\n) {\n    CustomScaffold(scaffoldState) {\n        // display items in a LazyColumn\n    }\n}\n\n@Composable\nfun CustomScaffold(\n    scaffoldState: CustomScaffoldState,\n    content: @Composable (PaddingValues) -&gt; Unit\n) {\n    Scaffold(\n        topBar = { /* set up title and actions from scaffoldState */ }\n        ...\n        content = content,\n    )\n}\n</code></pre> <p>Now we can add/remove parameters to/from <code>CustomScaffoldState</code> without affecting the intermediate functions.</p> <p><code>CustomScaffoldState</code> is known as a \"State holder\" in Compose terms.</p>"},{"location":"modules/movie-ui-2/STEP_090_FULL.html#composition-locals","title":"Composition Locals","text":"<p>Alternatively, you can define a Composition Local to scope data around composable calls.</p> <p>Warning</p> <p>I feel this is generally a bad idea, as it makes composable functions more difficult to reason about and test. In general, passing parameters down makes your composable functions much more clear.</p> <p>There are some uses of it in Compose, such as <code>MaterialTheme</code>, <code>LocalContext</code> and <code>LocalDensity</code> that are useful, but I would much rather have had a context object that all functions take that accesses these data.</p> <p>The above link gives a great description of Composition Locals, but please don't use them, or use them only with great responsibility.</p>"},{"location":"modules/movie-ui-2/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/movie-ui-2. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>movie-ui-2</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/movie-ui-2\n</code></pre>"},{"location":"modules/movie-ui-3/index.html","title":"Overview","text":"<p>We implemented deletions from the main movie, actor and ratings lists, but we haven't implemented it for the lists in the display screens. For example, deleting cast/filmography entries from a movie or actor display.</p> <p>And what about editing the fields in each of our entities?</p>"},{"location":"modules/movie-ui-3/STEP_020_REPO.html","title":"Display-screen list cleanup","text":"<p>In our previous example, you could not delete items from display screens. For example, the Rating display screen shows a list of movies with that rating, but you cannot delete the movies from that screen.</p> <p>We'd like to reuse as much as possible, but our <code>ListScaffold</code> isn't as flexible as we need. It manages the entire body content as a <code>List</code>. For our display screens, we have other content above the list of children.</p> <p>But let's not ignore a big issue: When we rotate the screen, there's very little room for the list. If there were more fields at the top, or the user increases the font size, we may lose some field and the list completely!</p> <p></p> <p>So we need to take advantage of adding individual items to the <code>LazyColumn</code>, as follows:</p> <pre><code>LazyColumn(...) {\n    item {\n        // fixed part of UI - could be multiple separate item {...} blocks \n    }\n\n    items(list) { // dynamic part\n        // card for each item in the list\n    }\n}\n</code></pre> <p>We do this as follows. Add a <code>topContent</code> parameter in <code>List</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/List.kt <pre>// ...\n\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun &lt;T: HasId&gt; List(\n    // ...\n    onClearSelections: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    topContent: (@Composable () -&gt; Unit)? = null,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    // ...\n}</pre> <p>Add a <code>topContent</code> parameter in <code>ListScaffold</code> and pass it from <code>ListScaffold</code> to <code>List</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    // ...\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    topContent: (@Composable () -&gt; Unit)? = null,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    Scaffold(\n        // ...\n    ) { paddingValues -&gt;\n        List(\n            // ...\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            topContent = topContent,\n            modifier = Modifier\n                .padding(paddingValues)\n                // ...\n        )\n    }\n}</pre> <p>Add <code>topContent</code> (if it exists) as a fixed <code>item</code> to the <code>LazyColumn</code> when setting up the <code>List</code>. We'll only pass <code>topContent</code> in the display screens. (The list screens only display the dynamic lists.)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/List.kt <pre>// ...\n\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun &lt;T: HasId&gt; List(\n    // ...\n) {\n    LazyColumn(\n        modifier = modifier\n    ) {\n        topContent?.let {\n            item {\n                topContent()\n            }\n        }\n        items(\n            items = items,\n            // ...\n    }\n}</pre> <p>Because the display screens now have selectable lists, we need to add selection parameters to them, as well as the other parameters needed for the <code>ListScaffold</code>. (Here we show <code>RatingDisplay</code>, but we need to do the same to <code>MovieDisplay</code> and <code>ActorDisplay</code>)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>// ...\n//@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RatingDisplayUi(\n    // ...\n    fetchRating: suspend (String) -&gt; RatingWithMoviesDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var ratingWithMovies by remember { mutableStateOf&lt;RatingWithMoviesDto?&gt;(null) }\n    // ...\n}</pre> <p>Collect the <code>selection</code> state from the view model (in <code>Ui()</code>) and pass the selection and other top-bar parameters to the display screen</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        }\n        is RatingDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            RatingDisplayUi(\n                // ...\n//              onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        // ...\n    }\n}</pre> <p>And finally convert the <code>Scaffold</code> to <code>ListScaffold</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>// ...\n//@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RatingDisplayUi(\n    // ...\n) {\n    // ...\n        }\n    }\n//  Scaffold(\n//      topBar = {\n//          TopAppBar(\n//              title = {\n//                  Text(text = ratingWithMovies?.rating?.name ?: stringResource(R.string.loading))\n//              }\n    ListScaffold(\n        titleId = R.string.rating,\n        items = ratingWithMovies?.movies?.sortedBy { it.title } ?: emptyList(),\n        onItemClicked = onMovieClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { movie -&gt;\n            Display(\n                text = movie.title\n            )\n//      }\n//  ) { paddingValues -&gt;\n        },\n        topContent = {\n            ratingWithMovies?.let { ratingWithMovies -&gt;\n//          Column(\n//              modifier = Modifier\n//                  .padding(paddingValues)\n//          ) {\n                Label(textId = R.string.name)\n                Display(text = ratingWithMovies.rating.name)\n                Label(textId = R.string.description)\n                Display(text = ratingWithMovies.rating.description)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_rated,\n                        ratingWithMovies.rating.name\n                    )\n                )\n//              List(\n//                  items = ratingWithMovies.movies.sortedBy { it.title },\n//                  onItemClicked = onMovieClicked,\n//                  selectedIds = emptySet(),\n//                  onSelectionToggle = {},\n//                  onClearSelections = {},\n//                  modifier = Modifier.weight(1f)\n//              ) { movie -&gt;\n//                  Display(\n//                      text = movie.title\n            }\n        }\n    )\n//              }\n//          }\n//      }\n//  }\n}</pre> <p>After making these changes, the entire display screen scrolls. We have reasonable space to look at the list items and fixed items!</p> <p></p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/ActorDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import androidx.compose.foundation.layout.Column\n//import androidx.compose.foundation.layout.padding\n//import androidx.compose.material3.ExperimentalMaterial3Api\n//import androidx.compose.material3.Scaffold\n//import androidx.compose.material3.Text\n//import androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.ActorWithFilmographyDto\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n//@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun ActorDisplayUi(\n    id: String,\n    fetchActor: suspend (String) -&gt; ActorWithFilmographyDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var actorWithFilmography by remember { mutableStateOf&lt;ActorWithFilmographyDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            actorWithFilmography = fetchActor(id)\n        }\n    }\n//  Scaffold(\n//      topBar = {\n//          TopAppBar(\n//              title = {\n//                  Text(text = actorWithFilmography?.actor?.name ?: stringResource(R.string.loading))\n//              }\n//          )\n//      }\n//  ) { paddingValues -&gt;\n//      actorWithFilmography?.let { actorWithFilmography -&gt;\n//          Column(\n//              modifier = Modifier\n//                  .padding(paddingValues)\n//          ) {\n    ListScaffold(\n        titleId = R.string.actor,\n        items = actorWithFilmography?.filmography?.sortedBy { it.movie.title } ?: emptyList(),\n        onItemClicked = { onMovieClicked(it.movie) },\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Display(text = role.movie.title)\n        },\n        topContent = {\n            Label(textId = R.string.name)\n//              Display(text = actorWithFilmography.actor.name)\n            Display(text = actorWithFilmography?.actor?.name ?: \"\")\n            Label(\n                text = stringResource(\n                    id = R.string.movies_starring,\n//                      actorWithFilmography.actor.name\n                    actorWithFilmography?.actor?.name ?: \"\"\n                )\n            )\n//              List(\n//                  items = actorWithFilmography.filmography.sortedBy { it.movie.title },\n//                  onItemClicked = { onMovieClicked(it.movie) },\n//                  selectedIds = emptySet(),\n//                  onSelectionToggle = {},\n//                  onClearSelections = {},\n//                  modifier = Modifier.weight(1f)\n//              ) { role -&gt;\n//                  Display(text = role.movie.title)\n//              }\n//          }\n//      }\n        }\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/List.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.foundation.ExperimentalFoundationApi\nimport androidx.compose.foundation.combinedClickable\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.LazyListState\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Card\nimport androidx.compose.material3.CardDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.contentColorFor\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun &lt;T: HasId&gt; List(\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    topContent: (@Composable () -&gt; Unit)? = null,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    LazyColumn(\n        modifier = modifier\n    ) {\n        topContent?.let {\n            item {\n                topContent()\n            }\n        }\n        items(\n            items = items,\n            key = { it.id },\n        ) { item -&gt;\n            val containerColor =\n                if (item.id in selectedIds) {\n                    MaterialTheme.colorScheme.secondary\n                } else {\n                    MaterialTheme.colorScheme.surface\n                }\n            val contentColor = MaterialTheme.colorScheme.contentColorFor(containerColor)\n            if (selectedIds.isNotEmpty()) {\n                BackHandler {\n                    onClearSelections()\n                }\n            }\n            Card(\n                elevation = CardDefaults.cardElevation(\n                    defaultElevation = 8.dp,\n                ),\n                colors = CardDefaults.cardColors(\n                    containerColor = containerColor,\n                    contentColor = contentColor,\n                ),\n                modifier = Modifier\n                    .padding(8.dp)\n                    .combinedClickable(\n                        onClick = {\n                            if (selectedIds.isEmpty()) {\n                                onItemClicked(item)\n                            } else {\n                                onSelectionToggle(item.id)\n                            }\n                        },\n                        onLongClick = {\n                            onSelectionToggle(item.id)\n                        },\n                    )\n            ) {\n                itemContent(item)\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.annotation.StringRes\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyListState\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material.icons.filled.Person\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.NavigationBar\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.ScreenSelectButton\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    @StringRes titleId: Int,\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedItems: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    topContent: (@Composable () -&gt; Unit)? = null,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(titleId)) },\n                    actions = {\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = { Text(text = selectedIds.size.toString(), modifier = Modifier.padding(8.dp)) },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedItems) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        bottomBar = {\n            NavigationBar {\n                ScreenSelectButton(\n                    targetScreen = RatingList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.ratings,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = MovieList,\n                    imageVector = Icons.Default.Movie,\n                    labelId = R.string.movies,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = ActorList,\n                    imageVector = Icons.Default.Person,\n                    labelId = R.string.actors,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n            }\n        },\n        modifier = modifier\n    ) { paddingValues -&gt;\n        List(\n            items = items,\n            onItemClicked = onItemClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            topContent = topContent,\n            modifier = Modifier\n                .padding(paddingValues)\n                .fillMaxSize(),\n            itemContent = itemContent,\n        )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import androidx.compose.foundation.layout.Column\n//import androidx.compose.foundation.layout.padding\n//import androidx.compose.foundation.rememberScrollState\n//import androidx.compose.foundation.verticalScroll\n//import androidx.compose.material3.ExperimentalMaterial3Api\n//import androidx.compose.material3.Scaffold\n//import androidx.compose.material3.Text\n//import androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\n//import com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.MovieWithCastDto\nimport com.androidbyexample.compose.movies.repository.RoleWithActorDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n//@OptIn(ExperimentalMaterial3Api::class) // for TopAppBar\n@Composable\nfun MovieDisplayUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    onActorClicked: (RoleWithActorDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n//  Scaffold(\n//      topBar = {\n//          TopAppBar(\n//              title = {\n//                  Text(text = movieWithCast?.movie?.title ?: stringResource(R.string.loading))\n//              }\n//          )\n//      },\n//      modifier = modifier,\n//  ) { innerPadding -&gt;\n//      movieWithCast?.let { movieWithCast -&gt;\n//          Column (\n//              modifier = Modifier\n//                  .padding(innerPadding)\n//          ) {\n//              Label (textId = R.string.title)\n//              Display(text = movieWithCast.movie.title)\n//              Label(textId = R.string.description)\n//              Display(text = movieWithCast.movie.description)\n//              Label(textId = R.string.cast)\n//\n//              List(\n//                  items = movieWithCast.cast.sortedBy { it.orderInCredits },\n    ListScaffold(\n        titleId = R.string.movie,\n        items = movieWithCast?.cast?.sortedBy { it.orderInCredits } ?: emptyList(),\n        onItemClicked = onActorClicked,\n//                  selectedIds = emptySet(),\n//                  onSelectionToggle = {},\n//                  onClearSelections = {},\n//                  modifier = Modifier.weight(1f)\n//              ) { role -&gt;\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Display(\n                text = stringResource(\n                    R.string.cast_entry,\n                    role.character,\n                    role.actor.name,\n                )\n            )\n        },\n        topContent = {\n            Label(textId = R.string.title)\n            Display(text = movieWithCast?.movie?.title ?: \"\")\n            Label(textId = R.string.description)\n            Display(text = movieWithCast?.movie?.description ?: \"\")\n            Label(textId = R.string.cast)\n        }\n//          }\n//      }\n//  }\n//}\n    )}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\n//import androidx.compose.foundation.layout.Column\n//import androidx.compose.foundation.layout.padding\n//import androidx.compose.material3.ExperimentalMaterial3Api\n//import androidx.compose.material3.Scaffold\n//import androidx.compose.material3.Text\n//import androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.RatingWithMoviesDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n//@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun RatingDisplayUi(\n    id: String,\n    fetchRating: suspend (String) -&gt; RatingWithMoviesDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var ratingWithMovies by remember { mutableStateOf&lt;RatingWithMoviesDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            ratingWithMovies = fetchRating(id)\n        }\n    }\n//  Scaffold(\n//      topBar = {\n//          TopAppBar(\n//              title = {\n//                  Text(text = ratingWithMovies?.rating?.name ?: stringResource(R.string.loading))\n//              }\n    ListScaffold(\n        titleId = R.string.rating,\n        items = ratingWithMovies?.movies?.sortedBy { it.title } ?: emptyList(),\n        onItemClicked = onMovieClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { movie -&gt;\n            Display(\n                text = movie.title\n            )\n//      }\n//  ) { paddingValues -&gt;\n        },\n        topContent = {\n            ratingWithMovies?.let { ratingWithMovies -&gt;\n//          Column(\n//              modifier = Modifier\n//                  .padding(paddingValues)\n//          ) {\n                Label(textId = R.string.name)\n                Display(text = ratingWithMovies.rating.name)\n                Label(textId = R.string.description)\n                Display(text = ratingWithMovies.rating.description)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_rated,\n                        ratingWithMovies.rating.name\n                    )\n                )\n//              List(\n//                  items = ratingWithMovies.movies.sortedBy { it.title },\n//                  onItemClicked = onMovieClicked,\n//                  selectedIds = emptySet(),\n//                  onSelectionToggle = {},\n//                  onClearSelections = {},\n//                  modifier = Modifier.weight(1f)\n//              ) { movie -&gt;\n//                  Display(\n//                      text = movie.title\n            }\n        }\n    )\n//              }\n//          }\n//      }\n//  }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n//              onActorClicked = { viewModel.pushScreen(ActorDisplay(it.actor.id)) },\n                onActorClicked = { viewModel.pushScreen(ActorDisplay(it.actor.id)) },                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                modifier = modifier,\n            )\n        }\n        is ActorDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            ActorDisplayUi(\n                id = screen.id,\n                fetchActor = viewModel::getActorWithFilmography,\n//              onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        is RatingDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            RatingDisplayUi(\n                id = screen.id,\n                fetchRating = viewModel::getRatingWithMovies,\n//              onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) }\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                },\n            )\n        }\n        ActorList -&gt; {\n            val actors by viewModel.actorsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            ActorListUi(\n                actors = actors,\n                onActorClicked = { actor -&gt;\n                    viewModel.pushScreen(ActorDisplay(actor.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedActors = viewModel::deleteSelectedActors,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        RatingList -&gt; {\n            val ratings by viewModel.ratingsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            RatingListUi(\n                ratings = ratings,\n                onRatingClicked = { rating -&gt;\n                    viewModel.pushScreen(RatingDisplay(rating.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedRatings = viewModel::deleteSelectedRatings,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n    }\n}\n</pre>"},{"location":"modules/movie-ui-3/STEP_030_REPO.html","title":"Deleting from the display screens","text":"<p>Now that we have selectable lists inside the display screens, let's allow deletions.</p> <p>First, let's add icons to the items in the display screens:</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>// ...\n\n@Composable\nfun RatingDisplayUi(\n    // ...\n) {\n    // ...\n    ListScaffold(\n        // ...\n        modifier = modifier,\n        itemContent = { movie -&gt;\n//          Display(\n//              text = movie.title\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(movie.id)\n                    }\n                )\n                Display(text = movie.title)\n            }\n        },\n        topContent = {\n            // ...\n    )\n}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@Composable\nfun MovieDisplayUi(\n    // ...\n) {\n    // ...\n    ListScaffold(\n        // ...\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(role.id)\n                    }\n                )\n                Display(\n                    text = stringResource(\n                        R.string.cast_entry,\n                        role.character,\n                        role.actor.name,\n                    )\n                )\n            }\n        },\n        topContent = {\n            // ...\n    )}</pre> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ActorDisplay.kt <pre>// ...\n\n@Composable\nfun ActorDisplayUi(\n    // ...\n) {\n    // ...\n    ListScaffold(\n        // ...\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(role.id)\n                    }\n                )\n                Display(text = role.movie.title)\n            }\n        },\n        topContent = {\n            // ...\n    )\n}</pre> <p>This allows clicking on the icons to select, in addition to long-pressing the cards.</p> <p>Note</p> <p>For the movie and actor display screens, the data we're displaying is role information, and we're using the derived id for these objects in <code>RoleWithMovieDto</code> and <code>RoleWithActorDto</code>. This will not work for <code>RoleEntity</code> deletion. To properly delete the roles we would need to track the actor id, movie id, and order in credits so we can match them up for deletion. I'm leaving that as the obligatory \"exercise for the interested reader\", and we'll only focus on deleting movies via the rating display screen.</p> <p>To test deletion, we:</p> <ol> <li>Go to the ratings list</li> <li>Select PG-13</li> <li>Click on the icon next to \"Hobbs and Shaw\"</li> <li>Click the trash can on the top bar to delete the movie    And... nothing happens! Or at least nothing seems to happen.    </li> <li>But if we click on the ratings list</li> <li>Then go back into PG-13</li> </ol> <p>We see that \"Hobbs and Shaw\" has indeed been deleted.</p> <p>What's happening?</p> <p>Once again, it's all down to where the state is being set/read.</p> <ol> <li>When we select PG-13, we pass the id of the PG-13 entity into <code>RatingDisplayUi</code></li> <li><code>RatingDisplayUi</code> fetches a <code>RatingWithMoviesDto</code> using that id inside a <code>LaunchedEffect</code></li> <li>When we delete a movie from the database, the only thing that changes is the data in the    <code>MovieEntity</code> table, emitting a new <code>MovieList</code> to the <code>Flow</code> for all movies.</li> <li>We're not collecting that <code>Flow</code> for this screen; nothing triggers a refetch of the    currently-displayed rating (the rating id hasn't changed)</li> <li>We're stuck with the previously-fetched <code>RatingWithMoviesDto</code>.</li> </ol> <p>How do we fix this? We need something to tell us that our local movie list has changed.</p> <p>Pass in the <code>RoleWithMoviesDto</code> instead of fetching it (and get rid of the fetcher function and <code>LaunchedEffect</code> that loaded the movie)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>// ...\n\n@Composable\nfun RatingDisplayUi(\n//  id: String,\n//  fetchRating: suspend (String) -&gt; RatingWithMoviesDto,\n    ratingWithMovies: RatingWithMoviesDto?,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    // ...\n) {\n    // ...\n}</pre> <p>Create a DAO function to get a rating with its movies using a <code>Flow</code></p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>// ...\n\n@Dao\nabstract class MovieDao {\n    // ...\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMovies&gt;\n\n    @Insert\n    // ...\n}</pre> <p>Forward that function through the repository, database repository implementation, and view model (automatically done via delegation)</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\ninterface MovieRepository {\n    // ...\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n\n    fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt;\n\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    // ...\n}</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nclass MovieDatabaseRepository(\n    // ...\n): MovieRepository {\n    // ...\n            }\n\n    override fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt; =\n        dao.getRatingWithMoviesFlow(id)\n            .map { it.toDto() }\n\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        // ...\n}</pre> <p>Collect the <code>Flow</code> and pass the result into the rating display</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        is RatingDisplay -&gt; {\n            // ...\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            val ratingWithMovies by viewModel\n                .getRatingWithMoviesFlow(screen.id)\n                .collectAsStateWithLifecycle(initialValue = null)\n\n            RatingDisplayUi(\n//              id = screen.id,\n//              fetchRating = viewModel::getRatingWithMovies,\n                ratingWithMovies = ratingWithMovies,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                // ...\n            )\n        }\n        // ...\n    }\n}</pre> <p>Poof! It works now!</p> <p>The trick here was using data that's automatically updated, sending us a new <code>RoleWithMoviesDto</code> when a movie is deleted. We collect that flow in <code>Ui</code>, updating the value that we pass into the rating display, triggering recomposition.</p> <p>The list will also display when the reset-database button on the top bar is pressed.</p> <p>!</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/ActorDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.ActorWithFilmographyDto\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@Composable\nfun ActorDisplayUi(\n    id: String,\n    fetchActor: suspend (String) -&gt; ActorWithFilmographyDto,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var actorWithFilmography by remember { mutableStateOf&lt;ActorWithFilmographyDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            actorWithFilmography = fetchActor(id)\n        }\n    }\n    ListScaffold(\n        titleId = R.string.actor,\n        items = actorWithFilmography?.filmography?.sortedBy { it.movie.title } ?: emptyList(),\n        onItemClicked = { onMovieClicked(it.movie) },\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(role.id)\n                    }\n                )\n                Display(text = role.movie.title)\n            }\n        },\n        topContent = {\n            Label(textId = R.string.name)\n            Display(text = actorWithFilmography?.actor?.name ?: \"\")\n            Label(\n                text = stringResource(\n                    id = R.string.movies_starring,\n                    actorWithFilmography?.actor?.name ?: \"\"\n                )\n            )\n        }\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieWithCastDto\nimport com.androidbyexample.compose.movies.repository.RoleWithActorDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@Composable\nfun MovieDisplayUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    onActorClicked: (RoleWithActorDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n    ListScaffold(\n        titleId = R.string.movie,\n        items = movieWithCast?.cast?.sortedBy { it.orderInCredits } ?: emptyList(),\n        onItemClicked = onActorClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(role.id)\n                    }\n                )\n                Display(\n                    text = stringResource(\n                        R.string.cast_entry,\n                        role.character,\n                        role.actor.name,\n                    )\n                )\n            }\n        },\n        topContent = {\n            Label(textId = R.string.title)\n            Display(text = movieWithCast?.movie?.title ?: \"\")\n            Label(textId = R.string.description)\n            Display(text = movieWithCast?.movie?.description ?: \"\")\n            Label(textId = R.string.cast)\n        }\n    )}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/RatingDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.RatingWithMoviesDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@Composable\nfun RatingDisplayUi(\n//  id: String,\n//  fetchRating: suspend (String) -&gt; RatingWithMoviesDto,\n    ratingWithMovies: RatingWithMoviesDto?,\n    onMovieClicked: (MovieDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n//  var ratingWithMovies by remember { mutableStateOf&lt;RatingWithMoviesDto?&gt;(null) }\n//  LaunchedEffect(key1 = id) {\n//      withContext(Dispatchers.IO) {\n//          ratingWithMovies = fetchRating(id)\n//      }\n//  }\n    ListScaffold(\n        titleId = R.string.rating,\n        items = ratingWithMovies?.movies?.sortedBy { it.title } ?: emptyList(),\n        onItemClicked = onMovieClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { movie -&gt;\n//          Display(\n//              text = movie.title\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(movie.id)\n                    }\n                )\n                Display(text = movie.title)\n            }\n        },\n        topContent = {\n            ratingWithMovies?.let { ratingWithMovies -&gt;\n                Label(textId = R.string.name)\n                Display(text = ratingWithMovies.rating.name)\n                Label(textId = R.string.description)\n                Display(text = ratingWithMovies.rating.description)\n                Label(\n                    text = stringResource(\n                        id = R.string.movies_rated,\n                        ratingWithMovies.rating.name\n                    )\n                )\n            }\n        }\n    )\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                onActorClicked = { viewModel.pushScreen(ActorDisplay(it.actor.id)) },                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                modifier = modifier,\n            )\n        }\n        is ActorDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            ActorDisplayUi(\n                id = screen.id,\n                fetchActor = viewModel::getActorWithFilmography,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        is RatingDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            val ratingWithMovies by viewModel\n                .getRatingWithMoviesFlow(screen.id)\n                .collectAsStateWithLifecycle(initialValue = null)\n\n            RatingDisplayUi(\n//              id = screen.id,\n//              fetchRating = viewModel::getRatingWithMovies,\n                ratingWithMovies = ratingWithMovies,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                },\n            )\n        }\n        ActorList -&gt; {\n            val actors by viewModel.actorsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            ActorListUi(\n                actors = actors,\n                onActorClicked = { actor -&gt;\n                    viewModel.pushScreen(ActorDisplay(actor.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedActors = viewModel::deleteSelectedActors,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        RatingList -&gt; {\n            val ratings by viewModel.ratingsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            RatingListUi(\n                ratings = ratings,\n                onRatingClicked = { rating -&gt;\n                    viewModel.pushScreen(RatingDisplay(rating.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedRatings = viewModel::deleteSelectedRatings,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class MovieDao {\n    @Query(\"SELECT * FROM RatingEntity\")\n    abstract fun getRatingsFlow(): Flow&lt;List&lt;RatingEntity&gt;&gt;\n    @Query(\"SELECT * FROM MovieEntity\")\n    abstract fun getMoviesFlow(): Flow&lt;List&lt;MovieEntity&gt;&gt;\n    @Query(\"SELECT * FROM ActorEntity\")\n    abstract fun getActorsFlow(): Flow&lt;List&lt;ActorEntity&gt;&gt;\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract suspend fun getRatingWithMovies(id: String): RatingWithMovies\n    @Transaction\n    @Query(\"SELECT * FROM ActorEntity WHERE id = :id\")\n    abstract suspend fun getActorWithFilmography(id: String): ActorWithFilmography\n    @Transaction\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMovies&gt;\n\n    @Insert\n    abstract suspend fun insert(vararg ratings: RatingEntity)\n    @Insert\n    abstract suspend fun insert(vararg movies: MovieEntity)\n    @Insert\n    abstract suspend fun insert(vararg actors: ActorEntity)\n    @Insert\n    abstract suspend fun insert(vararg roles: RoleEntity)\n\n    @Query(\"DELETE FROM MovieEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM ActorEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM RatingEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    @Query(\"DELETE FROM MovieEntity\")\n    abstract suspend fun clearMovies()\n    @Query(\"DELETE FROM ActorEntity\")\n    abstract suspend fun clearActors()\n    @Query(\"DELETE FROM RatingEntity\")\n    abstract suspend fun clearRatings()\n    @Query(\"DELETE FROM RoleEntity\")\n    abstract suspend fun clearRoles()\n    @Transaction\n    open suspend fun resetDatabase() {\n        clearMovies()\n        clearActors()\n        clearRoles()\n        clearRatings()\n        insert(\n            RatingEntity(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            RatingEntity(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            RatingEntity(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            RatingEntity(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            RatingEntity(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n        insert(\n            MovieEntity(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            MovieEntity(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            MovieEntity(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            MovieEntity(\"m4\", \"Jumanji - Welcome to the Jungle\", \"The Rock smolders\", \"r3\"),\n        )\n        insert(\n            ActorEntity(\"a1\", \"Jason Statham\"),\n            ActorEntity(\"a2\", \"The Rock\"),\n            ActorEntity(\"a3\", \"Shu Qi\"),\n            ActorEntity(\"a4\", \"Amber Valletta\"),\n            ActorEntity(\"a5\", \"Kevin Hart\"),\n        )\n        insert(\n            RoleEntity(\"m1\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m1\", \"a3\", \"Lai\", 2),\n            RoleEntity(\"m2\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            RoleEntity(\"m3\", \"a2\", \"Hobbs\", 1),\n            RoleEntity(\"m3\", \"a1\", \"Shaw\", 2),\n            RoleEntity(\"m4\", \"a2\", \"Spencer\", 1),\n            RoleEntity(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport android.content.Context\nimport com.androidbyexample.compose.movies.data.MovieDao\nimport com.androidbyexample.compose.movies.data.createDao\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n\n    override fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt; =\n        dao.getRatingWithMoviesFlow(id)\n            .map { it.toDto() }\n\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) = dao.deleteMoviesById(ids)\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) = dao.deleteActorsById(ids)\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) = dao.deleteRatingsById(ids)\n\n    override suspend fun resetDatabase() = dao.resetDatabase()\n\n    companion object {\n        fun create(context: Context) =\n            MovieDatabaseRepository(createDao(context))\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport kotlinx.coroutines.flow.Flow\n\ninterface MovieRepository {\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt;\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n\n    fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt;\n\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    suspend fun getMovieWithCast(id: String): MovieWithCastDto\n    suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto\n    suspend fun insert(movie: MovieDto)\n    suspend fun insert(actor: ActorDto)\n    suspend fun insert(rating: RatingDto)\n\n    suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    suspend fun resetDatabase()\n}\n</pre>"},{"location":"modules/movie-ui-3/STEP_040_REPO.html","title":"Editing a movie","text":"<p>Let's edit some movies!</p> <p>To be able to save the updates, we need to add and expose update functionality.</p> <p>Add \"upsert\" functions in the DAO - these will insert if it doesn't exist, update if it does.</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>// ...\n\n@Dao\nabstract class MovieDao {\n    // ...\n    abstract suspend fun insert(vararg roles: RoleEntity)\n\n    @Upsert\n    abstract suspend fun upsert(vararg ratings: RatingEntity)\n    @Upsert\n    abstract suspend fun upsert(vararg movies: MovieEntity)\n    @Upsert\n    abstract suspend fun upsert(vararg actors: ActorEntity)\n    @Upsert\n    abstract suspend fun upsert(vararg roles: RoleEntity)\n\n\n    // ...\n}</pre> <p>Pass the upserts through in the repository repository database implementation</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\ninterface MovieRepository {\n    // ...\n    suspend fun insert(rating: RatingDto)\n\n    suspend fun upsert(movie: MovieDto)\n    suspend fun upsert(actor: ActorDto)\n    suspend fun upsert(rating: RatingDto)\n\n    suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    // ...\n}</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nclass MovieDatabaseRepository(\n    // ...\n): MovieRepository {\n    // ...\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n\n    override suspend fun upsert(movie: MovieDto) = dao.upsert(movie.toEntity())\n    override suspend fun upsert(actor: ActorDto) = dao.upsert(actor.toEntity())\n    override suspend fun upsert(rating: RatingDto) = dao.upsert(rating.toEntity())\n\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) = dao.deleteMoviesById(ids)\n    // ...\n}</pre> <p>The view model automatically delegates to the repository, but we need to add update <code>Flow</code>s (queues) that will debounce and send the updates</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    // ...\n): ViewModel(), MovieRepository by repository {\n    // ...\n    }\n\n    fun update(movie: MovieDto) {\n        movieUpdateFlow.value = movie\n    }\n    fun update(actor: ActorDto) {\n        actorUpdateFlow.value = actor\n    }\n    fun update(rating: RatingDto) {\n        ratingUpdateFlow.value = rating\n    }\n    // using a debounced flow as a person-update queue\n    private val movieUpdateFlow = MutableStateFlow&lt;MovieDto?&gt;(null)\n    private val actorUpdateFlow = MutableStateFlow&lt;ActorDto?&gt;(null)\n    private val ratingUpdateFlow = MutableStateFlow&lt;RatingDto?&gt;(null)\n    init {\n        viewModelScope.launch {\n            movieUpdateFlow.debounce(500).collect { movie -&gt;\n                movie?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            actorUpdateFlow.debounce(500).collect { actor -&gt;\n                actor?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            ratingUpdateFlow.debounce(500).collect { rating -&gt;\n                rating?.let { repository.upsert(it) }\n            }\n        }\n    }\n\n    fun deleteSelectedMovies() {\n        // ...\n}</pre> <p>Note</p> <p>Keep in mind that Room ensures its suspend functions are run using an IO dispatcher. It uses a call like <code>withContext(Dispatchers.IO) { ... }</code> to wrap all work. This ensures that the calls are \"main-thread safe\", meaning they don't block the main thread. Some other libraries will do similar context switching, but you may want to be extra careful and make your repository calls main-thread safe. For example, you could write</p> <pre><code>override suspend fun upsert(movie: MovieDto) = \n    withContext(Dispatchers.IO) {\n        dao.insert(movie.toEntity())\n    }\n</code></pre> <p>in the <code>MovieDatabaseRepository</code>, ensuring that the called function is switched to the IO dispatcher. Not necessary with Room, but if you use other databases, files, or network, you should do so.</p> <p>We'll follow the \"save to database as we type\" approach for the movie edit process.</p> <p>Add <code>getMovie(id)</code> to the DAO</p> show in full file  data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>// ...\n\n@Dao\nabstract class MovieDao {\n    // ...\n    abstract fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMovies&gt;\n\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovie(id: String): MovieEntity\n\n    @Insert\n    // ...\n}</pre> <p>Pass through the repository and repository database implementation</p> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>// ...\ninterface MovieRepository {\n    // ...\n    fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt;\n\n    suspend fun getMovie(id: String): MovieDto\n\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    // ...\n}</pre> show in full file  repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>// ...\nclass MovieDatabaseRepository(\n    // ...\n): MovieRepository {\n    // ...\n            .map { it.toDto() }\n\n    override suspend fun getMovie(id: String): MovieDto =\n        dao.getMovie(id).toDto()\n\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        // ...\n}</pre> <p>Add new screen data for the movie edit screen</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>// ...\ndata class ActorDisplay(val id: String): Screen\ndata class RatingDisplay(val id: String): Screen\ndata class MovieEdit(val id: String): Screen</pre> <p>Add an event function to <code>ListScaffold</code> to tell the caller to start editing. Note the definition of this function:</p> <pre><code>onEdit: (() -&gt; Unit)? = null,\n</code></pre> <p>That might look a bit odd, but what we're defining is a <code>() -&gt; Unit</code> function that can be   nullable by wrapping the function type in <code>(...)?</code>, then giving it a default value of <code>null</code>.   This allows us to pass it if we need it, otherwise its value is null.</p> <p>Conditionally add an edit button to the <code>ListScaffold</code>, if <code>onEdit</code> is not null. The button will call <code>onEdit</code> with no parameters, informing the caller that the user wants to edit.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    // ...\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(titleId)) },\n                    actions = {\n                        onEdit?.let {\n                            IconButton(onClick = onEdit) {\n                                Icon(\n                                    imageVector = Icons.Default.Edit,\n                                    contentDescription = stringResource(R.string.edit)\n                                )\n                            }\n                        }\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                // ...\n                    }\n                )\n            } else {\n                // ...\n            }\n        },\n        // ...\n    ) { paddingValues -&gt;\n        // ...\n    }\n}</pre> <p>Set up the <code>onEdit</code> call. This one's a bit tricky:     * If we don't have a movie to edit, <code>movieWithCast</code> will be null, causing the <code>let</code> to be null,       resulting in passing <code>null</code> to the <code>ListScaffold</code> - no edit button will be displayed.     * If we have a movie to edit, we want to pass a lambda to <code>ListScaffold</code> for what to do when       the user presses the edit button. The additional curly braces inside the <code>let</code> define a lambda       expression as the last expression in the <code>let</code>, which will be returned from the <code>let</code> and       passed to the <code>ListScaffold</code>.     * The <code>onEdit</code> lambda we created in that <code>let</code> takes the id from the movie in the       currently-displayed <code>MovieWithRoleDto</code>, and tells the caller to edit it.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>// ...\n\n@Composable\nfun MovieDisplayUi(\n    // ...\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    onEdit: (String) -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n    ListScaffold(\n        titleId = R.string.movie,\n        onEdit = movieWithCast?.let {\n            { // if we have a movie, pass this lambda as the edit function (else null from let)\n                onEdit(it.movie.id)\n            }\n        },\n        items = movieWithCast?.cast?.sortedBy { it.orderInCredits } ?: emptyList(),\n        onItemClicked = onActorClicked,\n        // ...\n    )}</pre> <p>Define a movie edit screen to perform the edits. This simple screen doesn't use our common scaffold. It fetches the movie (using our new <code>getMovie</code> function), and doesn't refetch until/unless a new id is passed in. This movie holds the title and description that's being edited. Whenever a change is made, we create a copy with the new value and send it out via <code>onMovieChange</code> so the caller can make a database update.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/MovieEdit.kt <pre>// ...\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MovieEditUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieDto,\n    onMovieChange: (MovieDto) -&gt; Unit,\n) {\n    var movie by remember { mutableStateOf&lt;MovieDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movie = fetchMovie(id)\n        }\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(title = { Text(text = movie?.title ?: \"\") })\n        }\n    ) { paddingValues -&gt;\n        Column(\n            modifier = Modifier.padding(paddingValues)\n        ) {\n            movie?.let { fetchedMovie -&gt;\n                OutlinedTextField(\n                    value = fetchedMovie.title,\n                    label = { Text(text = stringResource(id = R.string.title))},\n                    onValueChange = {\n                        val newMovie = fetchedMovie.copy(title = it)\n                        movie = newMovie\n                        onMovieChange(newMovie)\n                    },\n                )\n                OutlinedTextField(\n                    value = fetchedMovie.description,\n                    label = { Text(text = stringResource(id = R.string.description))},\n                    onValueChange = {\n                        val newMovie = fetchedMovie.copy(description = it)\n                        movie = newMovie\n                        onMovieChange(newMovie)\n                    },\n                )\n            }\n        }\n    }\n}</pre> <p>To finish things up, we set up <code>onEdit</code> in <code>Ui</code> to navigate from the display screen to the edit screen and add the <code>MovieEditScreen</code> to the <code>when</code> in <code>Ui</code></p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>// ...\n\n@Composable\nfun Ui(\n    // ...\n) {\n    // ...\n    when (val screen = viewModel.currentScreen) {\n        // ...\n        is MovieDisplay -&gt; {\n            // ...\n            MovieDisplayUi(\n                // ...\n                    }\n                },\n                onEdit = { viewModel.pushScreen(MovieEdit(it)) },\n                modifier = modifier,\n            )\n        }\n        is MovieEdit -&gt; {\n            MovieEditUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovie,\n                onMovieChange = viewModel::update\n            )\n        }\n        is ActorDisplay -&gt; {\n            val selectedIds by viewModel\n                // ...\n    }\n}</pre> <p>When we run, we can now edit our movie information!</p> <p>I'll leave the other screens as exercises for the interested reader.</p> All code changes CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.repository.ActorDto\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.repository.RatingDto\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\nimport kotlinx.coroutines.FlowPreview\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.debounce\nimport kotlinx.coroutines.launch\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    private val repository: MovieRepository,\n): ViewModel(), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    fun setScreen(screen: Screen) {\n        screenStack = listOf(screen)\n    }\n\n    fun update(movie: MovieDto) {\n        movieUpdateFlow.value = movie\n    }\n    fun update(actor: ActorDto) {\n        actorUpdateFlow.value = actor\n    }\n    fun update(rating: RatingDto) {\n        ratingUpdateFlow.value = rating\n    }\n    // using a debounced flow as a person-update queue\n    private val movieUpdateFlow = MutableStateFlow&lt;MovieDto?&gt;(null)\n    private val actorUpdateFlow = MutableStateFlow&lt;ActorDto?&gt;(null)\n    private val ratingUpdateFlow = MutableStateFlow&lt;RatingDto?&gt;(null)\n    init {\n        viewModelScope.launch {\n            movieUpdateFlow.debounce(500).collect { movie -&gt;\n                movie?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            actorUpdateFlow.debounce(500).collect { actor -&gt;\n                actor?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            ratingUpdateFlow.debounce(500).collect { rating -&gt;\n                rating?.let { repository.upsert(it) }\n            }\n        }\n    }\n\n    fun deleteSelectedMovies() {\n        viewModelScope.launch {\n            deleteMoviesById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedActors() {\n        viewModelScope.launch {\n            deleteActorsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedRatings() {\n        viewModelScope.launch {\n            deleteRatingsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/ListScaffold.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.annotation.StringRes\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.ColumnScope\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyListState\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\nimport androidx.compose.material.icons.filled.Delete\nimport androidx.compose.material.icons.filled.Edit\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material.icons.filled.Person\nimport androidx.compose.material.icons.filled.Refresh\nimport androidx.compose.material.icons.filled.Star\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.Icon\nimport androidx.compose.material3.IconButton\nimport androidx.compose.material3.NavigationBar\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.ScreenSelectButton\nimport com.androidbyexample.compose.movies.repository.HasId\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun &lt;T: HasId&gt; ListScaffold(\n    @StringRes titleId: Int,\n    items: List&lt;T&gt;,\n    onItemClicked: (T) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedItems: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    onEdit: (() -&gt; Unit)? = null,\n    modifier: Modifier = Modifier,\n    topContent: (@Composable () -&gt; Unit)? = null,\n    itemContent: @Composable ColumnScope.(T) -&gt; Unit,\n) {\n    Scaffold(\n        topBar = {\n            if (selectedIds.isEmpty()) {\n                TopAppBar(\n                    title = { Text(text = stringResource(titleId)) },\n                    actions = {\n                        onEdit?.let {\n                            IconButton(onClick = onEdit) {\n                                Icon(\n                                    imageVector = Icons.Default.Edit,\n                                    contentDescription = stringResource(R.string.edit)\n                                )\n                            }\n                        }\n                        IconButton(onClick = onResetDatabase) {\n                            Icon(\n                                imageVector = Icons.Default.Refresh,\n                                contentDescription = stringResource(R.string.reset_database)\n                            )\n                        }\n                    }\n                )\n            } else {\n                TopAppBar(\n                    navigationIcon = {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,\n                            contentDescription = stringResource(R.string.clear_selections),\n                            modifier = Modifier.clickable(onClick = onClearSelections),\n                        )\n                    },\n                    title = { Text(text = selectedIds.size.toString(), modifier = Modifier.padding(8.dp)) },\n                    actions = {\n                        IconButton(onClick = onDeleteSelectedItems) {\n                            Icon(\n                                imageVector = Icons.Default.Delete,\n                                contentDescription = stringResource(R.string.delete_selected_items)\n                            )\n                        }\n                    },\n                )\n            }\n        },\n        bottomBar = {\n            NavigationBar {\n                ScreenSelectButton(\n                    targetScreen = RatingList,\n                    imageVector = Icons.Default.Star,\n                    labelId = R.string.ratings,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = MovieList,\n                    imageVector = Icons.Default.Movie,\n                    labelId = R.string.movies,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n                ScreenSelectButton(\n                    targetScreen = ActorList,\n                    imageVector = Icons.Default.Person,\n                    labelId = R.string.actors,\n                    currentScreen = currentScreen,\n                    onSelectListScreen = onSelectListScreen\n                )\n            }\n        },\n        modifier = modifier\n    ) { paddingValues -&gt;\n        List(\n            items = items,\n            onItemClicked = onItemClicked,\n            selectedIds = selectedIds,\n            onSelectionToggle = onSelectionToggle,\n            onClearSelections = onClearSelections,\n            topContent = topContent,\n            modifier = Modifier\n                .padding(paddingValues)\n                .fillMaxSize(),\n            itemContent = itemContent,\n        )\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieDisplay.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.clickable\nimport androidx.compose.foundation.layout.Row\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.Movie\nimport androidx.compose.material3.Icon\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.unit.dp\nimport com.androidbyexample.compose.movies.R\nimport com.androidbyexample.compose.movies.components.Display\nimport com.androidbyexample.compose.movies.components.Label\nimport com.androidbyexample.compose.movies.repository.MovieWithCastDto\nimport com.androidbyexample.compose.movies.repository.RoleWithActorDto\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@Composable\nfun MovieDisplayUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieWithCastDto,\n    onActorClicked: (RoleWithActorDto) -&gt; Unit,\n    selectedIds: Set&lt;String&gt;,\n    onSelectionToggle: (id: String) -&gt; Unit,\n    onClearSelections: () -&gt; Unit,\n    onDeleteSelectedMovies: () -&gt; Unit,\n    currentScreen: Screen,\n    onSelectListScreen: (Screen) -&gt; Unit,\n    onResetDatabase: () -&gt; Unit,\n    onEdit: (String) -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    var movieWithCast by remember { mutableStateOf&lt;MovieWithCastDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movieWithCast = fetchMovie(id)\n        }\n    }\n\n    ListScaffold(\n        titleId = R.string.movie,\n        onEdit = movieWithCast?.let {\n            { // if we have a movie, pass this lambda as the edit function (else null from let)\n                onEdit(it.movie.id)\n            }\n        },\n        items = movieWithCast?.cast?.sortedBy { it.orderInCredits } ?: emptyList(),\n        onItemClicked = onActorClicked,\n        selectedIds = selectedIds,\n        onSelectionToggle = onSelectionToggle,\n        onClearSelections = onClearSelections,\n        onDeleteSelectedItems = onDeleteSelectedMovies,\n        currentScreen = currentScreen,\n        onSelectListScreen = onSelectListScreen,\n        onResetDatabase = onResetDatabase,\n        modifier = modifier,\n        itemContent = { role -&gt;\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier.padding(8.dp)\n            ) {\n                Icon(\n                    imageVector = Icons.Default.Movie,\n                    contentDescription = stringResource(id = R.string.movie),\n                    modifier = Modifier.clickable {\n                        onSelectionToggle(role.id)\n                    }\n                )\n                Display(\n                    text = stringResource(\n                        R.string.cast_entry,\n                        role.character,\n                        role.actor.name,\n                    )\n                )\n            }\n        },\n        topContent = {\n            Label(textId = R.string.title)\n            Display(text = movieWithCast?.movie?.title ?: \"\")\n            Label(textId = R.string.description)\n            Display(text = movieWithCast?.movie?.description ?: \"\")\n            Label(textId = R.string.cast)\n        }\n    )}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/screens/MovieEdit.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.ExperimentalMaterial3Api\nimport androidx.compose.material3.OutlinedTextField\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TopAppBar\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.stringResource\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.R\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun MovieEditUi(\n    id: String,\n    fetchMovie: suspend (String) -&gt; MovieDto,\n    onMovieChange: (MovieDto) -&gt; Unit,\n) {\n    var movie by remember { mutableStateOf&lt;MovieDto?&gt;(null) }\n    LaunchedEffect(key1 = id) {\n        withContext(Dispatchers.IO) {\n            movie = fetchMovie(id)\n        }\n    }\n    Scaffold(\n        topBar = {\n            TopAppBar(title = { Text(text = movie?.title ?: \"\") })\n        }\n    ) { paddingValues -&gt;\n        Column(\n            modifier = Modifier.padding(paddingValues)\n        ) {\n            movie?.let { fetchedMovie -&gt;\n                OutlinedTextField(\n                    value = fetchedMovie.title,\n                    label = { Text(text = stringResource(id = R.string.title))},\n                    onValueChange = {\n                        val newMovie = fetchedMovie.copy(title = it)\n                        movie = newMovie\n                        onMovieChange(newMovie)\n                    },\n                )\n                OutlinedTextField(\n                    value = fetchedMovie.description,\n                    label = { Text(text = stringResource(id = R.string.description))},\n                    onValueChange = {\n                        val newMovie = fetchedMovie.copy(description = it)\n                        movie = newMovie\n                        onMovieChange(newMovie)\n                    },\n                )\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Screens.kt <pre>package com.androidbyexample.compose.movies.screens\n\nsealed interface Screen\ndata object MovieList: Screen\ndata object ActorList: Screen\ndata object RatingList: Screen\ndata class MovieDisplay(val id: String): Screen\ndata class ActorDisplay(val id: String): Screen\ndata class RatingDisplay(val id: String): Screen\ndata class MovieEdit(val id: String): Screen\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/screens/Ui.kt <pre>package com.androidbyexample.compose.movies.screens\n\nimport androidx.activity.compose.BackHandler\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport com.androidbyexample.compose.movies.MovieViewModel\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun Ui(\n    viewModel: MovieViewModel,\n    modifier: Modifier = Modifier,\n    onExit: () -&gt; Unit,\n) {\n    BackHandler {\n        viewModel.popScreen()\n    }\n\n    val scope = rememberCoroutineScope()\n\n    when (val screen = viewModel.currentScreen) {\n        null -&gt; onExit()\n        is MovieDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieDisplayUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovieWithCast,\n                onActorClicked = { viewModel.pushScreen(ActorDisplay(it.actor.id)) },                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onEdit = { viewModel.pushScreen(MovieEdit(it)) },\n                modifier = modifier,\n            )\n        }\n        is MovieEdit -&gt; {\n            MovieEditUi(\n                id = screen.id,\n                fetchMovie = viewModel::getMovie,\n                onMovieChange = viewModel::update\n            )\n        }\n        is ActorDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            ActorDisplayUi(\n                id = screen.id,\n                fetchActor = viewModel::getActorWithFilmography,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        is RatingDisplay -&gt; {\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            val ratingWithMovies by viewModel\n                .getRatingWithMoviesFlow(screen.id)\n                .collectAsStateWithLifecycle(initialValue = null)\n\n            RatingDisplayUi(\n                ratingWithMovies = ratingWithMovies,\n                onMovieClicked = { viewModel.pushScreen(MovieDisplay(it.id)) },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        MovieList -&gt; {\n            val movies by viewModel.moviesFlow.collectAsStateWithLifecycle(\n                initialValue = emptyList()\n            )\n\n            val selectedIds by viewModel\n                .selectedIdsFlow\n                .collectAsStateWithLifecycle(initialValue = emptySet())\n\n            MovieListUi(\n                movies = movies,\n                modifier = modifier,\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedMovies = viewModel::deleteSelectedMovies,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch (Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                },\n                onMovieClicked = { movie -&gt;\n                    viewModel.pushScreen(MovieDisplay(movie.id))\n                },\n            )\n        }\n        ActorList -&gt; {\n            val actors by viewModel.actorsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            ActorListUi(\n                actors = actors,\n                onActorClicked = { actor -&gt;\n                    viewModel.pushScreen(ActorDisplay(actor.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedActors = viewModel::deleteSelectedActors,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n        RatingList -&gt; {\n            val ratings by viewModel.ratingsFlow.collectAsStateWithLifecycle(initialValue = emptyList())\n            val selectedIds by viewModel.selectedIdsFlow.collectAsStateWithLifecycle(initialValue = emptySet())\n            RatingListUi(\n                ratings = ratings,\n                onRatingClicked = { rating -&gt;\n                    viewModel.pushScreen(RatingDisplay(rating.id))\n                },\n                selectedIds = selectedIds,\n                onClearSelections = viewModel::clearSelectedIds,\n                onSelectionToggle = viewModel::toggleSelection,\n                onDeleteSelectedRatings = viewModel::deleteSelectedRatings,\n                currentScreen = screen,\n                onSelectListScreen = viewModel::setScreen,\n                onResetDatabase = {\n                    scope.launch(Dispatchers.IO) {\n                        viewModel.resetDatabase()\n                    }\n                }\n            )\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n    &lt;string name=\"loading\"&gt;\u2026Loading\u2026&lt;/string&gt;\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n    &lt;string name=\"cast_entry\"&gt;%1$s: %2$s&lt;/string&gt;\n    &lt;string name=\"clear_selections\"&gt;Clear Selections&lt;/string&gt;\n    &lt;string name=\"delete_selected_items\"&gt;Delete selected items&lt;/string&gt;\n    &lt;string name=\"ratings\"&gt;Ratings&lt;/string&gt;\n    &lt;string name=\"rating\"&gt;Rating&lt;/string&gt;\n    &lt;string name=\"actors\"&gt;Actors&lt;/string&gt;\n    &lt;string name=\"actor\"&gt;Actor&lt;/string&gt;\n    &lt;string name=\"name\"&gt;Name&lt;/string&gt;\n    &lt;string name=\"movies_rated\"&gt;Movies rated %1$s&lt;/string&gt;\n    &lt;string name=\"movies_starring\"&gt;Movies starring %1$s&lt;/string&gt;\n    &lt;string name=\"edit\"&gt;Edit&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: data/src/main/java/com/androidbyexample/compose/movies/data/MovieDao.kt <pre>package com.androidbyexample.compose.movies.data\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport androidx.room.Transaction\nimport androidx.room.Upsert\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\nabstract class MovieDao {\n    @Query(\"SELECT * FROM RatingEntity\")\n    abstract fun getRatingsFlow(): Flow&lt;List&lt;RatingEntity&gt;&gt;\n    @Query(\"SELECT * FROM MovieEntity\")\n    abstract fun getMoviesFlow(): Flow&lt;List&lt;MovieEntity&gt;&gt;\n    @Query(\"SELECT * FROM ActorEntity\")\n    abstract fun getActorsFlow(): Flow&lt;List&lt;ActorEntity&gt;&gt;\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract suspend fun getRatingWithMovies(id: String): RatingWithMovies\n\n    @Transaction\n    @Query(\"SELECT * FROM ActorEntity WHERE id = :id\")\n    abstract suspend fun getActorWithFilmography(id: String): ActorWithFilmography\n    @Transaction\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovieWithCast(id: String): MovieWithCast\n\n    @Transaction\n    @Query(\"SELECT * FROM RatingEntity WHERE id = :id\")\n    abstract fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMovies&gt;\n\n    @Query(\"SELECT * FROM MovieEntity WHERE id = :id\")\n    abstract suspend fun getMovie(id: String): MovieEntity\n\n    @Insert\n    abstract suspend fun insert(vararg ratings: RatingEntity)\n    @Insert\n    abstract suspend fun insert(vararg movies: MovieEntity)\n    @Insert\n    abstract suspend fun insert(vararg actors: ActorEntity)\n    @Insert\n    abstract suspend fun insert(vararg roles: RoleEntity)\n\n    @Upsert\n    abstract suspend fun upsert(vararg ratings: RatingEntity)\n    @Upsert\n    abstract suspend fun upsert(vararg movies: MovieEntity)\n    @Upsert\n    abstract suspend fun upsert(vararg actors: ActorEntity)\n    @Upsert\n    abstract suspend fun upsert(vararg roles: RoleEntity)\n\n\n    @Query(\"DELETE FROM MovieEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM ActorEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    @Query(\"DELETE FROM RatingEntity WHERE id IN (:ids)\")\n    abstract suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    @Query(\"DELETE FROM MovieEntity\")\n    abstract suspend fun clearMovies()\n    @Query(\"DELETE FROM ActorEntity\")\n    abstract suspend fun clearActors()\n    @Query(\"DELETE FROM RatingEntity\")\n    abstract suspend fun clearRatings()\n    @Query(\"DELETE FROM RoleEntity\")\n    abstract suspend fun clearRoles()\n    @Transaction\n    open suspend fun resetDatabase() {\n        clearMovies()\n        clearActors()\n        clearRoles()\n        clearRatings()\n        insert(\n            RatingEntity(id = \"r0\", name = \"Not Rated\", description = \"Not yet rated\"),\n            RatingEntity(id = \"r1\", name = \"G\", description = \"General Audiences\"),\n            RatingEntity(id = \"r2\", name = \"PG\", description = \"Parental Guidance Suggested\"),\n            RatingEntity(id = \"r3\", name = \"PG-13\", description = \"Unsuitable for those under 13\"),\n            RatingEntity(id = \"r4\", name = \"R\", description = \"Restricted - 17 and older\"),\n        )\n        insert(\n            MovieEntity(\"m1\", \"The Transporter\", \"Jason Statham kicks a guy in the face\", \"r3\"),\n            MovieEntity(\"m2\", \"Transporter 2\", \"Jason Statham kicks a bunch of guys in the face\", \"r4\"),\n            MovieEntity(\"m3\", \"Hobbs and Shaw\", \"Cars, Explosions and Stuff\", \"r3\"),\n            MovieEntity(\"m4\", \"Jumanji - Welcome to the Jungle\", \"The Rock smolders\", \"r3\"),\n        )\n        insert(\n            ActorEntity(\"a1\", \"Jason Statham\"),\n            ActorEntity(\"a2\", \"The Rock\"),\n            ActorEntity(\"a3\", \"Shu Qi\"),\n            ActorEntity(\"a4\", \"Amber Valletta\"),\n            ActorEntity(\"a5\", \"Kevin Hart\"),\n        )\n        insert(\n            RoleEntity(\"m1\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m1\", \"a3\", \"Lai\", 2),\n            RoleEntity(\"m2\", \"a1\", \"Frank Martin\", 1),\n            RoleEntity(\"m2\", \"a4\", \"Audrey Billings\", 2),\n            RoleEntity(\"m3\", \"a2\", \"Hobbs\", 1),\n            RoleEntity(\"m3\", \"a1\", \"Shaw\", 2),\n            RoleEntity(\"m4\", \"a2\", \"Spencer\", 1),\n            RoleEntity(\"m4\", \"a5\", \"Fridge\", 2),\n        )\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieDatabaseRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport android.content.Context\nimport com.androidbyexample.compose.movies.data.MovieDao\nimport com.androidbyexample.compose.movies.data.createDao\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\nclass MovieDatabaseRepository(\n    private val dao: MovieDao\n): MovieRepository {\n    override val ratingsFlow =\n        dao.getRatingsFlow()\n            .map { ratings -&gt;// for each List&lt;RatingEntity&gt; that's emitted\n                // create a list of RatingDto\n                ratings.map { rating -&gt; rating.toDto() } // map each entity to Dto\n            }\n    override val moviesFlow =\n        dao.getMoviesFlow()\n            .map { movies -&gt;\n                movies.map { it.toDto() }\n            }\n    override val actorsFlow =\n        dao.getActorsFlow()\n            .map { actors -&gt;\n                actors.map { it.toDto() }\n            }\n\n    override fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt; =\n        dao.getRatingWithMoviesFlow(id)\n            .map { it.toDto() }\n\n    override suspend fun getMovie(id: String): MovieDto =\n        dao.getMovie(id).toDto()\n\n    override suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto =\n        dao.getRatingWithMovies(id).toDto()\n    override suspend fun getMovieWithCast(id: String): MovieWithCastDto =\n        dao.getMovieWithCast(id).toDto()\n    override suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto =\n        dao.getActorWithFilmography(id).toDto()\n    override suspend fun insert(movie: MovieDto) = dao.insert(movie.toEntity())\n    override suspend fun insert(actor: ActorDto) = dao.insert(actor.toEntity())\n    override suspend fun insert(rating: RatingDto) = dao.insert(rating.toEntity())\n\n    override suspend fun upsert(movie: MovieDto) = dao.upsert(movie.toEntity())\n    override suspend fun upsert(actor: ActorDto) = dao.upsert(actor.toEntity())\n    override suspend fun upsert(rating: RatingDto) = dao.upsert(rating.toEntity())\n\n    override suspend fun deleteMoviesById(ids: Set&lt;String&gt;) = dao.deleteMoviesById(ids)\n    override suspend fun deleteActorsById(ids: Set&lt;String&gt;) = dao.deleteActorsById(ids)\n    override suspend fun deleteRatingsById(ids: Set&lt;String&gt;) = dao.deleteRatingsById(ids)\n\n    override suspend fun resetDatabase() = dao.resetDatabase()\n\n    companion object {\n        fun create(context: Context) =\n            MovieDatabaseRepository(createDao(context))\n    }\n}\n</pre> CHANGED: repository/src/main/java/com/androidbyexample/compose/movies/repository/MovieRepository.kt <pre>package com.androidbyexample.compose.movies.repository\n\nimport kotlinx.coroutines.flow.Flow\n\ninterface MovieRepository {\n    val ratingsFlow: Flow&lt;List&lt;RatingDto&gt;&gt;\n    val moviesFlow: Flow&lt;List&lt;MovieDto&gt;&gt;\n    val actorsFlow: Flow&lt;List&lt;ActorDto&gt;&gt;\n\n    fun getRatingWithMoviesFlow(id: String): Flow&lt;RatingWithMoviesDto&gt;\n\n    suspend fun getMovie(id: String): MovieDto\n\n    suspend fun getRatingWithMovies(id: String): RatingWithMoviesDto\n    suspend fun getMovieWithCast(id: String): MovieWithCastDto\n    suspend fun getActorWithFilmography(id: String): ActorWithFilmographyDto\n    suspend fun insert(movie: MovieDto)\n    suspend fun insert(actor: ActorDto)\n    suspend fun insert(rating: RatingDto)\n\n    suspend fun upsert(movie: MovieDto)\n    suspend fun upsert(actor: ActorDto)\n    suspend fun upsert(rating: RatingDto)\n\n    suspend fun deleteMoviesById(ids: Set&lt;String&gt;)\n    suspend fun deleteActorsById(ids: Set&lt;String&gt;)\n    suspend fun deleteRatingsById(ids: Set&lt;String&gt;)\n\n    suspend fun resetDatabase()\n}\n</pre>"},{"location":"modules/movie-ui-3/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/movie-ui-3. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>movie-ui-3</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/movie-ui-3\n</code></pre>"},{"location":"modules/movie-widget/index.html","title":"Overview","text":"<p>We can create little widgets in our application that give the user a mini user interface on their homescreen!</p> <p>In this module, we'll create a simple widget to display movie names, and when they're clicked, send the user to the display page for that movie.</p>"},{"location":"modules/movie-widget/STEP_020_REPO.html","title":"Widget Declaration","text":"<p>Widgets allow you to embed small parts of your application into a user's home screen. They can display data from your application, allow the user to interact with it, and act as customized launch points for your application.</p> <p>Glance is a Jetpack Compose framework for creating and managing widgets, built on top of the existing AppWidget framework. It looks and feels quite a bit like the Compose UIs you've built before, but there's a really important difference: the UI is remote.</p> <p>Your widget runs in a separate process from your application, inside the user's selected Home application. You can't directly communicate with it, nor can you add your code to that Home application. So how does it work?</p> <p>In the AppWidget framework, you'd create Remote Views. They defined a limited subset of available UI views, and acted as a proxy for your user interface. The remote views are defined in a Broadcast Receiver that you define, that accepts system broadcasts describing the current state of the widget and whether it wants an update.</p> <p>Broadcast Receivers are top-level Android Components, like Activities, and are declared in the <code>AndroidManifest.xml</code> file. When a broadcast <code>Intent</code> is sent to them, the system creates an instance of them, passes the <code>Intent</code> to its <code>onReceive()</code> function to perform its action, then the receiver's work is done.</p> <p>You create a subclass of <code>AppWidgetReceiver</code> (or for Compose, <code>GlanceAppWidgetReceiver</code>) to supply the remote views for the widget. When the user adds or removes a widget for their Home app, or after an amount of time that the widget declaration states it should be updated, a broadcast <code>Intent</code> is sent to your widget receiver. You create or update the remote views which are sent back to the widget framework to render for the user (or remove form the Home app).</p> <p>This is easier to see as we create a new widget. We'll define a widget that displays our movie list and allows the user to click on one, taking them to that movie in the application.</p>"},{"location":"modules/movie-widget/STEP_020_REPO.html#setting-up-the-widget","title":"Setting up the widget","text":"<p>First we need to add the glance dependencies in the version catalog</p> show in full file  gradle/libs.versions.toml <pre>[versions]\n// ...\nlifecycle-compose = \"2.8.7\"\nicons-extended = \"1.7.6\"\nglance=\"1.1.1\"\n\n[libraries]\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material3 = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended-android\", version.ref = \"icons-extended\"}\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\n// ...\n[plugins]\n// ...</pre> <p>and as dependencies in the app's build script</p> show in full file  app/build.gradle.kts <pre>// ...\ndependencies {\n    implementation(project(\":repository\"))\n\n    implementation(libs.glance.appwidget)\n    implementation(libs.glance.material3)\n//    implementation(libs.icons.extended)\n    implementation(libs.lifecycle.compose)\n    // ...\n}</pre> <p>We'll put our code in a subpackage named <code>com.androidbyexample.movie.glance</code>. To do this,  right-click on the <code>com.androidbyexample.movie</code> package and choose New &gt; package</p> <p></p> <p>then add \".glance\" at the end and press Enter:</p> <p></p> <p>Note</p> <p>A \"subpackage\" in Kotlin (or Java) is one where another package has the same prefix. For example, <code>a.b.c</code> is a subpackage of <code>a.b</code>.</p> <p>Aside from the name, there is no relation between these packages. If you <code>import a.b.*</code>, it doesn't make types from <code>a.b.c</code> available.</p> <p>Warning</p> <p>Never use import-on-demand (imports like <code>a.b.*</code>). See Import on Demand is EVIL! for details.</p> <p>Info</p> <p>Nested boxes are cool. So are Fezzes and Bowties.</p> <p></p> <p>(I'm in a mood today...)</p> <p>Now we create some new code in that package.</p> <p>The <code>MovieAppWidget</code> class defines your user interface for the widget. We'll just create a <code>Text</code> for it.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>// ...\nimport androidx.glance.text.Text\n\nclass MovieAppWidget : GlanceAppWidget() {\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\n        provideContent {\n            Text(text = \"Widget!\")\n        }\n    }\n}</pre> <p>Caution</p> <p>The composable functions for Glance, like <code>Text</code> have the same names as the ones we've been using, but are in a different package. In this case, the Glance <code>Text</code> is <code>androidx.glance.text.Text</code>. Be careful when adding them; be sure to choose the one from the Glance package.</p> <p>Now the <code>MovieAppWidgetReceiver</code>. This is the broadcast receiver that receives the system broadcasts about the widget to add/remove/update it. All we need to do is define its <code>glanceAppWidget</code> property.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MovieAppWidgetReceiver.kt <pre>// ...\nimport androidx.glance.appwidget.GlanceAppWidgetReceiver\n\nclass MovieAppWidgetReceiver: GlanceAppWidgetReceiver() {\n    override val glanceAppWidget: GlanceAppWidget = MovieAppWidget()\n}</pre> <p>Note</p> <p>We won't be doing anything fancy with widgets (and there's much more you can do). If you want to do more, see Jetpack Glance and App widgets overview.</p> <p>We need to describe to Android how our widget should behave when placed into a Home app, including sizing information and how often to explicitly update it. This information is specified in <code>app/src/main/res/xml/movie_app_widget_info.xml</code>.</p> show in full file  app/src/main/res/xml/movies_app_widget_info.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;appwidget-provider\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:initialLayout=\"@layout/glance_default_loading_layout\" /&gt;</pre> <p>There are  many more options you can specify in the widget info file. </p> <p>We attach the widget info when registering our receiver in  <code>app/src/main/AndroidManifest.xml</code>. The manifest is our way of telling Android which top-level components we've defined in our application. So far, we've only had a single Activity in there and haven't really talked about it.</p> show in full file  app/src/main/AndroidManifest.xml <pre>// ...\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n    // ...\n    &lt;application\n        // ...\n        tools:targetApi=\"31\"&gt;\n        // ...\n        &lt;/activity&gt;\n\n        &lt;receiver android:name=\".glance.MovieAppWidgetReceiver\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /&gt;\n            &lt;/intent-filter&gt;\n            &lt;meta-data\n                android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/movies_app_widget_info\" /&gt;\n        &lt;/receiver&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;</pre> <p>When an app is installed, Android looks at the manifest to determine what's available. The <code>&lt;intent-filter&gt;</code>s specify which <code>Intent</code>s this application can handle, and which components to send those intents to. Any application can send intents to start activities or services, and send messages to broadcast receivers. (There are some limitations but we won't go into that detail here).</p>"},{"location":"modules/movie-widget/STEP_020_REPO.html#a-little-more-on-intents-and-filters","title":"A little more on intents and filters","text":"<p>Let's take a quick diversion to explain in a bit more detail how <code>Intent</code>s and <code>intent-filter</code>s work.</p> <p>When the system sees</p> <pre><code>&lt;intent-filter&gt;\n    &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n    &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n&lt;/intent-filter&gt;\n</code></pre> <p>The <code>MAIN/LAUNCHER</code> combination of <code>action</code> and <code>category</code> is special - it specifies an Activity as an entry point to the application that can be listed in the Home app to start the application.</p> <p>If we had something like</p> <pre><code>&lt;intent-filter&gt;\n    &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n    &lt;data android:scheme=\"https\" /&gt;\n    &lt;data android:scheme=\"http\" /&gt;\n    &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n    &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n&lt;/intent-filter&gt;\n</code></pre> <p>You'd be telling android that you can handle requests to view a URI that starts with \"http\" or \"https\" - something like this might be used if you were creating a web browser application. If another application sent an implicit intent that said \"hey Android, I want to view https://androidbyexample.com\", your application would be a candidate to handle it.</p> <p>If only one app is installed that has an intent filter that matches, that application is used to perform the request. If more than one app is installed that can handle it, the user is asked which to use.</p> <p>An application can send an explicit intent, which indicates which application and activity/service should handle it. We'll see this later when we talk about services.</p>"},{"location":"modules/movie-widget/STEP_020_REPO.html#using-the-widget","title":"Using the Widget","text":"<p>To use the widget we need to install the application. Note that we don't need to actually run the application from Android Studio, so if you'd prefer, you can edit the application launcher setting by clicking the \"...\" next to the app launcher on the Android Studio toolbar and choosing \"Edit\":</p> <p></p> <p>And choose \"Nothing\" in the Launch dropdown:</p> <p></p> <p>You don't need to do this, but if you don't, you'll need to return to the home screen when the application opens so you can add the widget.</p> <p>To set up the widget:</p> <p></p> <ol> <li>Run the application to install it.</li> <li>If you didn't change the launcher to not launch the app, go to the home screen. You can do    this by clicking the \"O\" icon on the emulator toolbar, or swiping up from the bottom of the    emulator or device and quickly releasing. The gesture can be tricky to use on the emulator, so    I recommend the toolbar.</li> <li>Long press on an empty spot on the home screen. Note that this might be different based on    the Home app that you're using.</li> <li>Choose Widgets</li> <li>Scroll down to the MovieWidget app</li> <li>Long press on the widget to add to the home screen (some apps define multiple widgets)</li> <li>Drag the widget to the home screen position you'd like and release</li> <li>To remove, long press on the widget and drag to \"Remove\". Note that this might be different    based on the Home app that you're using. </li> </ol> All code changes CHANGED: app/build.gradle.kts <pre>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n}\n\nandroid {\n    namespace = \"com.androidbyexample.compose.movies\"\n    compileSdk = libs.versions.compileSdk.get().toInt()\n\n    defaultConfig {\n        applicationId = \"com.androidbyexample.compose.movies\"\n        minSdk = libs.versions.minSdk.get().toInt()\n        targetSdk = libs.versions.targetSdk.get().toInt()\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n        targetCompatibility = JavaVersion.valueOf(libs.versions.javaVersion.get())\n    }\n    kotlinOptions {\n        jvmTarget = libs.versions.jvmTarget.get()\n    }\n    buildFeatures {\n        compose = true\n    }\n}\n\ndependencies {\n    implementation(project(\":repository\"))\n\n    implementation(libs.glance.appwidget)\n    implementation(libs.glance.material3)\n//    implementation(libs.icons.extended)\n    implementation(libs.lifecycle.compose)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n}\n</pre> CHANGED: app/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Movies\"\n        tools:targetApi=\"31\"&gt;\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:label=\"@string/app_name\"\n            android:theme=\"@style/Theme.Movies\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;receiver android:name=\".glance.MovieAppWidgetReceiver\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /&gt;\n            &lt;/intent-filter&gt;\n            &lt;meta-data\n                android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/movies_app_widget_info\" /&gt;\n        &lt;/receiver&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/glance/MovieAppWidgetReceiver.kt <pre>package com.androidbyexample.compose.movies.glance\n\nimport androidx.glance.appwidget.GlanceAppWidget\nimport androidx.glance.appwidget.GlanceAppWidgetReceiver\n\nclass MovieAppWidgetReceiver: GlanceAppWidgetReceiver() {\n    override val glanceAppWidget: GlanceAppWidget = MovieAppWidget()\n}\n</pre> ADDED: app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>package com.androidbyexample.compose.movies.glance\n\nimport android.content.Context\nimport androidx.glance.GlanceId\nimport androidx.glance.appwidget.GlanceAppWidget\nimport androidx.glance.appwidget.provideContent\nimport androidx.glance.text.Text\n\nclass MovieAppWidget : GlanceAppWidget() {\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\n        provideContent {\n            Text(text = \"Widget!\")\n        }\n    }\n}\n</pre> ADDED: app/src/main/res/xml/movies_app_widget_info.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;appwidget-provider\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:initialLayout=\"@layout/glance_default_loading_layout\" /&gt;\n</pre> CHANGED: gradle/libs.versions.toml <pre>[versions]\nagp = \"8.7.3\"\nkotlin = \"2.0.21\"\ncoreKtx = \"1.15.0\"\njunit = \"4.13.2\"\njunitVersion = \"1.2.1\"\nespressoCore = \"3.6.1\"\nlifecycleRuntimeKtx = \"2.8.7\"\nactivityCompose = \"1.9.3\"\ncomposeBom = \"2024.12.01\"\nappcompat = \"1.7.0\"\nmaterial = \"1.12.0\"\nroom = \"2.6.1\"\nksp = \"2.0.21-1.0.28\"\ncompileSdk = \"35\"\ntargetSdk = \"35\"\nminSdk = \"24\"\njvmTarget = \"11\"\njavaVersion = \"VERSION_11\"\nlifecycle-compose = \"2.8.7\"\nicons-extended = \"1.7.6\"\nglance=\"1.1.1\"\n\n[libraries]\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material3 = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\nicons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended-android\", version.ref = \"icons-extended\"}\nlifecycle-compose = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-compose\", version.ref = \"lifecycle-compose\" }\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\nandroidx-junit = { group = \"androidx.test.ext\", name = \"junit\", version.ref = \"junitVersion\" }\nandroidx-espresso-core = { group = \"androidx.test.espresso\", name = \"espresso-core\", version.ref = \"espressoCore\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nroom-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nroom-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nroom-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\nandroid-library = { id = \"com.android.library\", version.ref = \"agp\" }\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\n</pre>"},{"location":"modules/movie-widget/STEP_030_REPO.html","title":"Widget UI and Data","text":"<p>Let's make this widget actually do something. We'll fetch the list of movies from the database and display it on the widget. When the user selects a movie, they'll be taken to its display page in the app.</p> <p>Before moving forward, let's update the widget metadata</p> show in full file  app/src/main/res/xml/movies_app_widget_info.xml <pre>// ...\n&lt;appwidget-provider\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n//  android:initialLayout=\"@layout/glance_default_loading_layout\" /&gt;\n    android:initialLayout=\"@layout/glance_default_loading_layout\"\n    android:description=\"@string/movie_list\"\n    android:minWidth=\"46dp\"\n    android:minHeight=\"46dp\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:targetCellWidth=\"2\"\n    android:targetCellHeight=\"2\"\n    android:widgetCategory=\"home_screen\" /&gt;</pre> <ul> <li><code>description</code> adds descriptive text when choosing the widget to place on a home screen.   This requires adding the text to strings.xml</li> <li><code>minWidth</code> and <code>minHeight</code> limits how small the user can size the widget</li> <li><code>resizeMode</code> specifies which directions the user can resize the widget</li> <li><code>targetCellWidth</code> and <code>targetCellHeight</code> gives sizing when initially placing the widget.   These are multiples of the cell size defined by the home application.</li> <li><code>widgetCategory</code> specifies if the widget can appear on the home or lock screen (called \"keyguard\"   here)</li> </ul> <p>Widgets run in a different process than our application. The <code>MovieAppWidget</code> runs in our application's process to create a set of Remote Views that are sent to the widget to be rendered. We need to set it up to fetch data when first creating the widget and when the widget is updated.</p> <p>By default, <code>GlanceAppWidget</code> is set up to read widget state from a preference store. This is a file that's private to your application, and is normally used to store application settings between runs. Here it's used for the application to write widget state updates. If you only have minor data to update, this is fine, but a movie list is typically too much data to store in a preference store (and the data would have to be read from the database, written to the file, then read back from the file to perform the widget update).</p> <p>Instead, we'll override the update data handling.</p> <p>All classes that extend <code>GlanceAppWidget</code> contain a <code>GlanceStateDefinition</code> instance that provides a <code>DataStore</code> that the widget can use to get its data. We'll use this data store to fetch the initial list of movies from the database. Glance gets the <code>data</code> property from the data store, a <code>Flow</code> of our movie list in this case.</p> <p>Whenever the widget is told to update (we'll see that later), Glance reads <code>data</code> again and updates state.</p> <p>Normally, if we use a <code>DataStore</code>, we read <code>data</code> once to get the <code>Flow</code> of updates, and then collect from that <code>Flow</code> to get changes. However, the <code>MovieAppWidget</code> wants an explicit update notification, telling it when to update its data. We'll ask for a new <code>Flow</code> each time from our repository to get the movie list.</p> <p>To do this, we need to create a state definition class. This is just a factory for our data store. We don't need to define the <code>getLocation</code> function; it's not used (and normally returns a <code>File</code> indicating where the data is stored)</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>// ...\nprivate val movieIdKey = ActionParameters.Key&lt;String&gt;(MOVIE_ID_EXTRA)\n\nclass MovieGlanceStateDefinition: GlanceStateDefinition&lt;List&lt;MovieDto&gt;&gt; {\n    override suspend fun getDataStore(\n        context: Context,\n        fileKey: String\n    ): DataStore&lt;List&lt;MovieDto&gt;&gt; = MovieDataStore(context)\n    override fun getLocation(context: Context, fileKey: String): File {\n        throw RuntimeException(\"Should not be used\")\n    }\n}\n\nclass MovieDataStore(\n    // ...</pre> <p>Create a data store that returns the actual data. Its <code>data</code> property returns a new <code>Flow&lt;List&lt;MovieDto&gt;&gt;</code> each time it's read.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>// ...\n}\n\nclass MovieDataStore(\n    context: Context,\n): DataStore&lt;List&lt;MovieDto&gt;&gt; {\n    val repository = MovieDatabaseRepository.create(context)\n    override val data: Flow&lt;List&lt;MovieDto&gt;&gt;\n        get() = repository.moviesFlow\n    override suspend fun updateData(transform: suspend (t: List&lt;MovieDto&gt;) -&gt; List&lt;MovieDto&gt;): List&lt;MovieDto&gt; {\n        throw RuntimeException(\"Should not be used\")\n    }\n}\nclass MovieAppWidget : GlanceAppWidget() {\n    override val stateDefinition = MovieGlanceStateDefinition()\n    // ...</pre> <p>Add a state definition property in our <code>MovieAppWidget</code> so it knows how to create its data store (and then get its data). Because the widget doesn't update the data, we don't implement the <code>updateData</code> function.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>// ...\n}\nclass MovieAppWidget : GlanceAppWidget() {\n    override val stateDefinition = MovieGlanceStateDefinition()\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\n        provideContent {\n            // ...\n}</pre> <p>Get the current state so we can display it.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>// ...\nclass MovieAppWidget : GlanceAppWidget() {\n    // ...\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\n        provideContent {\n//          Text(text = \"Widget!\")\n            val movies = currentState&lt;List&lt;MovieDto&gt;&gt;()\n\n            GlanceTheme {\n                // ...\n        }\n    }\n}</pre> <p>We need to explicitly request widget updates when the UI changes data. This is done via</p> <pre><code>MovieAppWidget().updateAll(context)\n</code></pre> <p>Note</p> <p>This will update all instances of the movie widget that the user has placed on their home screens. It's possible to update just a specific instance if you'd like, but we won't go into that detail here. (Think as an example, different instances of a picture-frame widget that host different images - you click on one to take you to the app to select an image, and it updates only that instance of the widget)</p> <p>Ideally, we want to make this update call in as few places as possible, while ensuring we cover all cases. In our application, this is simple - we can  watch the movie flow for emissions and call update. For this purpose, we start a coroutine when the view model is initialized and collect the movie flow.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    // ...\n): AndroidViewModel(application), MovieRepository by repository {\n    // ...\n    private val ratingUpdateFlow = MutableStateFlow&lt;RatingDto?&gt;(null)\n    init {\n        viewModelScope.launch {\n            repository.moviesFlow.collectLatest {\n                MovieAppWidget().updateAll(getApplication())\n            }\n        }\n\n        viewModelScope.launch {\n            // ...\n    }\n    // ...\n}</pre> <p>The <code>updateAll()</code> call requires a context. We can access the application context (which lives across the lifetime of the application, vs an activity context that only lives while the activity is running) by changing our view model to subclass <code>AndroidViewModel</code> and passing in an <code>Application</code>. <code>AndroidViewModel</code> contains a <code>getApplication()</code> function that allows access when we call <code>updateAll()</code>.</p> <p>This requires that we pass the application when creating our view model in its factory.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    application: Application,\n    private val repository: MovieRepository,\n//): ViewModel(), MovieRepository by repository {\n): AndroidViewModel(application), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n    // ...\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                // ...\n            ): T {\n                // ...\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    application,\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}</pre> <p>The UI for our <code>MovieAppWidget</code> uses a <code>LazyColumn</code> to display our list of movies.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>// ...\nimport java.io.File\n\nprivate val movieIdKey = ActionParameters.Key&lt;String&gt;(MOVIE_ID_EXTRA)\n\nclass MovieGlanceStateDefinition: GlanceStateDefinition&lt;List&lt;MovieDto&gt;&gt; {\n    // ...\nclass MovieAppWidget : GlanceAppWidget() {\n    // ...\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\n        provideContent {\n            // ...\n            val movies = currentState&lt;List&lt;MovieDto&gt;&gt;()\n\n            GlanceTheme {\n                LazyColumn(\n                    modifier = GlanceModifier\n                        .fillMaxSize()\n                        .padding(4.dp)\n                        .appWidgetBackground()\n                        .background(GlanceTheme.colors.background),\n                ) {\n                    items(items = movies) { movie -&gt;\n                        Text(\n                            text = movie.title,\n                            modifier = GlanceModifier\n                                .padding(4.dp)\n                                .fillMaxWidth()\n                                .clickable(\n                                    actionStartActivity&lt;MainActivity&gt;(\n                                        actionParametersOf(movieIdKey to movie.id)\n                                    )\n                                )\n                            ,\n                            style = TextStyle(\n                                fontWeight = FontWeight.Normal,\n                                fontSize = 18.sp,\n                            ),\n                        )\n                    }\n                }\n            }\n        }\n    }\n}</pre> <p>When a movie title is clicked, we start our <code>MainActivity</code> and pass the movie id as a parameter.</p> <p>Note that <code>actionStartActivity</code> creates a lambda for us, so we pass it in parentheses to <code>clickable</code> rather than put it in a lambda. If we had instead written</p> <pre><code>.clickable {\n    actionStartActivity&lt;MainActivity&gt;(\n        actionParametersOf(movieIdKey to movie.id)\n    )\n}\n</code></pre> <p>we'd be telling it to call <code>actionStartActivity</code> to create the lambda when the button is clicked. We need to create that lambda and use it as the function called when the button is clicked.</p> <p>The created lambda creates an explicit <code>Intent</code> targeting our activity, and uses the  <code>actionParametersOf</code> function to add key and value pairs to the <code>extras</code> map of that intent.</p> <p>The name specified in the <code>movieIdKey</code> must match the name we use to retrieve the data from the intent in <code>MainActivity</code>. </p> <p>We define the key name as a constant in <code>MainActivity</code> to ensure the name is consistent.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>// ...\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nconst val MOVIE_ID_EXTRA = \"movieId\"\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt; { MovieViewModel.Factory }\n    // ...</pre> <p>When the user selects a movie from the list in the widget, we need to show the movie display screen. But what happens when the user presses back? It would be nice if we could go to the movie list screen so it feels the same as when the user runs the app directly.</p> <p>To do this, we need a way to set the entire stack.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>// ...\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    // ...\n): AndroidViewModel(application), MovieRepository by repository {\n    // ...\n    }\n\n    fun setScreens(vararg screens: Screen) {\n        screenStack = screens.toList()\n    }\n\n    fun update(movie: MovieDto) {\n        // ...\n}</pre> <p>The fun part is now dealing with that intent coming into the activity. The activity may or may not already be running. If you were running the application and went to the home screen, the system may keep the activity instance around until it needs to reclaim its memory. However, it could kill it at any time when it's not the current foreground application. This leads to two ways we must deal with the intent:</p> <ul> <li>if the activity is not running, a new instance will be created and the intent passed to   <code>onCreate</code></li> <li>if the activity is running, the intent will be passed to the <code>onNewIntent()</code> function of the   existing activity instance</li> </ul> <p>We need to handle the intent in both places, so we create a helper function that tries to pull the movie id out of an intent. If the intent is not present, we reset the stack to be just <code>MovieList</code>. If it is present, we set the stack to be <code>MovieList</code> followed by <code>MovieDisplay</code> for that movie. This presents the movie to the user and allows them to press back to get to the movie list.</p> <p>We call <code>handleMovieId()</code> from <code>onCreate</code> and <code>onNewIntent</code>.</p> show in full file  app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>// ...\nclass MainActivity : ComponentActivity() {\n    // ...\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        intent.handleMovieId()\n\n        enableEdgeToEdge()\n        // ...\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        intent.handleMovieId()\n    }\n\n    private fun Intent.handleMovieId() {\n        val movieId = extras?.getString(MOVIE_ID_EXTRA)\n        if (movieId != null) {\n            viewModel.setScreens(MovieList, MovieDisplay(movieId))\n        }\n    }\n}</pre> <p>Note that <code>onNewIntent</code> is passed an <code>Intent</code> as a parameter, while <code>onCreate</code> uses the property <code>intent</code> defined by the activity as the <code>Intent</code> that launched it.</p> <p>If we run the application now, we'll get some interesting results if we</p> <ol> <li>Click on a movie in the widget (and see the movie displayed)</li> <li>Go back to home</li> <li>Click on a different movie in the widget (and see it displayed)</li> <li>Press back repeatedly</li> </ol> <p></p> <p>The problem is that each time we start the activity from the widget, a new instance is pushed on the stack for the application process. We now have a stack of activities, managed by the system, each of which contains a stack of screens. Originally, Android applications used an <code>Actitity</code> for each screen, calling <code>startActvitity</code> to push new instances on the system-managed stacks. Over time we evolved to using a single <code>Activity</code> approach.</p> <p>To fix this, we set the launch mode for our <code>MainActivity</code> to <code>singleInstance</code>, which ensures we only ever have one instance of the activity.</p> show in full file  app/src/main/AndroidManifest.xml <pre>// ...\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n    // ...\n    &lt;application\n        // ...\n        tools:targetApi=\"31\"&gt;\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n//          android:label=\"@string/app_name\"\n            android:launchMode=\"singleInstance\"\n            android:theme=\"@style/Theme.Movies\"&gt;\n            &lt;intent-filter&gt;\n                // ...\n        &lt;/activity&gt;\n        // ...\n    &lt;/application&gt;\n// ...\n&lt;/manifest&gt;</pre> All code changes CHANGED: app/src/main/AndroidManifest.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;application\n        android:allowBackup=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.Movies\"\n        tools:targetApi=\"31\"&gt;\n        &lt;activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n//          android:label=\"@string/app_name\"\n            android:launchMode=\"singleInstance\"\n            android:theme=\"@style/Theme.Movies\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n\n        &lt;receiver android:name=\".glance.MovieAppWidgetReceiver\"\n            android:exported=\"true\"&gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /&gt;\n            &lt;/intent-filter&gt;\n            &lt;meta-data\n                android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/movies_app_widget_info\" /&gt;\n        &lt;/receiver&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MainActivity.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.content.Intent\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.viewModels\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.ui.Modifier\nimport com.androidbyexample.compose.movies.screens.MovieDisplay\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Ui\nimport com.androidbyexample.compose.movies.ui.theme.MoviesTheme\n\nconst val MOVIE_ID_EXTRA = \"movieId\"\nclass MainActivity : ComponentActivity() {\n    private val viewModel by viewModels&lt;MovieViewModel&gt; { MovieViewModel.Factory }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        intent.handleMovieId()\n\n        enableEdgeToEdge()\n        setContent {\n            MoviesTheme {\n                Ui(\n                    viewModel = viewModel,\n                    modifier = Modifier.fillMaxSize()\n                ) {\n                    finish()\n                }\n            }\n        }\n    }\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        intent.handleMovieId()\n    }\n\n    private fun Intent.handleMovieId() {\n        val movieId = extras?.getString(MOVIE_ID_EXTRA)\n        if (movieId != null) {\n            viewModel.setScreens(MovieList, MovieDisplay(movieId))\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/MovieViewModel.kt <pre>package com.androidbyexample.compose.movies\n\nimport android.app.Application\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.setValue\nimport androidx.glance.appwidget.updateAll\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport androidx.lifecycle.viewmodel.CreationExtras\nimport com.androidbyexample.compose.movies.glance.MovieAppWidget\nimport com.androidbyexample.compose.movies.repository.ActorDto\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport com.androidbyexample.compose.movies.repository.MovieRepository\nimport com.androidbyexample.compose.movies.repository.RatingDto\nimport com.androidbyexample.compose.movies.screens.MovieList\nimport com.androidbyexample.compose.movies.screens.Screen\nimport kotlinx.coroutines.FlowPreview\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.flow.debounce\nimport kotlinx.coroutines.launch\n\n@OptIn(FlowPreview::class)\nclass MovieViewModel(\n    application: Application,\n    private val repository: MovieRepository,\n//): ViewModel(), MovieRepository by repository {\n): AndroidViewModel(application), MovieRepository by repository {\n    private val _selectedIdsFlow = MutableStateFlow&lt;Set&lt;String&gt;&gt;(emptySet())\n    val selectedIdsFlow: Flow&lt;Set&lt;String&gt;&gt; = _selectedIdsFlow.asStateFlow()\n\n    fun clearSelectedIds() {\n        _selectedIdsFlow.value = emptySet()\n    }\n    fun toggleSelection(id: String) {\n        if (id in _selectedIdsFlow.value) {\n            _selectedIdsFlow.value -= id\n        } else {\n            _selectedIdsFlow.value += id\n        }\n    }\n\n    private var screenStack = listOf&lt;Screen&gt;(MovieList)\n        set(value) {\n            field = value\n            clearSelectedIds()\n            currentScreen = value.lastOrNull()\n        }\n\n    // NOTE: We're keep this as a Compose State for comparison.\n    //       You can use Compose state to expose anything from the view model,\n    //       but our example will be using Flow from now on to demonstrate how\n    //       the view model can be used without Compose, perhaps for other\n    //       platforms such as iOS, desktop, web or command line\n    var currentScreen by mutableStateOf&lt;Screen?&gt;(MovieList)\n        private set\n\n    fun pushScreen(screen: Screen) {\n        screenStack = screenStack + screen\n    }\n    fun popScreen() {\n        screenStack = screenStack.dropLast(1)\n    }\n\n    fun setScreen(screen: Screen) {\n        screenStack = listOf(screen)\n    }\n\n    fun setScreens(vararg screens: Screen) {\n        screenStack = screens.toList()\n    }\n\n    fun update(movie: MovieDto) {\n        movieUpdateFlow.value = movie\n    }\n    fun update(actor: ActorDto) {\n        actorUpdateFlow.value = actor\n    }\n    fun update(rating: RatingDto) {\n        ratingUpdateFlow.value = rating\n    }\n    // using a debounced flow as a person-update queue\n    private val movieUpdateFlow = MutableStateFlow&lt;MovieDto?&gt;(null)\n    private val actorUpdateFlow = MutableStateFlow&lt;ActorDto?&gt;(null)\n    private val ratingUpdateFlow = MutableStateFlow&lt;RatingDto?&gt;(null)\n    init {\n        viewModelScope.launch {\n            repository.moviesFlow.collectLatest {\n                MovieAppWidget().updateAll(getApplication())\n            }\n        }\n\n        viewModelScope.launch {\n            movieUpdateFlow.debounce(500).collect { movie -&gt;\n                movie?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            actorUpdateFlow.debounce(500).collect { actor -&gt;\n                actor?.let { repository.upsert(it) }\n            }\n        }\n        viewModelScope.launch {\n            ratingUpdateFlow.debounce(500).collect { rating -&gt;\n                rating?.let { repository.upsert(it) }\n            }\n        }\n    }\n\n    fun deleteSelectedMovies() {\n        viewModelScope.launch {\n            deleteMoviesById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedActors() {\n        viewModelScope.launch {\n            deleteActorsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n    fun deleteSelectedRatings() {\n        viewModelScope.launch {\n            deleteRatingsById(_selectedIdsFlow.value)\n            _selectedIdsFlow.value = emptySet()\n        }\n    }\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = object: ViewModelProvider.Factory {\n            @Suppress(\"UNCHECKED_CAST\")\n            override fun &lt;T : ViewModel&gt; create(\n                modelClass: Class&lt;T&gt;,\n                extras: CreationExtras\n            ): T {\n                // Get the Application object from extras\n                val application = checkNotNull(extras[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY])\n                return MovieViewModel(\n                    application,\n                    MovieDatabaseRepository.create(application)\n                ) as T\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/java/com/androidbyexample/compose/movies/glance/MoviesAppWidget.kt <pre>package com.androidbyexample.compose.movies.glance\n\nimport android.content.Context\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport androidx.datastore.core.DataStore\nimport androidx.glance.GlanceId\nimport androidx.glance.GlanceModifier\nimport androidx.glance.GlanceTheme\nimport androidx.glance.action.ActionParameters\nimport androidx.glance.action.actionParametersOf\nimport androidx.glance.action.actionStartActivity\nimport androidx.glance.action.clickable\nimport androidx.glance.appwidget.GlanceAppWidget\nimport androidx.glance.appwidget.appWidgetBackground\nimport androidx.glance.appwidget.lazy.LazyColumn\nimport androidx.glance.appwidget.lazy.items\nimport androidx.glance.appwidget.provideContent\nimport androidx.glance.background\nimport androidx.glance.currentState\nimport androidx.glance.layout.fillMaxSize\nimport androidx.glance.layout.fillMaxWidth\nimport androidx.glance.layout.padding\nimport androidx.glance.state.GlanceStateDefinition\nimport androidx.glance.text.FontWeight\nimport androidx.glance.text.Text\nimport androidx.glance.text.TextStyle\nimport com.androidbyexample.compose.movies.MOVIE_ID_EXTRA\nimport com.androidbyexample.compose.movies.MainActivity\nimport com.androidbyexample.compose.movies.repository.MovieDatabaseRepository\nimport com.androidbyexample.compose.movies.repository.MovieDto\nimport kotlinx.coroutines.flow.Flow\nimport java.io.File\n\nprivate val movieIdKey = ActionParameters.Key&lt;String&gt;(MOVIE_ID_EXTRA)\n\nclass MovieGlanceStateDefinition: GlanceStateDefinition&lt;List&lt;MovieDto&gt;&gt; {\n    override suspend fun getDataStore(\n        context: Context,\n        fileKey: String\n    ): DataStore&lt;List&lt;MovieDto&gt;&gt; = MovieDataStore(context)\n    override fun getLocation(context: Context, fileKey: String): File {\n        throw RuntimeException(\"Should not be used\")\n    }\n}\n\nclass MovieDataStore(\n    context: Context,\n): DataStore&lt;List&lt;MovieDto&gt;&gt; {\n    val repository = MovieDatabaseRepository.create(context)\n    override val data: Flow&lt;List&lt;MovieDto&gt;&gt;\n        get() = repository.moviesFlow\n    override suspend fun updateData(transform: suspend (t: List&lt;MovieDto&gt;) -&gt; List&lt;MovieDto&gt;): List&lt;MovieDto&gt; {\n        throw RuntimeException(\"Should not be used\")\n    }\n}\nclass MovieAppWidget : GlanceAppWidget() {\n    override val stateDefinition = MovieGlanceStateDefinition()\n    override suspend fun provideGlance(context: Context, id: GlanceId) {\n        provideContent {\n//          Text(text = \"Widget!\")\n            val movies = currentState&lt;List&lt;MovieDto&gt;&gt;()\n\n            GlanceTheme {\n                LazyColumn(\n                    modifier = GlanceModifier\n                        .fillMaxSize()\n                        .padding(4.dp)\n                        .appWidgetBackground()\n                        .background(GlanceTheme.colors.background),\n                ) {\n                    items(items = movies) { movie -&gt;\n                        Text(\n                            text = movie.title,\n                            modifier = GlanceModifier\n                                .padding(4.dp)\n                                .fillMaxWidth()\n                                .clickable(\n                                    actionStartActivity&lt;MainActivity&gt;(\n                                        actionParametersOf(movieIdKey to movie.id)\n                                    )\n                                )\n                            ,\n                            style = TextStyle(\n                                fontWeight = FontWeight.Normal,\n                                fontSize = 18.sp,\n                            ),\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n</pre> CHANGED: app/src/main/res/values/strings.xml <pre>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"movies\"&gt;Movies&lt;/string&gt;\n    &lt;string name=\"title\"&gt;Title&lt;/string&gt;\n    &lt;string name=\"description\"&gt;Description&lt;/string&gt;\n    &lt;string name=\"movie\"&gt;Movie&lt;/string&gt;\n    &lt;string name=\"reset_database\"&gt;Reset Database&lt;/string&gt;\n    &lt;string name=\"loading\"&gt;\u2026Loading\u2026&lt;/string&gt;\n    &lt;string name=\"cast\"&gt;Cast&lt;/string&gt;\n    &lt;string name=\"cast_entry\"&gt;%1$s: %2$s&lt;/string&gt;\n    &lt;string name=\"clear_selections\"&gt;Clear Selections&lt;/string&gt;\n    &lt;string name=\"delete_selected_items\"&gt;Delete selected items&lt;/string&gt;\n    &lt;string name=\"ratings\"&gt;Ratings&lt;/string&gt;\n    &lt;string name=\"rating\"&gt;Rating&lt;/string&gt;\n    &lt;string name=\"actors\"&gt;Actors&lt;/string&gt;\n    &lt;string name=\"actor\"&gt;Actor&lt;/string&gt;\n    &lt;string name=\"name\"&gt;Name&lt;/string&gt;\n    &lt;string name=\"movies_rated\"&gt;Movies rated %1$s&lt;/string&gt;\n    &lt;string name=\"movies_starring\"&gt;Movies starring %1$s&lt;/string&gt;\n    &lt;string name=\"edit\"&gt;Edit&lt;/string&gt;\n    &lt;string name=\"movie_list\"&gt;Movie List&lt;/string&gt;\n&lt;/resources&gt;\n</pre> CHANGED: app/src/main/res/xml/movies_app_widget_info.xml <pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;appwidget-provider\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n//  android:initialLayout=\"@layout/glance_default_loading_layout\" /&gt;\n    android:initialLayout=\"@layout/glance_default_loading_layout\"\n    android:description=\"@string/movie_list\"\n    android:minWidth=\"46dp\"\n    android:minHeight=\"46dp\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:targetCellWidth=\"2\"\n    android:targetCellHeight=\"2\"\n    android:widgetCategory=\"home_screen\" /&gt;\n</pre>"},{"location":"modules/movie-widget/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/movie-widget. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>movie-widget</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/movie-widget\n</code></pre>"},{"location":"modules/room/index.html","title":"Entities","text":"<p>Each \"thing\" that you want to represent in your database is called an \"Entity\". Each entity has attributes, the data that describes it.</p> <p>In a Relational Database, each entity is represented by one row in a database table. The attributes are held in columns of the table.</p> <p>For these examples, we'll define \"Person\", \"Birth Certificate\", \"Organ\" and \"Address\" entities with the following attributes. </p> <p>In the \"Key\" column, you'll see three possible values:</p> <ul> <li>(blank) the attribute is not a key</li> <li>PK - represents a Primary Key, a value that must be unique in the table storing the entity. This is typically a unique identifier for an entity.</li> <li>FK - represents a Foreign Key, a primary key in some other table that we're associated with.</li> </ul> <p>In this example, I'm representing primary keys using Strings. I chose Strings here because mobile applications may synchronize their data between mobile devices and servers (or even other mobile devices). If entities can be created on mobile devices, possibly while not connected to a server, we can use a UUID (Universally Unique Identifier) to ensure we don't have collisions between ids created on different mobile devices at the same time. We'll see examples of this later.</p>"},{"location":"modules/room/index.html#person","title":"Person","text":"Attribute Type Key Comment id String PK Unique identifier name String name of the person ssn String social security number"},{"location":"modules/room/index.html#organ","title":"Organ","text":"Attribute Type Key Comment id String PK Unique identifier personId String FK id of owning person type String type of organ"},{"location":"modules/room/index.html#birth-certificate","title":"Birth Certificate","text":"Attribute Type Key Comment id String PK Unique identifier personId String FK id of owning person timeOfBirth long birth time in millis"},{"location":"modules/room/index.html#address","title":"Address","text":"Attribute Type Key Comment id String PK Unique identifier street String city String state String zip String"},{"location":"modules/room/STEP_10_FULL.html","title":"Relationships","text":"<p>Entities can be related to other entities in the same or other tables. These relationships ca be</p> <ul> <li>One-to-one: One instance of an entity relates to exactly one instance other entity</li> <li>One-to-many: One instance of entity relates to multiple instances of another entity</li> <li>Many-to-Many: Multiple instances of an entity can be related to multiple instances of another entity</li> </ul> <p>These relationships are easiest to understand through examples</p>"},{"location":"modules/room/STEP_10_FULL.html#one-to-one","title":"One to One","text":"<p>In our database, each Person can have exactly one Birth Certificate. Each Birth Certificate is owned by exactly one person.</p> <pre><code>erDiagram\n    PERSON ||--|| BIRTH-CERTIFICATE : born</code></pre> <p>This relationship is often used for extra/optional data. While we could add the birth certificate details directly to the person, putting it in a separate entity allows that data to be optional, or easily moved to a different entity.</p> <p>Using one-to-one relationships, we can gradually attach more data to an entity as our system grows with new function.</p> <p>There are several ways to represent this, but we typically define an attribute in one of the entities that holds the id of the other entity. This attribute is called a Foreign Key, as it's a key in another entity. Usually you'll put this attribute in the entity that feels like it's \"owned\" by the other entity (if the relationship feels like that). In this example, the Person owns the Birth Certificate, so we put a Foreign Key called personId in the Birth Certificate.</p>"},{"location":"modules/room/STEP_10_FULL.html#one-to-many","title":"One to Many","text":"<p>Often we'll need to have more than one entity attached/owned by an entity. In our example, a Person has organs, and those organs are only associated with that specific person. </p> <pre><code>erDiagram\n    PERSON ||--|{ ORGAN : has-organ</code></pre> <p>By making Organ a separate entity, we can attach any number of Organs to a Person by defining a personId foreign key in the Organ entity. We can even donate organs to another Person entity by just changing the value of that foreign key. The donate organ can only belong to one Person at a time.</p>"},{"location":"modules/room/STEP_10_FULL.html#many-to-many","title":"Many to Many","text":"<p>The real fun begins when entities can be shared. Think about an address as representing a home, office, hotel room, and so on. </p> <p>Each Person entity could be associated with multiple Address entities. Each Address entity could be associated with multiple Person entities.</p> <pre><code>erDiagram\n    PERSON }o--o{ ADDRESS : has-address</code></pre> <p>This relationship is trickier to represent - we cannot simply add a foreign key to either entity; we need to create a table to represent the linkage. </p> <p>We can create an Person-Address table to relate each person/address pair</p> Attribute Type Key Comment personId String FK The ID of the related person addressId String FK The ID of the related address <p>In this case, the combination of the personId and addressId create a unique key for a row in the Person-Address table.</p>"},{"location":"modules/room/STEP_10_FULL.html#associative-entities","title":"Associative Entities","text":"<p>Sometimes, a many-to-many relationship requires additional information describing the relationship itself. When we defined that Person-Address table above to represent the many-to-many relationship, we can add more columns to it for that extra information.</p> <p>Because we now have data we care about attached to the relationship, we now think of that Person-Address as an entity, and can link the three entities:</p> <pre><code>erDiagram\n    PERSON ||--o{ PERSON-ADDRESS : has-address\n    PERSON-ADDRESS }o--|| ADDRESS: has-address</code></pre> <p>The many-to-many relationship now looks like two one-to-many relationships:</p> <ul> <li>One Person can have zero or more Person-Addresses</li> <li>One Address can have zero or more Person-Addresses</li> <li>One Person-Address can have exactly one Person and one Address</li> </ul> <p>The Person-Address Entity now looks like</p> Attribute Type Key Comment personId String FK The ID of the related person addressId String FK The ID of the related address type String The type of address (home, work...)"},{"location":"modules/room/STEP_10_FULL.html#full-example","title":"Full Example","text":"<p>We can put them all together in a single diagram</p> <pre><code>erDiagram\n    PERSON ||--|| BIRTH-CERTIFICATE : born\n    PERSON ||--|{ ORGAN : has-organ\n    PERSON }o--|| PERSON-ADDRESS : has-address\n    PERSON-ADDRESS ||--|{ ADDRESS: has-address    </code></pre>"},{"location":"modules/room/STEP_20_FULL.html","title":"Room Basics","text":"<p>Room is a simple Object-Relational-Mapping (aka ORM) framework for Android.</p> <p>ORMs allow you to treat database tables as types in your programming language. Some require external definitions of your database and types. Others create databases and the access code by examining your types, which may include extra metadata such as annotations.</p> <p>Room takes the annotated-type approach. You define</p> <ul> <li>Entity classes</li> <li>Data-Access-Object interfaces (or abstract classes)</li> <li>Database abstract class</li> </ul> <p>and Room can generate the database, tables, and code to access them.</p> <p>When we walk through our movie example, we'll see how to set up the Room compiler as part of our build to process the annotated types and generate code.</p> <p>Note</p> <p>We're just going to show code snippets here; the setup needed for Room, as well as full example code, appears in the Movie Database Example.</p>"},{"location":"modules/room/STEP_20_FULL.html#entity","title":"Entity","text":"<p>Let's start by defining a simple entity using Room. </p> <pre><code>@Entity\ndata class Person(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var age: Int,\n    var ssn: String,\n)\n</code></pre> <p>We're using a Kotlin Data Class to define the entity type. The <code>@Entity</code> annotation tells the Room compiler to generate a database table and code to convert the class definition to/from a row in that table.</p> <p>The <code>@PrimaryKey</code> annotation tells the Room compiler which attribute represents the unique identifier for the entity. Here we see a Kotlin default value specification - if a caller creates a <code>Person</code> instance and does not specify the id, one will be created for them by generating a random <code>UUID</code>.</p> <p>When you want to create a <code>Person</code>, all you need to do is write</p> <pre><code>val person = Person(\n    name = \"Scott\", \n    age = 55,\n    ssn = \"123-45-6789\"\n)\n</code></pre> <p>You can then use a Data Access Object to store that <code>Person</code> in the database.</p> <p>By default the table name will be the class name, and all columns will be the property names. You can modify this, but we won't go into that detail in this class. If you want more detail, take a look at https://developer.android.com/training/data-storage/room.</p>"},{"location":"modules/room/STEP_20_FULL.html#data-access-object-dao","title":"Data Access Object (DAO)","text":"<p>A Data Access Object defines your \"CRUD\" functions. \"CRUD\" stands for \"Create, Read, Update and Delete\", the four types of queries you'll use to access and modify database contents.</p> <p>A simple DAO might look like</p> <pre><code>@Dao\ninterface PersonDao {\n    @Query(\"SELECT * FROM Person\")\n    fun getPeople(): List&lt;Person&gt;\n\n    @Query(\"SELECT * FROM Person WHERE id = :id\")\n    fun getPerson(id: String): Person\n\n    @Insert\n    fun insert(vararg people: Person)\n\n    @Update\n    fun update(vararg people: Person)\n\n    @Upsert\n    fun upsert(vararg people: Person)\n\n    @Delete\n    fun delete(vararg people: Person)\n\n    @Query(\"DELETE FROM Person WHERE id IN (:ids)\")\n    fun delete(ids: List&lt;String&gt;)\n}\n</code></pre> <p>Note</p> <p>This is an interface, but you can also define it as an abstract class. The Room compiler will generate an implementation (or subclass) with the details of how to perform the declared functions.</p> <p>Here we're defining some simple CRUD operations for a Person. </p> <ul> <li><code>getPeople()</code> - Returns a list of all <code>Person</code> instances in the table. Note that the specified SQL is just normal SQL, using the entity as the table name.</li> <li><code>getPerson(id)</code> - Returns a single person with the specified id. The <code>:id</code> syntax is replaced with the <code>id</code> parameter passed to the function.</li> <li><code>insert(people)</code> - inserts the passed <code>Person</code> instances into the database. By default, this will throw an exception if a passed <code>Person</code> has an <code>id</code> that's already in the table.</li> <li><code>update(people)</code> - updates the <code>Person</code> table with the values for each passed <code>Person</code>. Will throw an exception if any passed <code>Person</code> doesn't exist.</li> <li><code>upsert(people)</code> - updates or inserts to the <code>Person</code> table with the values for each passed <code>Person</code>. If the <code>Person</code> already exists, it will update; otherwise it will insert.</li> <li><code>delete(people)</code> - deletes the specified people from the table.</li> <li><code>delete(ids)</code> - deletes the people with the specified ids from the table. Note that we're using the <code>@Query</code> annotation here to tailor the deletion.</li> </ul> <p>Once you have a DAO instance, you just call the functions to access/modify data.</p> <p>Note</p> <p>All of the functions defined in this DAO are synchronous! You really don't want to call these from the user-interface thread or the UI may become \"janky\" (non-smooth animation, delays in user interaction, etc). Using the above DAO requires you to call the DAO functions from a different thread. We'll see how to do that shortly. We'll also see how to set up asynchronous queries in the DAO.</p> <p>Note</p> <p>You can define separate DAOs for separate entities, but you don't need to. If you don't have a huge number of DAO functions needed for your application, you can define them all in the same DAO interface/abstract class.</p>"},{"location":"modules/room/STEP_20_FULL.html#database","title":"Database","text":"<p>But how do we get an instance of a DAO? That's where the Database class comes in.</p> <pre><code>@Database(\n    version = 1,\n    entities = [\n        Person::class\n    ],\n    exportSchema = false\n)\nabstract class PersonDatabase: RoomDatabase() {\n    abstract val dao: PersonDao\n}\n</code></pre> <p>You define a database class with the <code>@Database</code> annotation, and the class must be abstract and extend <code>RoomDatabase</code>. The Room compiler will generate a subclass that creates the actual DAO instance you'll use to run your queries.</p> <p>By listing the entity classes in the <code>@Database</code> annotation, Room knows which tables it should create. Room also supports database migration (when the entity definitions change), but that's a more advanced topic and not covered in this class.)</p>"},{"location":"modules/room/STEP_20_FULL.html#usage","title":"Usage","text":"<p>Now that all the pieces are defined, we can use the database as follows.</p> <p>Note</p> <p>You'd normally put this code in a View Model or Repository class, spread across multiple functions.</p> <pre><code>val database = Room\n    .databaseBuilder(\n        context, \n            // An Android context, like an Activity, used\n            //   to locate the database file on the device\n        PersonDatabase::class.java, \n            // The database type to create\n        \"PEOPLE\"\n            // The name of the database file\n    )\n    .build()\n\nval person1 = Person(\n    name = \"Scott\",\n    age = 55, \n    ssn = \"123-45-6789\"\n)\nval person2 = Person(\n    name = \"Mikey\",\n    age = 10, \n    ssn = \"234-56-7890\"\n)\n\ndatabase.dao.insert(person1, person2)\n\nval people = database.dao.getPeople()\n\nperson1.age++\ndatabase.dao.update(person1)\n\ndatabase.dao.delete(person2)\n</code></pre> <p><code>Room.databaseBuilder</code> creates our database for us. Be sure to use only one instance of your database! The database has caching and other code that won't work as expected if you create multiple instances! Because of this, you usually want to hold onto your database in a View Model or Repository, or create the instance using Dependency Injection.</p> <p><code>Room.databaseBuilder</code> is written in Java, and because of this, you cannot use named parameters or pass the Kotlin KClass (<code>PersonDatabase::class</code>) as a parameter. You must pass the Java <code>Class</code> that represents the database by adding <code>.class</code>. The <code>Class</code> is metadata describing the type, and is using to create an instance of the type dynamically at runtime.</p> <p>Once you have a database, you can access the dao and calls its functions.</p>"},{"location":"modules/room/STEP_20_FULL.html#threading-issues","title":"Threading Issues","text":"<p>The problem with the code you've seen so far is that it might be invoked on the user interface thread, causing \"jank\", a poor-performing UI. It's important to perform the database processing on another thread. In this class, we'll use Kotlin's coroutines to perform our work.</p> <p>For data-access queries, we'll use <code>Flows</code>, collected in a coroutine. For everything else we'll launch a coroutine to perform the action.</p> <p>I'm going to do a lot of hand-waving on coroutines at this point (imagine you're watching a video with my hands flailing about) and explain them in more detail later in the course. For now, follow the patterns I'll describe and don't worry too much about how things work behind the scenes.</p> <p>For now, think of a coroutine as a helper that will run some code on a specific thread, and can switch to other threads depending on the work you need to run.</p> <p>Coroutines use Dispatchers to manage their execution on different threads. The \"Main\" dispatcher runs code on the user-interface thread. The \"IO\" dispatcher runs potentially blocking code on a set of threads optimized for blocking function calls. The \"Default\" dispatcher runs code on other background threads.</p> <p>Let's say that we want to display a message, fetch 10 items from the database, updating a progress bar and the message for each, then display a \"done\" message. For this type of processing, we need to update the message and progress bar on the UI thread, and fetch the items from the database on a background thread.</p> <p>Our coroutine might look like</p> <pre><code>fun doStuff() {\n    scope.launch(Dispatchers.Main) { \n        showMessage(\"Fetching data...\")\n        repeat(10) { n -&gt;\n            val item = withContext(Dispatchers.IO) {\n                fetch(n)\n            }\n            showMessage(item.message)\n            updateProgress(n)\n        }\n        showMessage(\"All data fetched!\")\n    }\n}\n</code></pre> <p>Notice how this is just a function, and it looks like normal imperative logic. But it's actually switching threads! And we don't need to set up callbacks or other constructs to pass values around or trigger thread changes.</p> <p>The <code>withContext(...)</code> function switches over to the IO dispatcher to run our background work, then returns back to the Main (UI) dispatcher to update the UI.</p> <p>Note</p> <p>The code we'll write will be even simpler, as we'll be updating state for our UI rather than switching over the UI thread to update the UI directly.</p>"},{"location":"modules/room/STEP_20_FULL.html#using-flows","title":"Using <code>Flows</code>","text":"<p>Kotlin <code>Flows</code> allow your coroutine to fetch new data as it becomes available. We can tweak our DAO data-access functions to return <code>Flows</code> rather than just data:</p> <pre><code>@Query(\"SELECT * FROM Person\")\nfun getPeople(): Flow&lt;List&lt;Person&gt;&gt;\n\n@Query(\"SELECT * FROM Person WHERE id = :id\")\nfun getPerson(id: String): Flow&lt;Person&gt;\n</code></pre> <p>So what does this do? We can now call <code>getPeople()</code> or <code>getPerson()</code> and it will immediately return a <code>Flow</code>. We collect it from a coroutine</p> <pre><code>val people = database.dao.getPeople()\n    // returns the Flow immediately\n\nscope.launch { \n    // watch the Flow for new lists when data changes\n    people.collect { people -&gt;\n        // display the current list of people\n    }\n}\n</code></pre> <p>The coroutine will ask for the next list of people to process, and suspend until a new list is available. (We'll talk more about \"suspension\" later, but in a nutshell, it allows the dispatcher to process other coroutines rather than blocking to wait for the next result to come in.) On the database side, a trigger is installed to serve up a new list when the data changes. The <code>collect</code> will keep receiving new lists until we cancel the coroutine (when its host scope is canceled - could be when the application or current activity is closed).</p>"},{"location":"modules/room/STEP_20_FULL.html#one-shot-dao-functions","title":"One-Shot DAO Functions","text":"<p>But what if we just want to run a DAO function and not receive updates? Or what if the function is an insert/update/delete?</p> <p>We want to call these functions and wait for the result. This call needs to be on a non-UI thread.</p> <p>In our examples, we again use Kotlin coroutines. For example, let's call an update function in the DAO:</p> <pre><code>scope.launch {\n    database.dao.update(person1)\n}\n</code></pre> <p>Here we kick off a coroutine to perform some work and call the update function. But what thread does this run on? That depends on the scope used to launch the coroutine, and would be a decision for the caller to make.</p> <p>We could do</p> <pre><code>scope.launch(Dispatchers.IO) {\n    database.dao.update(person1)\n}\n</code></pre> <p>but this has a few problems. </p> <p>First, as mentioned, the caller has to choose the dispatcher. When you leave things to the caller reading the documentation that says \"make sure you run this off the UI thread\", some calls are going to miss it.</p> <p>Second, Room cannot optimize the way that the database is accessed, because it doesn't know we're running the function in a coroutine.</p> <p>So let's tell Room.</p>"},{"location":"modules/room/STEP_25_FULL.html","title":"Room Relations","text":"<p>So far we've only talked about entities by themselves. But we really need relationships to make things work.</p> <p>There are two general approaches to making relationships work</p> <ul> <li>Helper class: You define a non-entity class to hold data and explicitly pull columns<ul> <li><code>@Embedded</code> objects can group attributes into objects</li> <li><code>@Relation</code> objects run secondary queries automatically</li> </ul> </li> <li>Multi-map: Specify a <code>Map&lt;Entity, List&lt;OtherEntity&gt;&gt;</code> as the return type on a DAO function</li> </ul> <p>We'll look into using some of these in a few examples, which should be enough for the class assignment. For a more detailed discussion see https://developer.android.com/training/data-storage/room/relationships.</p>"},{"location":"modules/room/STEP_25_FULL.html#fetching-partial-data","title":"Fetching Partial Data","text":"<p>You can use a helper class to fetch partial data from an Entity.</p> <p>Let's start by only fetching the <code>name</code> and <code>age</code> of <code>Person</code> entities. Recall that our <code>Person</code> looks like</p> <pre><code>@Entity\ndata class Person(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var age: Int,\n    var ssn: String,\n)\n</code></pre> <p>If we only want the <code>name</code> and <code>age</code>, we can define a data class with just those properties:</p> <pre><code>data class NameAndAge(\n    val name: String,\n    val age: Int,\n)\n</code></pre> <p>Note</p> <p>Note that <code>NameAndAge</code> does not have the <code>@Entity</code> annotation! It's just a normal data class!</p> <p>And then in the DAO, you can define</p> <pre><code>@Query(\"SELECT name, age FROM Person\")\nfun getNamesAndAges(): Flow&lt;List&lt;NameAndAge&gt;&gt;\n</code></pre> <p>Room will fill the <code>NameAndAge</code> instances, not returning the <code>id</code> or <code>ssn</code>. (This would also work with a <code>\"SELECT * FROM Person\"</code> query, but that would fetch all the data from the database before creating <code>NameAndAge</code> objects with just the <code>name</code> and <code>age</code>)</p>"},{"location":"modules/room/STEP_25_FULL.html#one-to-one","title":"One-to-One","text":"<p>Let's set up support to fetch a <code>BirthCertificate</code> while we're fetching a <code>Person</code>. Suppose we have entities</p> <pre><code>@Entity\ndata class Person(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var age: Int,\n    var ssn: String,\n)\n\n@Entity\ndata class BirthCertificate(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var owningPersonId: String,\n    var fatherName: String,\n    var motherName: String,\n    var birthTime: Long,\n)\n</code></pre> <p>We want to fetch a <code>Person</code> and its associated <code>BirthCertificate</code> at the same time. So we create</p> <pre><code>data class PersonAndBirthCertificate(\n    @Embedded\n    val person: Person,\n    @Relation(\n        parentColumn = \"id\", \n            // the id attribute of the \"owner\"\n        entityColumn = \"owningPersonId\",\n            // the foreign key in the related item that holds the \n            //   owner id\n    )\n    val birthCertificate: BirthCertificate\n)\n\n// (in the DAO)\n@Transaction\n@Query(\"SELECT * FROM Person\")\nfun getPeopleWithBirthCertificates(): Flow&lt;List&lt;PersonAndBirthCertificate&gt;&gt;\n</code></pre> <p>Our helper class, <code>PersonAndBirthCertificate</code> contains two objects - a <code>Person</code> and a <code>BirthCertificate</code>. Surprise!</p> <p>Let's talk through how they get filled in.</p> <ol> <li>We run the <code>getPeopleWithBirthCertificates</code> function in the Dao.</li> <li>The <code>\"SELECT * FROM Person\"</code> query is run, fetching all <code>Person</code> data from the table.</li> <li>Room looks at the return type and creates a <code>PersonAndBirthCertificate</code> instance for each row in the table.</li> <li> <p>Room sees the <code>@Embedded</code> annotation on <code>person</code> and copies the data from all columns matching properties in the <code>Person</code> to a new <code>Person</code> instance.       Note that the <code>@Embedded</code> object doesn't have to be the same type as table we're querying. It could be a partial-data class that contains properties that match columns in the table. Note that you can use <code>@ColumnInfo</code> annotations to create custom mappings between column names and properties, but we're not covering that in this class.</p> </li> <li> <p>Room sees a <code>@Relation</code> annotation on the <code>birthCertificates</code> property, and runs another query to fetch the <code>BirthCertificates</code>.</p> <ul> <li>The <code>@Relation</code> annotation specifies a <code>parentColumn</code> and <code>entityColumn</code>.</li> <li><code>parentColumn</code> is the column in the original query that is considered the id of the owner</li> <li><code>entityColumn</code> is the foreign key inside the related object (the one specified as the type of the annotated property, <code>BirthCertificate</code> in this example)</li> <li>Room's query fetches from the <code>BirthCertificate</code> table grabbing entities that have a <code>owningPersonId</code> that matches the <code>id</code> of each <code>Person</code></li> </ul> </li> <li>Room fills in the <code>BirthCertificate</code> for each <code>PersonWithBirthCertificate</code></li> </ol> <p>You can have multiple <code>@Relation</code> annotations inside the helper class, but note that they each result in running an extra query. You can also nest relations, where related objects can contain their own <code>@Relation</code> annotations to create a larger graph of results.</p> <p>Note</p> <p>Did you notice the <code>@Transaction</code> annotation on the <code>getPeopleWithBirthCertificates</code> function? This ensures that no matter how many queries are run when the function is called, they're all treated atomically. No updates can happen between any of the queries, keeping the returned data consistent. Whenever you use <code>@Relation</code>, make sure any DAO functions that reference the class containing it are marked with <code>@Transaction</code>.</p> <p><code>@Transaction</code> can also be used when defining non-abstract functions in a DAO. For example, suppose you want to define a <code>transfer</code> function in a banking DAO that removes funds from one account and deposits them in another account. You would need a <code>@Transaction</code> annotation on such a function so the operation is atomic. You'd never want it to be able to only deposit or withdraw. You could write (if the DAO is an abstract class):</p> <pre><code>@Transaction\nfun transfer(\n    from: Account,\n    to: Account,\n    amount: Long\n) {\n    withdraw(from, amount)\n    deposit(to, amount)\n}\n</code></pre>"},{"location":"modules/room/STEP_25_FULL.html#one-to-many","title":"One-to-Many","text":"<p>One-to-Many works almost exactly like One-to-One. The only difference is the declaration of the related property in the helper object. For our <code>Organs</code> example, we could define</p> <pre><code>@Entity\ndata class Person(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var age: Int,\n    var ssn: String,\n)\n\n@Entity\ndata class Organ(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var owningPersonId: String,\n    var type: String,\n)\n</code></pre> <p>for our entities, and</p> <pre><code>data class PersonAndOrgans(\n    @Embedded\n    val person: Person,\n    @Relation(\n        parentColumn = \"id\",\n        // the id attribute of the \"owner\"\n        entityColumn = \"owningPersonId\",\n        // the foreign key in the related item that holds the\n        //   owner id\n    )\n    val organs: List&lt;Organ&gt;\n)\n\n// and in the DAO\n@Transaction\n@Query(\"SELECT * FROM Person\")\nfun getPeopleAndOrgans(): Flow&lt;List&lt;PersonAndOrgans&gt;&gt;\n</code></pre> <p>The only difference here is that our related property, <code>organs</code> is a <code>List</code> rather than a single-value property.</p>"},{"location":"modules/room/STEP_25_FULL.html#many-to-many","title":"Many-to-Many","text":"<p>Things get more complex when we define a many-to-many relationship. Take our example of <code>Person</code> and <code>Address</code>:</p> <pre><code>@Entity\ndata class Person(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var name: String,\n    var age: Int,\n    var ssn: String,\n)\n\n@Entity\ndata class Address(\n    @PrimaryKey var id: String = UUID.randomUUID().toString(),\n    var street: String,\n    var city: String,\n    var state: String,\n    var zipCode: String,\n)\n\n@Entity(\n    primaryKeys = [\"personId\", \"addressId\"]\n)\ndata class PersonAddress(\n    var personId: String,\n    var addressId: String,\n)\n</code></pre> <p>These three entities give us a many-to-many relationship:</p> <ul> <li>A <code>Person</code> can have multiple <code>Address</code> entities (home, work, etc)</li> <li>An <code>Address</code> can host multiple <code>Person</code> entities.</li> </ul> <p>All three are entities, and we can use helper objects to fetch a <code>Person</code> or <code>Address</code> and the related other:</p> <pre><code>data class PersonAndAddresses(\n    @Embedded\n    val person: Person,\n    @Relation(\n        parentColumn = \"id\",\n            // which property represents the id of the person \n            //    (the main entity we're fetching)\n        entityColumn = \"id\",\n            // which property represents the id of the Address (the related entity)\n        associateBy = Junction(\n            PersonAddress::class,\n            parentColumn = \"personId\",\n                // which property **in the association table** represents\n                //   the id of the person (the main entity we're fetching)\n            entityColumn = \"addressId\",\n                // which property **in the association table** represents\n                //   the id of the Address (the related entity)\n        ),\n    )\n    val addresses: List&lt;Address&gt;\n)\n\n// in the DAO\n@Transaction\n@Query(\"SELECT * FROM Person\")\nfun getPeopleAndAddresses(): Flow&lt;List&lt;PersonAndAddresses&gt;&gt;\n</code></pre> <p>Similar to before, but we add an <code>associateBy</code> attribute to describe the association table. Room maps the <code>parentColumn</code> of the <code>@Relation</code> to the <code>parentColumn</code> in the <code>Junction</code>, and the <code>entityColumn</code> in the <code>@Relation</code> to the <code>entityColumn</code> in the <code>Junction</code>. </p> <p>This ends up running two queries. First, get all the <code>Person</code> entities.</p> <pre><code>SELECT * FROM Person\n</code></pre> <p>Room now has all the <code>Person</code> data, including the <code>ids</code> of each <code>Person</code>. Room will now run its second query, passing those ids (I'm representing them as <code>$personIds</code> in this query).</p> <pre><code>SELECT \n    Address.id, Address.street, Address.city, \n    Address.state, Address.zip\nFROM PersonAddress \nINNER JOIN Address ON (PersonAddress.addressId = Address.id)\nWHERE PersonAddress.personId IN ($personIds)\n</code></pre>"},{"location":"modules/room/STEP_30_FULL.html","title":"Suspending Functions","text":"<p>Many operations in a multi-threaded application end up blocking the current thread, and it cannot be used for any other work while it's blocked. Think about a <code>sleep</code> function. You've got some background work running, and it wants to pause for a moment (perhaps you're checking if something has changed once a minute). This ties up the thread that's being used to run that operation.</p> <p>Threads are a limited resource. Using them like this severely limits concurrency on your machine. What we'd like to do is allow other operations to be performed while we're waiting.</p> <p>This is where suspending functions come into play. A suspending function is one that can be paused when it's called, with the current state of its caller captured.</p> <p>Coroutines are cooperative. Java threads are pre-emptive. </p> <p>Long ago, multitasking was all about being cooperative. Your program would start running on a CPU, and would keep running until you would yield, telling the CPU it was ok to give another program a turn. Your state was saved, the CPU would run something else, and it would yield to allow you (or something else picked by the scheduler) to run.</p> <p>But all it took was one rogue program to hog the CPU and starve all other programs until it was done. This wouldn't necessarily be done by a malicious programmer; it was easy to accidentally omit the yield, as it depended upon the programmer reading the right chunk of documentation.</p> <p>Pre-emptive multitasking got rid of that worry. When multiple programs wanted to run at the same time, the CPU scheduler would grant each a chunk of time on one of its threads, then switch to another program. It wasn't up to the programmer.</p> <p>Kotlin is most often run on top of the Java Virtual Machine (JVM), which uses a pre-emptive threading model. When we use cooperative coroutines, we get an interesting mix of threading models that works well in our favor. A coroutine cannot starve other processes that want to use a thread, as the pre-emptive nature of the JVM will force switches.</p> <p>But if a blocking operation (like a <code>sleep</code>) is performed, the CPU will keep switching back to the operation, wasting time that other processes could use.</p> <p>Coroutine work is scheduled in a way that can decide when it really needs to use a thread. Instead of blocking a thread from being used while <code>sleep</code> is called, we use <code>delay</code>, which interacts with the scheduler to request to be continued at a later time. Other coroutines can then use the underlying thread, allowing much better concurrency.</p> <p>Marking a function with the <code>suspend</code> keyword causes the Kotlin compiler to modify that function to pass an additional parameter called a \"continuation\". Whenever a suspend function is called from within it, the continuation remembers our function state so we can restart at that point later. The scheduler can then use the thread that the suspend function was being run on. Later, when our suspend function gets another chance to run, the continuation is used to execute the next chunk (up until another suspend function is called). For more detail on how this works, check out Suspend functions - Kotlin vocabulary.</p> <p>Suspending functions can only be called from another <code>suspend</code> function or within a coroutine, started by <code>launch</code> (no result needed) or <code>async</code> (allows us to wait for a result).</p> <p>Dispatchers manage one or more threads as a group. As we've seen earlier, we use dispatchers to switch the coroutine processing to work on a different thread using the <code>withContext(dispatcher)</code> function, which is itself a suspending function!</p> <p>Google's current advice is that suspending functions should be \"main-thread safe\". If the function is called from the main (UI) thread, it should use <code>withContext</code> to switch to a different dispatcher.</p> <p>For example, if we wanted to define a function to update a person in the database, we could write</p> <pre><code>suspend fun updatePerson(person: Person) {\n    withContext(Dispatchers.IO) {\n        database.dao.update(person)\n    }\n}\n</code></pre> <p>This function is main-safe, as it forces a switch to the IO dispatcher. Often you'll see suspend functions written using Kotlin's single-expression-function syntax. (<code>withContext</code> will return the value that its lambda returns).</p> <pre><code>suspend fun updatePerson(person: Person) = withContext(Dispatchers.IO) {\n    database.dao.update(person)\n}\n</code></pre> <p>Because this is a common task to perform, and because Room can perform some extra optimization if it knows it's running in a coroutine, we can add <code>suspend</code> to our DAO function declarations. The Room compiler will create a main-safe suspending function for you:</p> <pre><code>@Dao\ninterface PersonDao {\n    ...\n    @Insert\n    suspend fun insert(vararg person: Person)\n\n    @Update\n    suspend fun update(vararg person: Person)\n\n    @Delete\n    suspend fun delete(vararg person: Person)\n\n    @Query(\"DELETE FROM Person WHERE id IN (:ids)\")\n    suspend fun delete(ids: List&lt;String&gt;)\n}\n</code></pre> <p>This forces you to launch coroutines to call these functions (<code>suspend</code> functions can only be called from coroutines or other <code>suspend</code> functions) and switches to a dispatcher that Room defines to optimize the database access.</p>"},{"location":"modules/room/STEP_40_FULL.html","title":"The Repository","text":"<p>A Repository is an optional abstraction at the top of the Data Layer. It's often used to</p> <ul> <li>Expose data from multiple data sources</li> <li>Cache data from a remote data source (such as a web service) in a local data source (such as a database or file)</li> <li>Convert data into Data Transfer Objects that expose a more restricted view of the data</li> </ul> <p>In this class, we'll be using it to create Data Transfer Objects. If you're interested in other uses of a Repository, search online for terms such as \"Android Repository Cache\".</p> <p>But first, where does the Repository go? It's part of the Data Layer, but by smart use of Modules in your application, you can take advantage of dependencies between modules to prevent other layers from accidentally accessing data directly.</p> <pre><code>flowchart LR\n    subgraph User Interface Layer\n    ui[User Interface Module\\nView Model\\nUser interface]\n    end\n    ui --&gt; repo\n    subgraph Data Layer\n    repo[Repository Module\\nRepository\\nData Transfer Objects]\n    ds[Data Source Module\\nEntities\\nDAO]\n    repo --&gt; ds\n    end</code></pre> <p>The separate Repository Module prevents the User Interface Module from directly accessing anything in the Data Source Module (assuming you set up module dependencies in your build to restrict that). It's a great way to hide details as well as make the data we use in the user interface immutable, which is great for the Jetpack Compose UI that we'll be creating.</p> <p>We'll see how these modules are set up when we're walking through the example code.</p>"},{"location":"modules/room/STEP_40_FULL.html#repository-code","title":"Repository Code","text":"<p>So what does the code in the Repository module look like? </p> <p>First, let's define a Data Transfer Object for our Person:</p> <pre><code>data class PersonDto(\n    val id: String,\n    val name: String,\n    val age: Int,\n    val ssn: String,\n) \n</code></pre> <p>Note that all of the properties here are <code>val</code> properties; we can only read them; we cannot change them. We can also define a couple of helper extension functions</p> <pre><code>internal fun Person.toDto() =\n    PersonDto(\n        id = id,\n        name = name,\n        age = age,\n        ssn = ssn\n    )\n\ninternal fun PersonDto.toEntity() =\n    Person(\n        id = id,\n        name = name,\n        age = age,\n        ssn = ssn\n    )\n</code></pre> <p>Kotlin extension functions make it look like we're defining new functions on existing types. Here we add a <code>toDto</code> function to our <code>Person</code> entity, and a <code>toEntity</code> function to our <code>PersonDto</code>. </p> <p>Note that both functions are marked <code>internal</code>. This restricts their use to inside of the module defining them. We're only doing the transformation inside the Repository module. Marking them <code>internal</code> allows us to use them anywhere within the module, no matter which package.</p> <p>Next, we define an interface for the Repository:</p> <pre><code>interface PersonRepository {\n    val peopleFlow: Flow&lt;List&lt;PersonDto&gt;&gt;\n    suspend fun insert(vararg people: PersonDto)\n    suspend fun update(vararg people: PersonDto)\n    suspend fun delete(vararg people: PersonDto)\n}\n</code></pre> <p>Note that this interface only uses the <code>PersonDto</code>, not the <code>Person</code> entity. We're only exposing the DTO.</p> <p>We can (and will) have multiple implementations of this interface. We'll start with one that talks to a Room database, and later in the course we'll implement it by talking to a web service.</p> <pre><code>class PersonDatabaseRepository(\n    context: Context\n): PersonRepository {\n    private val dao =\n        Room.databaseBuilder(\n            context,\n            PersonDatabase::class.java,\n            \"PEOPLE\"\n        )\n        .build()\n        .dao\n\n    ...\n}\n</code></pre> <p>To create a Room database instance, we need an Android <code>Context</code>. The <code>Context</code> (typically an <code>Application</code> or <code>Activity</code> instance) gives us access to details about the application, such as where our database files are stored.</p> <p>We pass that to the <code>PersonDatabaseRepository</code>, create a database instance and grab the DAO from it.</p> <p>Next, we expose a <code>Flow&lt;List&lt;PersonDto&gt;&gt;</code>. To do this, we'll take advantage of the <code>map</code> operator on <code>Flow</code>. <code>map</code> creates a new <code>Flow</code> by collecting objects from a <code>Flow</code> and transforming each item into something else.</p> <pre><code>class PersonDatabaseRepository(\n    context: Context\n): PersonRepository {\n    private val dao = ...\n\n    override val peopleFlow =\n        dao.getPeople()\n            .map { people -&gt;                // AAA\n                people.map { it.toDto() }   // BBB\n            }\n\n    ...    \n}\n</code></pre> <p>The first <code>map</code> call creates that new <code>Flow</code>. Whenever we get a new value, the <code>List&lt;Person&gt;</code>, we pass it to the lambda starting on line <code>AAA</code>. That list is represented by lambda parameter <code>people</code>.</p> <p>Using a <code>map</code> operator against that list (line <code>BBB</code>), we create a new list by converting each <code>Person</code> into a <code>PersonDto</code>. </p> <p>Anyone collecting <code>peopleFlow</code> will get a <code>List&lt;PersonDto&gt;</code> that contains a read-only copy of the <code>Person</code> entity data.</p> <p>The one-shot functions are all implemented similarly, so we'll just talk through the <code>insert</code> function.</p> <pre><code>class PersonDatabaseRepository(\n    context: Context\n): PersonRepository {\n    private val dao = ...\n\n    ...\n\n    override suspend fun insert(vararg people: PersonDto) =\n        dao.insert(\n            *people                     // AAA\n                .map { it.toEntity() }  // BBB\n                .toTypedArray()         // CCC\n        )\n\n    override suspend fun update(vararg people: PersonDto) = ...\n        // similar to insert\n\n    override suspend fun delete(vararg people: PersonDto) = ...\n        // similar to insert\n}\n</code></pre> <p>The caller will pass in a varying-length argument list of <code>PersonDto</code> instances. This means they can pass any number of <code>PersonDtos</code> into <code>insert</code>, separarted by commas. For example</p> <pre><code>repository.insert(person1)\nrepository.insert(person1, person2, person3)\n</code></pre> <p>are valid calls to <code>insert</code>. </p> <p>Inside <code>insert</code>, the <code>people</code> parameter is an <code>Array&lt;PersonDto&gt;</code>. We need to convert each <code>PersonDto</code> to a <code>Person</code> entity.</p> <p>Line <code>BBB</code> converts <code>people</code> into a <code>List&lt;Person&gt;</code>.</p> <p>But now we need to pass those <code>Person</code> instances into a varying-length, comma-separated argument list. Java would allow you to just pass an array, but that caused some ambiguity problems. Kotlin removed the ambiguity, but it had to make things a little more complex in the process.</p> <p>We need to \"spread\" the values out as a comma-separated list. That's what the <code>*</code> does on line <code>AAA</code>. <code>*</code> is called the \"spread operator\" in this context. But it only works against an <code>Array</code> of values, so we need to call <code>toTypedArray</code> on line <code>CCC</code> to convert our new <code>List&lt;Person&gt;</code> into an <code>Array&lt;Person&gt;</code>.</p> <p>Once spread, we pass the values into the DAO's <code>insert</code> function.</p> <p>Implement the <code>update</code> and <code>delete</code> functions similarly, and we now have a repository that isolates the Room data from the User Interface Layer.</p>"},{"location":"modules/speech/index.html","title":"Video","text":""},{"location":"modules/speech/index.html#introduction","title":"Introduction","text":"<p>Android applications can speak to you, and allow you to speak with them!</p> <p>In this module, we'll look at the Android text-to-speech and speech-to-text APIs, and build a simple text-adventure game that can be played without typing!</p>"},{"location":"modules/speech/index.html#videos","title":"Videos","text":"<p>Total video time for this module: 51:23</p>"},{"location":"modules/speech/index.html#speech-overview-fall-2021-1535","title":"Speech: Overview (Fall 2021) (15:35)","text":""},{"location":"modules/speech/index.html#speech-example-fall-2021-3548","title":"Speech: Example (Fall 2021) (35:48)","text":""},{"location":"modules/speech/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/speech. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>speech</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/speech\n</code></pre>"},{"location":"modules/testing/index.html","title":"Testing","text":""},{"location":"modules/testing/index.html#introduction","title":"Introduction","text":"<p>Automated tests can greatly improve the quality of your projects. You can run quick unit tests to check out non platform code, such as view models and algorithms, and instrumented tests that run on an emulator to test platform interaction such as user interfaces and databases.</p> <p>In this module we'll add some tests to a simplified movies application.</p> <p>This is recording of a live lecture that I gave Summer 2021. There are a few rough spots near the end of the first part of the example (live coding works well for me most of the time, but when it goes south, it does so spectacularly), but they're worked out in the second part of the example.</p>"},{"location":"modules/testing/index.html#videos","title":"Videos","text":"<p>Total video time for this module: 1:58:35</p>"},{"location":"modules/testing/index.html#testing-example-part-1-summer-2021-10204","title":"Testing: Example, Part 1 (Summer 2021) (1:02:04)","text":""},{"location":"modules/testing/index.html#testing-example-part-2-summer-2021-5631","title":"Testing: Example, Part 2 (Summer 2021) (56:31)","text":""},{"location":"modules/testing/repo.html","title":"Sample Repository","text":"<p>Sample code for this module is located at https://gitlab.com/605-686/spring-2025-refresh/modules/testing. Download the repository using git.</p> <p>Run the following command from a folder that will contain all of your git repositories. The command will create a new directory named <code>testing</code></p> <pre><code>git clone https://gitlab.com/605-686/spring-2025-refresh/modules/testing\n</code></pre>"}]}